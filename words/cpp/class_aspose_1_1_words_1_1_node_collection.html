<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"[]>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="description" content="Represents a collection of nodes of a specific type."/>
<meta property="og:title" content="Aspose.Words for C++ API Reference: Aspose::Words::NodeCollection Class Reference"/>
<meta property="og:type" content="website"/>
<meta property="og:description" content="Represents a collection of nodes of a specific type."/>
<meta property="og:url" content="https://apireference.aspose.com/words/cpp/class/aspose.words.node_collection"/>
<meta property="og:image" content="https://www.aspose.com/templates/aspose/App_Themes/V3/images/words/272x272/aspose_words-for-cpp.png"/>
<meta property="og:image:alt" content="Aspose.Words for C++ Logo"/>
<title>Aspose.Words for C++ API Reference: Aspose::Words::NodeCollection Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aspose.Words for C++ API Reference
   &#160;<span id="projectnumber">21.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_aspose_1_1_words_1_1_node_collection.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_aspose_1_1_words_1_1_node_collection-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Aspose::Words::NodeCollection Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details" href=""></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a collection of nodes of a specific type. </p>
<p><b>NodeCollection</b> does not own the nodes it contains, rather, is just a selection of nodes of the specified type, but the nodes are stored in the tree under their respective parent nodes.</p>
<p><b>NodeCollection</b> supports indexed access, iteration and provides add and remove methods.</p>
<p>The <b>NodeCollection</b> collection is "live", i.e. changes to the children of the node object that it was created from are immediately reflected in the nodes returned by the <b>NodeCollection</b> properties and methods.</p>
<p><b>NodeCollection</b> is returned by <a class="el" href="class_aspose_1_1_words_1_1_composite_node.html#getchildnodes_nodetype_bool">GetChildNodes()</a> and also serves as a base class for typed node collections such as <a class="el" href="class_aspose_1_1_words_1_1_section_collection.html">SectionCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_paragraph_collection.html">ParagraphCollection</a> etc.</p>
<p><b>NodeCollection</b> can be "flat" and contain only immediate children of the node it was created from, or it can be "deep" and contain all descendant children.</p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to replace all textbox shapes with image shapes. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;(MyDir + u<span class="stringliteral">"Textboxes in drawing canvas.docx"</span>);</div>
<div class="line"> </div>
<div class="line">ArrayPtr&lt;SharedPtr&lt;Shape&gt;&gt; shapes = doc-&gt;GetChildNodes(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_shape" title="A drawing object, such as an OfficeArt shape, image or an OLE object. A Shape node can contain Paragr...">NodeType::Shape</a>, <span class="keyword">true</span>)-&gt;LINQ_OfType&lt;SharedPtr&lt;Shape&gt;&gt;()-&gt;LINQ_ToArray();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> isTextBox = [](SharedPtr&lt;Shape&gt; s)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> s-&gt;get_ShapeType() == ShapeType::TextBox;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> isImage = [](SharedPtr&lt;Shape&gt; s)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> s-&gt;get_ShapeType() == ShapeType::Image;</div>
<div class="line">};</div>
<div class="line">ASSERT_EQ(3, shapes-&gt;LINQ_Count(isTextBox));</div>
<div class="line">ASSERT_EQ(1, shapes-&gt;LINQ_Count(isImage));</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (SharedPtr&lt;Shape&gt; shape : shapes)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (shape-&gt;get_ShapeType() == ShapeType::TextBox)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> replacementShape = MakeObject&lt;Shape&gt;(doc, ShapeType::Image);</div>
<div class="line">        replacementShape-&gt;get_ImageData()-&gt;SetImage(ImageDir + u<span class="stringliteral">"Logo.jpg"</span>);</div>
<div class="line">        replacementShape-&gt;set_Left(shape-&gt;get_Left());</div>
<div class="line">        replacementShape-&gt;set_Top(shape-&gt;get_Top());</div>
<div class="line">        replacementShape-&gt;set_Width(shape-&gt;get_Width());</div>
<div class="line">        replacementShape-&gt;set_Height(shape-&gt;get_Height());</div>
<div class="line">        replacementShape-&gt;set_RelativeHorizontalPosition(shape-&gt;get_RelativeHorizontalPosition());</div>
<div class="line">        replacementShape-&gt;set_RelativeVerticalPosition(shape-&gt;get_RelativeVerticalPosition());</div>
<div class="line">        replacementShape-&gt;set_HorizontalAlignment(shape-&gt;get_HorizontalAlignment());</div>
<div class="line">        replacementShape-&gt;set_VerticalAlignment(shape-&gt;get_VerticalAlignment());</div>
<div class="line">        replacementShape-&gt;set_WrapType(shape-&gt;get_WrapType());</div>
<div class="line">        replacementShape-&gt;set_WrapSide(shape-&gt;get_WrapSide());</div>
<div class="line"> </div>
<div class="line">        shape-&gt;get_ParentNode()-&gt;InsertAfter(replacementShape, shape);</div>
<div class="line">        shape-&gt;Remove();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">shapes = doc-&gt;GetChildNodes(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_shape" title="A drawing object, such as an OfficeArt shape, image or an OLE object. A Shape node can contain Paragr...">NodeType::Shape</a>, <span class="keyword">true</span>)-&gt;LINQ_OfType&lt;SharedPtr&lt;Shape&gt;&gt;()-&gt;LINQ_ToArray();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(0, shapes-&gt;LINQ_Count(isTextBox));</div>
<div class="line">ASSERT_EQ(4, shapes-&gt;LINQ_Count(isImage));</div>
<div class="line"> </div>
<div class="line">doc-&gt;Save(ArtifactsDir + u<span class="stringliteral">"Shape.ReplaceTextboxesWithImages.docx"</span>);</div>
</div><!-- fragment --> </div>
<p><code>#include &lt;<a class="el" href="_node_collection_8h_source.html">Aspose.Words.Cpp/NodeCollection.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for Aspose::Words::NodeCollection:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
 <div class="center">
  <img src="class_aspose_1_1_words_1_1_node_collection.png" usemap="#Aspose::Words::NodeCollection_map" alt="Aspose::Words::NodeCollection"/>
  <map id="Aspose::Words::NodeCollection_map" name="Aspose::Words::NodeCollection_map">
<area target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.collections.generic.i_enumerable" alt="System::Collections::Generic::IEnumerable&lt; System::SharedPtr&lt; Aspose::Words::Node &gt; &gt;" shape="rect" coords="528,56,1046,80"/>
<area target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.object" alt="System::Object" shape="rect" coords="528,0,1046,24"/>
<area href="class_aspose_1_1_words_1_1_building_blocks_1_1_building_block_collection.html" title="A collection of BuildingBlock objects in the document." alt="Aspose::Words::BuildingBlocks::BuildingBlockCollection" shape="rect" coords="792,168,1310,192"/>
<area href="class_aspose_1_1_words_1_1_comment_collection.html" title="Provides typed access to a collection of Comment nodes." alt="Aspose::Words::CommentCollection" shape="rect" coords="792,224,1310,248"/>
<area href="class_aspose_1_1_words_1_1_header_footer_collection.html" title="Provides typed access to HeaderFooter nodes of a Section." alt="Aspose::Words::HeaderFooterCollection" shape="rect" coords="792,280,1310,304"/>
<area href="class_aspose_1_1_words_1_1_paragraph_collection.html" title="Provides typed access to a collection of Paragraph nodes." alt="Aspose::Words::ParagraphCollection" shape="rect" coords="792,336,1310,360"/>
<area href="class_aspose_1_1_words_1_1_run_collection.html" title="Provides typed access to a collection of Run nodes." alt="Aspose::Words::RunCollection" shape="rect" coords="792,392,1310,416"/>
<area href="class_aspose_1_1_words_1_1_section_collection.html" title="A collection of Section objects in the document." alt="Aspose::Words::SectionCollection" shape="rect" coords="792,448,1310,472"/>
<area href="class_aspose_1_1_words_1_1_tables_1_1_cell_collection.html" title="Provides typed access to a collection of Cell nodes." alt="Aspose::Words::Tables::CellCollection" shape="rect" coords="792,504,1310,528"/>
<area href="class_aspose_1_1_words_1_1_tables_1_1_row_collection.html" title="Provides typed access to a collection of Row nodes." alt="Aspose::Words::Tables::RowCollection" shape="rect" coords="792,560,1310,584"/>
<area href="class_aspose_1_1_words_1_1_tables_1_1_table_collection.html" title="Provides typed access to a collection of Table nodes." alt="Aspose::Words::Tables::TableCollection" shape="rect" coords="792,616,1310,640"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods" href=""></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a068f070b5bbd81992e895bd3a9b7a909"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#add_node">Add</a> (const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Node</a> &gt; &amp;node)</td></tr>
<tr class="memdesc:a068f070b5bbd81992e895bd3a9b7a909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a node to the end of the collection.  <a href="class_aspose_1_1_words_1_1_node_collection.html#add_node">More...</a><br/></td></tr>
<tr class="separator:a068f070b5bbd81992e895bd3a9b7a909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c84bf176a96e3f048ff328ef0ef67aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#clear">Clear</a> ()</td></tr>
<tr class="memdesc:a5c84bf176a96e3f048ff328ef0ef67aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all nodes from this collection and from the document.  <a href="class_aspose_1_1_words_1_1_node_collection.html#clear">More...</a><br/></td></tr>
<tr class="separator:a5c84bf176a96e3f048ff328ef0ef67aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb103bc9c0ef36a0593141c957dec4ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#contains_node">Contains</a> (const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Node</a> &gt; &amp;node)</td></tr>
<tr class="memdesc:afb103bc9c0ef36a0593141c957dec4ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether a node is in the collection.  <a href="class_aspose_1_1_words_1_1_node_collection.html#contains_node">More...</a><br/></td></tr>
<tr class="separator:afb103bc9c0ef36a0593141c957dec4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e6dd6c87c6f40972781651e176742a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#get_count">get_Count</a> ()</td></tr>
<tr class="memdesc:a08e6dd6c87c6f40972781651e176742a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of nodes in the collection.  <a href="class_aspose_1_1_words_1_1_node_collection.html#get_count">More...</a><br/></td></tr>
<tr class="separator:a08e6dd6c87c6f40972781651e176742a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b3995dc3481cf158e6db8c39c2dc91"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.collections.generic.i_enumerator/">IEnumerator</a>&lt; <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Node</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#getenumerator">GetEnumerator</a> () override</td></tr>
<tr class="memdesc:a19b3995dc3481cf158e6db8c39c2dc91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a simple "foreach" style iteration over the collection of nodes.  <a href="class_aspose_1_1_words_1_1_node_collection.html#getenumerator">More...</a><br/></td></tr>
<tr class="separator:a19b3995dc3481cf158e6db8c39c2dc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20c8f845dfc7899af7940741fa99fc5"><td class="memItemLeft" align="right" valign="top">virtual const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.type_info/">TypeInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#gettype_const">GetType</a> () const override</td></tr>
<tr class="separator:ad20c8f845dfc7899af7940741fa99fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab986461f108ade77ed3ce9afd6f8af8f"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#idx_get_int">idx_get</a> (int32_t index)</td></tr>
<tr class="memdesc:ab986461f108ade77ed3ce9afd6f8af8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves a node at the given index.  <a href="class_aspose_1_1_words_1_1_node_collection.html#idx_get_int">More...</a><br/></td></tr>
<tr class="separator:ab986461f108ade77ed3ce9afd6f8af8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ff7fa6245f5be6b1830877cc6e641c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#indexof_node">IndexOf</a> (const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Node</a> &gt; &amp;node)</td></tr>
<tr class="memdesc:a99ff7fa6245f5be6b1830877cc6e641c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the zero-based index of the specified node.  <a href="class_aspose_1_1_words_1_1_node_collection.html#indexof_node">More...</a><br/></td></tr>
<tr class="separator:a99ff7fa6245f5be6b1830877cc6e641c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e08870652837402e08e2e56647795c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#insert_int_node">Insert</a> (int32_t index, const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Node</a> &gt; &amp;node)</td></tr>
<tr class="memdesc:ae0e08870652837402e08e2e56647795c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a node into the collection at the specified index.  <a href="class_aspose_1_1_words_1_1_node_collection.html#insert_int_node">More...</a><br/></td></tr>
<tr class="separator:ae0e08870652837402e08e2e56647795c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aea973950448976cd8e99aa11f82bf2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#is_typeinfo_const">Is</a> (const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.type_info/">TypeInfo</a> &amp;target) const override</td></tr>
<tr class="separator:a8aea973950448976cd8e99aa11f82bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86977ff4ddee5f0781a774868b8ad5a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#remove_node">Remove</a> (const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Node</a> &gt; &amp;node)</td></tr>
<tr class="memdesc:a86977ff4ddee5f0781a774868b8ad5a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the node from the collection and from the document.  <a href="class_aspose_1_1_words_1_1_node_collection.html#remove_node">More...</a><br/></td></tr>
<tr class="separator:a86977ff4ddee5f0781a774868b8ad5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1ce160d192c038c1e740c3ddc309eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#removeat_int">RemoveAt</a> (int32_t index)</td></tr>
<tr class="memdesc:a9c1ce160d192c038c1e740c3ddc309eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the node at the specified index from the collection and from the document.  <a href="class_aspose_1_1_words_1_1_node_collection.html#removeat_int">More...</a><br/></td></tr>
<tr class="separator:a9c1ce160d192c038c1e740c3ddc309eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224c4eef6fb6c30cbc2e0155f4503ef3"><td class="memItemLeft" align="right" valign="top"><a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a64e8d7c8f13f967748bdd283b4062425">ArrayPtr</a>&lt; <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Node</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#toarray">ToArray</a> ()</td></tr>
<tr class="memdesc:a224c4eef6fb6c30cbc2e0155f4503ef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies all nodes from the collection to a new array of nodes.  <a href="class_aspose_1_1_words_1_1_node_collection.html#toarray">More...</a><br/></td></tr>
<tr class="separator:a224c4eef6fb6c30cbc2e0155f4503ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods" href=""></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a78da420c638c982a6182dbc3a1ffd9b2"><td class="memItemLeft" align="right" valign="top">static const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.type_info/">TypeInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html#type">Type</a> ()</td></tr>
<tr class="separator:a78da420c638c982a6182dbc3a1ffd9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a068f070b5bbd81992e895bd3a9b7a909" href=""></a><a id="add_node" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#add_node">&#9670;&#160;</a></span>Add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Aspose::Words::NodeCollection::Add </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Aspose::Words::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a node to the end of the collection. </p>
<p>The node is inserted as a child into the node object from which the collection was created.</p>
<p>If the newChild is already in the tree, it is first removed.</p>
<p>If the node being inserted was created from another document, you should use ImportNode() to import the node to the current document. The imported node can then be inserted into the current document.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to be added to the end of the collection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System::NotSupportedException</td><td>The <b>NodeCollection</b> is a "deep" collection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to prepare a new section node for editing. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// A blank document comes with a section, which has a body, which in turn has a paragraph.</span></div>
<div class="line"><span class="comment">// We can add contents to this document by adding elements such as text runs, shapes, or tables to that paragraph.</span></div>
<div class="line">ASSERT_EQ(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_section" title="A Section object that corresponds to one section in a Word document. A Section node can have Body and...">NodeType::Section</a>, doc-&gt;GetChild(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_any" title="Indicates all node types. Allows to select all children.">NodeType::Any</a>, 0, <span class="keyword">true</span>)-&gt;get_NodeType());</div>
<div class="line">ASSERT_EQ(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_body" title="A Body object that contains the main text of a section (main text story). A Body node can have Paragr...">NodeType::Body</a>, doc-&gt;get_Sections()-&gt;idx_get(0)-&gt;GetChild(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_any" title="Indicates all node types. Allows to select all children.">NodeType::Any</a>, 0, <span class="keyword">true</span>)-&gt;get_NodeType());</div>
<div class="line">ASSERT_EQ(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_paragraph" title="A paragraph of text. A Paragraph node is a container for inline level elements Run,...">NodeType::Paragraph</a>, doc-&gt;get_Sections()-&gt;idx_get(0)-&gt;get_Body()-&gt;GetChild(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_any" title="Indicates all node types. Allows to select all children.">NodeType::Any</a>, 0, <span class="keyword">true</span>)-&gt;get_NodeType());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// If we add a new section like this, it will not have a body, or any other child nodes.</span></div>
<div class="line">doc-&gt;get_Sections()-&gt;Add(MakeObject&lt;Section&gt;(doc));</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(0, doc-&gt;get_Sections()-&gt;idx_get(1)-&gt;GetChildNodes(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_any" title="Indicates all node types. Allows to select all children.">NodeType::Any</a>, <span class="keyword">true</span>)-&gt;get_Count());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Run the "EnsureMinimum" method to add a body and a paragraph to this section to begin editing it.</span></div>
<div class="line">doc-&gt;get_LastSection()-&gt;EnsureMinimum();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_body" title="A Body object that contains the main text of a section (main text story). A Body node can have Paragr...">NodeType::Body</a>, doc-&gt;get_Sections()-&gt;idx_get(1)-&gt;GetChild(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_any" title="Indicates all node types. Allows to select all children.">NodeType::Any</a>, 0, <span class="keyword">true</span>)-&gt;get_NodeType());</div>
<div class="line">ASSERT_EQ(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_paragraph" title="A paragraph of text. A Paragraph node is a container for inline level elements Run,...">NodeType::Paragraph</a>, doc-&gt;get_Sections()-&gt;idx_get(1)-&gt;get_Body()-&gt;GetChild(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_any" title="Indicates all node types. Allows to select all children.">NodeType::Any</a>, 0, <span class="keyword">true</span>)-&gt;get_NodeType());</div>
<div class="line"> </div>
<div class="line">doc-&gt;get_Sections()-&gt;idx_get(0)-&gt;get_Body()-&gt;get_FirstParagraph()-&gt;AppendChild(MakeObject&lt;Run&gt;(doc, u<span class="stringliteral">"Hello world!"</span>));</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Hello world!"</span>, doc-&gt;GetText().Trim());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a5c84bf176a96e3f048ff328ef0ef67aa" href=""></a><a id="clear" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#clear">&#9670;&#160;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Aspose::Words::NodeCollection::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all nodes from this collection and from the document. </p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to remove all sections from a document. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;(MyDir + u<span class="stringliteral">"Document.docx"</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// This document has one section with a few child nodes containing and displaying all the document's contents.</span></div>
<div class="line">ASSERT_EQ(1, doc-&gt;get_Sections()-&gt;get_Count());</div>
<div class="line">ASSERT_EQ(17, doc-&gt;get_Sections()-&gt;idx_get(0)-&gt;GetChildNodes(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_any" title="Indicates all node types. Allows to select all children.">NodeType::Any</a>, <span class="keyword">true</span>)-&gt;get_Count());</div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Hello World!\r\rHello Word!\r\r\rHello World!"</span>, doc-&gt;GetText().Trim());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Clear the collection of sections, which will remove all of the document's children.</span></div>
<div class="line">doc-&gt;get_Sections()-&gt;Clear();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(0, doc-&gt;GetChildNodes(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_any" title="Indicates all node types. Allows to select all children.">NodeType::Any</a>, <span class="keyword">true</span>)-&gt;get_Count());</div>
<div class="line">ASSERT_EQ(String::Empty, doc-&gt;GetText().Trim());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="afb103bc9c0ef36a0593141c957dec4ad" href=""></a><a id="contains_node" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#contains_node">&#9670;&#160;</a></span>Contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Aspose::Words::NodeCollection::Contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Aspose::Words::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether a node is in the collection. </p>
<p>This method performs a linear search; therefore, the average execution time is proportional to Count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if item is found in the collection; otherwise, false.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to work with a <a class="el" href="class_aspose_1_1_words_1_1_node_collection.html" title="Represents a collection of nodes of a specific type.">NodeCollection</a>. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;();</div>
<div class="line"><span class="keyword">auto</span> builder = MakeObject&lt;DocumentBuilder&gt;(doc);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add text to the document by inserting Runs using a DocumentBuilder.</span></div>
<div class="line">builder-&gt;Write(u<span class="stringliteral">"Run 1. "</span>);</div>
<div class="line">builder-&gt;Write(u<span class="stringliteral">"Run 2. "</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Every invocation of the "Write" method creates a new Run,</span></div>
<div class="line"><span class="comment">// which then appears in the parent Paragraph's RunCollection.</span></div>
<div class="line">SharedPtr&lt;RunCollection&gt; runs = doc-&gt;get_FirstSection()-&gt;get_Body()-&gt;get_FirstParagraph()-&gt;get_Runs();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(2, runs-&gt;get_Count());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We can also insert a node into the RunCollection manually.</span></div>
<div class="line"><span class="keyword">auto</span> newRun = MakeObject&lt;Run&gt;(doc, u<span class="stringliteral">"Run 3. "</span>);</div>
<div class="line">runs-&gt;Insert(3, newRun);</div>
<div class="line"> </div>
<div class="line">ASSERT_TRUE(runs-&gt;Contains(newRun));</div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Run 1. Run 2. Run 3."</span>, doc-&gt;GetText().Trim());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access individual runs and remove them to remove their text from the document.</span></div>
<div class="line">SharedPtr&lt;Run&gt; run = runs-&gt;idx_get(1);</div>
<div class="line">runs-&gt;Remove(run);</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Run 1. Run 3."</span>, doc-&gt;GetText().Trim());</div>
<div class="line">ASSERT_FALSE(run == <span class="keyword">nullptr</span>);</div>
<div class="line">ASSERT_FALSE(runs-&gt;Contains(run));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a08e6dd6c87c6f40972781651e176742a" href=""></a><a id="get_count" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#get_count">&#9670;&#160;</a></span>get_Count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Aspose::Words::NodeCollection::get_Count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of nodes in the collection. </p>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to traverse through a composite node's collection of child nodes. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add two runs and one shape as child nodes to the first paragraph of this document.</span></div>
<div class="line"><span class="keyword">auto</span> paragraph = System::DynamicCast&lt;Paragraph&gt;(doc-&gt;GetChild(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_paragraph" title="A paragraph of text. A Paragraph node is a container for inline level elements Run,...">NodeType::Paragraph</a>, 0, <span class="keyword">true</span>));</div>
<div class="line">paragraph-&gt;AppendChild(MakeObject&lt;Run&gt;(doc, u<span class="stringliteral">"Hello world! "</span>));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> shape = MakeObject&lt;Shape&gt;(doc, ShapeType::Rectangle);</div>
<div class="line">shape-&gt;set_Width(200);</div>
<div class="line">shape-&gt;set_Height(200);</div>
<div class="line"><span class="comment">// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.</span></div>
<div class="line">shape-&gt;set_CustomNodeId(100);</div>
<div class="line">shape-&gt;set_WrapType(WrapType::Inline);</div>
<div class="line">paragraph-&gt;AppendChild(shape);</div>
<div class="line"> </div>
<div class="line">paragraph-&gt;AppendChild(MakeObject&lt;Run&gt;(doc, u<span class="stringliteral">"Hello again!"</span>));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate through the paragraph's collection of immediate children,</span></div>
<div class="line"><span class="comment">// and print any runs or shapes that we find within.</span></div>
<div class="line">SharedPtr&lt;NodeCollection&gt; children = paragraph-&gt;get_ChildNodes();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(3, paragraph-&gt;get_ChildNodes()-&gt;get_Count());</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; child : System::IterateOver(children))</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (child-&gt;get_NodeType())</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="namespace_aspose_1_1_words.html#nodetype_run" title="A run of text.">NodeType::Run</a>:</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Run contents:"</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"\t\""</span> &lt;&lt; child-&gt;GetText().Trim() &lt;&lt; <span class="stringliteral">"\""</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="namespace_aspose_1_1_words.html#nodetype_shape" title="A drawing object, such as an OfficeArt shape, image or an OLE object. A Shape node can contain Paragr...">NodeType::Shape</a>: {</div>
<div class="line">        <span class="keyword">auto</span> childShape = System::DynamicCast&lt;Shape&gt;(child);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Shape:"</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; String::Format(u<span class="stringliteral">"\t{0}, {1}x{2}"</span>, childShape-&gt;get_ShapeType(), childShape-&gt;get_Width(), childShape-&gt;get_Height()) &lt;&lt; std::endl;</div>
<div class="line">        ASSERT_EQ(100, shape-&gt;get_CustomNodeId());</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>Shows how to find out if a tables are nested. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keywordtype">void</span> CalculateDepthOfNestedTables()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;(MyDir + u<span class="stringliteral">"Nested tables.docx"</span>);</div>
<div class="line">    SharedPtr&lt;NodeCollection&gt; tables = doc-&gt;GetChildNodes(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_table" title="A Table object that represents a table in a Word document. A Table node can have Row nodes.">NodeType::Table</a>, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; tables-&gt;get_Count(); i++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> table = System::DynamicCast&lt;Table&gt;(tables-&gt;idx_get(i));</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Find out if any cells in the table have other tables as children.</span></div>
<div class="line">        <span class="keywordtype">int</span> count = GetChildTableCount(table);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Table #"</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" has "</span> &lt;&lt; count &lt;&lt; <span class="stringliteral">" tables directly within its cells"</span> &lt;&lt; std::endl;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Find out if the table is nested inside another table, and, if so, at what depth.</span></div>
<div class="line">        <span class="keywordtype">int</span> tableDepth = GetNestedDepthOfTable(table);</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (tableDepth &gt; 0)</div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">"Table #"</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" is nested inside another table at depth of "</span> &lt;&lt; tableDepth &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            std::cout &lt;&lt; <span class="stringliteral">"Table #"</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" is a non nested table (is not a child of another table)"</span> &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> GetNestedDepthOfTable(SharedPtr&lt;Table&gt; table)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> depth = 0;</div>
<div class="line">    SharedPtr&lt;Node&gt; parent = table-&gt;GetAncestor(table-&gt;get_NodeType());</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">while</span> (parent != <span class="keyword">nullptr</span>)</div>
<div class="line">    {</div>
<div class="line">        depth++;</div>
<div class="line">        parent = parent-&gt;GetAncestorOf&lt;SharedPtr&lt;Table&gt;&gt;();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> depth;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span> GetChildTableCount(SharedPtr&lt;Table&gt; table)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">int</span> childTableCount = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; row : System::IterateOver(table-&gt;get_Rows()-&gt;LINQ_OfType&lt;SharedPtr&lt;Row&gt;&gt;()))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; Cell : System::IterateOver(row-&gt;get_Cells()-&gt;LINQ_OfType&lt;SharedPtr&lt;Cell&gt;&gt;()))</div>
<div class="line">        {</div>
<div class="line">            SharedPtr&lt;TableCollection&gt; childTables = Cell-&gt;get_Tables();</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> (childTables-&gt;get_Count() &gt; 0)</div>
<div class="line">            {</div>
<div class="line">                childTableCount++;</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> childTableCount;</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a19b3995dc3481cf158e6db8c39c2dc91" href=""></a><a id="getenumerator" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#getenumerator">&#9670;&#160;</a></span>GetEnumerator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt;<a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.collections.generic.i_enumerator/">System::Collections::Generic::IEnumerator</a>&lt;<a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt;<a class="el" href="class_aspose_1_1_words_1_1_node.html">Aspose::Words::Node</a>&gt; &gt; &gt; Aspose::Words::NodeCollection::GetEnumerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides a simple "foreach" style iteration over the collection of nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>An IEnumerator. </dd></dl>

</div>
</div>
<a id="ad20c8f845dfc7899af7940741fa99fc5" href=""></a><a id="gettype_const" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#gettype_const">&#9670;&#160;</a></span>GetType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.type_info/">System::TypeInfo</a>&amp; Aspose::Words::NodeCollection::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.object/#ab108566dd35d8621466bbac2a40bd452">System::Object</a>.</p>

<p>Reimplemented in <a class="el" href="class_aspose_1_1_words_1_1_tables_1_1_table_collection.html#gettype_const">Aspose::Words::Tables::TableCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_tables_1_1_row_collection.html#gettype_const">Aspose::Words::Tables::RowCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_tables_1_1_cell_collection.html#gettype_const">Aspose::Words::Tables::CellCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_section_collection.html#gettype_const">Aspose::Words::SectionCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_run_collection.html#gettype_const">Aspose::Words::RunCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_paragraph_collection.html#gettype_const">Aspose::Words::ParagraphCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_header_footer_collection.html#gettype_const">Aspose::Words::HeaderFooterCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_comment_collection.html#gettype_const">Aspose::Words::CommentCollection</a>, and <a class="el" href="class_aspose_1_1_words_1_1_building_blocks_1_1_building_block_collection.html#gettype_const">Aspose::Words::BuildingBlocks::BuildingBlockCollection</a>.</p>

</div>
</div>
<a id="ab986461f108ade77ed3ce9afd6f8af8f" href=""></a><a id="idx_get_int" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#idx_get_int">&#9670;&#160;</a></span>idx_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt;<a class="el" href="class_aspose_1_1_words_1_1_node.html">Aspose::Words::Node</a>&gt; Aspose::Words::NodeCollection::idx_get </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves a node at the given index. </p>
<p>The index is zero-based.</p>
<p>Negative indexes are allowed and indicate access from the back of the collection. For example -1 means the last item, -2 means the second before last and so on.</p>
<p>If index is greater than or equal to the number of items in the list, this returns a null reference.</p>
<p>If index is negative and its absolute value is greater than the number of items in the list, this returns a null reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>An index into the collection of nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to traverse through a composite node's collection of child nodes. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add two runs and one shape as child nodes to the first paragraph of this document.</span></div>
<div class="line"><span class="keyword">auto</span> paragraph = System::DynamicCast&lt;Paragraph&gt;(doc-&gt;GetChild(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_paragraph" title="A paragraph of text. A Paragraph node is a container for inline level elements Run,...">NodeType::Paragraph</a>, 0, <span class="keyword">true</span>));</div>
<div class="line">paragraph-&gt;AppendChild(MakeObject&lt;Run&gt;(doc, u<span class="stringliteral">"Hello world! "</span>));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> shape = MakeObject&lt;Shape&gt;(doc, ShapeType::Rectangle);</div>
<div class="line">shape-&gt;set_Width(200);</div>
<div class="line">shape-&gt;set_Height(200);</div>
<div class="line"><span class="comment">// Note that the 'CustomNodeId' is not saved to an output file and exists only during the node lifetime.</span></div>
<div class="line">shape-&gt;set_CustomNodeId(100);</div>
<div class="line">shape-&gt;set_WrapType(WrapType::Inline);</div>
<div class="line">paragraph-&gt;AppendChild(shape);</div>
<div class="line"> </div>
<div class="line">paragraph-&gt;AppendChild(MakeObject&lt;Run&gt;(doc, u<span class="stringliteral">"Hello again!"</span>));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Iterate through the paragraph's collection of immediate children,</span></div>
<div class="line"><span class="comment">// and print any runs or shapes that we find within.</span></div>
<div class="line">SharedPtr&lt;NodeCollection&gt; children = paragraph-&gt;get_ChildNodes();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(3, paragraph-&gt;get_ChildNodes()-&gt;get_Count());</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; child : System::IterateOver(children))</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">switch</span> (child-&gt;get_NodeType())</div>
<div class="line">    {</div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="namespace_aspose_1_1_words.html#nodetype_run" title="A run of text.">NodeType::Run</a>:</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Run contents:"</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"\t\""</span> &lt;&lt; child-&gt;GetText().Trim() &lt;&lt; <span class="stringliteral">"\""</span> &lt;&lt; std::endl;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">case</span> <a class="code" href="namespace_aspose_1_1_words.html#nodetype_shape" title="A drawing object, such as an OfficeArt shape, image or an OLE object. A Shape node can contain Paragr...">NodeType::Shape</a>: {</div>
<div class="line">        <span class="keyword">auto</span> childShape = System::DynamicCast&lt;Shape&gt;(child);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">"Shape:"</span> &lt;&lt; std::endl;</div>
<div class="line">        std::cout &lt;&lt; String::Format(u<span class="stringliteral">"\t{0}, {1}x{2}"</span>, childShape-&gt;get_ShapeType(), childShape-&gt;get_Width(), childShape-&gt;get_Height()) &lt;&lt; std::endl;</div>
<div class="line">        ASSERT_EQ(100, shape-&gt;get_CustomNodeId());</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a99ff7fa6245f5be6b1830877cc6e641c" href=""></a><a id="indexof_node" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#indexof_node">&#9670;&#160;</a></span>IndexOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t Aspose::Words::NodeCollection::IndexOf </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Aspose::Words::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the zero-based index of the specified node. </p>
<p>This method performs a linear search; therefore, the average execution time is proportional to Count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to locate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The zero-based index of the node within the collection, if found; otherwise, -1.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to get the index of a node in a collection. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;(MyDir + u<span class="stringliteral">"Tables.docx"</span>);</div>
<div class="line"> </div>
<div class="line">SharedPtr&lt;Table&gt; table = doc-&gt;get_FirstSection()-&gt;get_Body()-&gt;get_Tables()-&gt;idx_get(0);</div>
<div class="line">SharedPtr&lt;NodeCollection&gt; allTables = doc-&gt;GetChildNodes(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_table" title="A Table object that represents a table in a Word document. A Table node can have Row nodes.">NodeType::Table</a>, <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(0, allTables-&gt;IndexOf(table));</div>
<div class="line"> </div>
<div class="line">SharedPtr&lt;Row&gt; row = table-&gt;get_Rows()-&gt;idx_get(2);</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(2, table-&gt;IndexOf(row));</div>
<div class="line"> </div>
<div class="line">SharedPtr&lt;Cell&gt; cell = row-&gt;get_LastCell();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(4, row-&gt;IndexOf(cell));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae0e08870652837402e08e2e56647795c" href=""></a><a id="insert_int_node" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#insert_int_node">&#9670;&#160;</a></span>Insert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Aspose::Words::NodeCollection::Insert </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Aspose::Words::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts a node into the collection at the specified index. </p>
<p>The node is inserted as a child into the node object from which the collection was created.</p>
<p>If the index is equal to or greater than Count, the node is added at the end of the collection.</p>
<p>If the index is negative and its absolute value is greater than Count, the node is added at the end of the collection.</p>
<p>If the newChild is already in the tree, it is first removed.</p>
<p>If the node being inserted was created from another document, you should use ImportNode() to import the node to the current document. The imported node can then be inserted into the current document.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The zero-based index of the node. Negative indexes are allowed and indicate access from the back of the list. For example -1 means the last node, -2 means the second before last and so on. </td></tr>
    <tr><td class="paramname">node</td><td>The node to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System::NotSupportedException</td><td>The <b>NodeCollection</b> is a "deep" collection.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to work with a <a class="el" href="class_aspose_1_1_words_1_1_node_collection.html" title="Represents a collection of nodes of a specific type.">NodeCollection</a>. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;();</div>
<div class="line"><span class="keyword">auto</span> builder = MakeObject&lt;DocumentBuilder&gt;(doc);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add text to the document by inserting Runs using a DocumentBuilder.</span></div>
<div class="line">builder-&gt;Write(u<span class="stringliteral">"Run 1. "</span>);</div>
<div class="line">builder-&gt;Write(u<span class="stringliteral">"Run 2. "</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Every invocation of the "Write" method creates a new Run,</span></div>
<div class="line"><span class="comment">// which then appears in the parent Paragraph's RunCollection.</span></div>
<div class="line">SharedPtr&lt;RunCollection&gt; runs = doc-&gt;get_FirstSection()-&gt;get_Body()-&gt;get_FirstParagraph()-&gt;get_Runs();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(2, runs-&gt;get_Count());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We can also insert a node into the RunCollection manually.</span></div>
<div class="line"><span class="keyword">auto</span> newRun = MakeObject&lt;Run&gt;(doc, u<span class="stringliteral">"Run 3. "</span>);</div>
<div class="line">runs-&gt;Insert(3, newRun);</div>
<div class="line"> </div>
<div class="line">ASSERT_TRUE(runs-&gt;Contains(newRun));</div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Run 1. Run 2. Run 3."</span>, doc-&gt;GetText().Trim());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access individual runs and remove them to remove their text from the document.</span></div>
<div class="line">SharedPtr&lt;Run&gt; run = runs-&gt;idx_get(1);</div>
<div class="line">runs-&gt;Remove(run);</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Run 1. Run 3."</span>, doc-&gt;GetText().Trim());</div>
<div class="line">ASSERT_FALSE(run == <span class="keyword">nullptr</span>);</div>
<div class="line">ASSERT_FALSE(runs-&gt;Contains(run));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8aea973950448976cd8e99aa11f82bf2" href=""></a><a id="is_typeinfo_const" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#is_typeinfo_const">&#9670;&#160;</a></span>Is()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Aspose::Words::NodeCollection::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.type_info/">System::TypeInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented from <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.object/#a126ddfe162038b96570fe3a4871a3060">System::Object</a>.</p>

<p>Reimplemented in <a class="el" href="class_aspose_1_1_words_1_1_tables_1_1_table_collection.html#is_typeinfo_const">Aspose::Words::Tables::TableCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_tables_1_1_row_collection.html#is_typeinfo_const">Aspose::Words::Tables::RowCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_tables_1_1_cell_collection.html#is_typeinfo_const">Aspose::Words::Tables::CellCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_section_collection.html#is_typeinfo_const">Aspose::Words::SectionCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_run_collection.html#is_typeinfo_const">Aspose::Words::RunCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_paragraph_collection.html#is_typeinfo_const">Aspose::Words::ParagraphCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_header_footer_collection.html#is_typeinfo_const">Aspose::Words::HeaderFooterCollection</a>, <a class="el" href="class_aspose_1_1_words_1_1_comment_collection.html#is_typeinfo_const">Aspose::Words::CommentCollection</a>, and <a class="el" href="class_aspose_1_1_words_1_1_building_blocks_1_1_building_block_collection.html#is_typeinfo_const">Aspose::Words::BuildingBlocks::BuildingBlockCollection</a>.</p>

</div>
</div>
<a id="a86977ff4ddee5f0781a774868b8ad5a8" href=""></a><a id="remove_node" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#remove_node">&#9670;&#160;</a></span>Remove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Aspose::Words::NodeCollection::Remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_aspose_1_1_words_1_1_node.html">Aspose::Words::Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the node from the collection and from the document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to work with a <a class="el" href="class_aspose_1_1_words_1_1_node_collection.html" title="Represents a collection of nodes of a specific type.">NodeCollection</a>. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;();</div>
<div class="line"><span class="keyword">auto</span> builder = MakeObject&lt;DocumentBuilder&gt;(doc);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Add text to the document by inserting Runs using a DocumentBuilder.</span></div>
<div class="line">builder-&gt;Write(u<span class="stringliteral">"Run 1. "</span>);</div>
<div class="line">builder-&gt;Write(u<span class="stringliteral">"Run 2. "</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Every invocation of the "Write" method creates a new Run,</span></div>
<div class="line"><span class="comment">// which then appears in the parent Paragraph's RunCollection.</span></div>
<div class="line">SharedPtr&lt;RunCollection&gt; runs = doc-&gt;get_FirstSection()-&gt;get_Body()-&gt;get_FirstParagraph()-&gt;get_Runs();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(2, runs-&gt;get_Count());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// We can also insert a node into the RunCollection manually.</span></div>
<div class="line"><span class="keyword">auto</span> newRun = MakeObject&lt;Run&gt;(doc, u<span class="stringliteral">"Run 3. "</span>);</div>
<div class="line">runs-&gt;Insert(3, newRun);</div>
<div class="line"> </div>
<div class="line">ASSERT_TRUE(runs-&gt;Contains(newRun));</div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Run 1. Run 2. Run 3."</span>, doc-&gt;GetText().Trim());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Access individual runs and remove them to remove their text from the document.</span></div>
<div class="line">SharedPtr&lt;Run&gt; run = runs-&gt;idx_get(1);</div>
<div class="line">runs-&gt;Remove(run);</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Run 1. Run 3."</span>, doc-&gt;GetText().Trim());</div>
<div class="line">ASSERT_FALSE(run == <span class="keyword">nullptr</span>);</div>
<div class="line">ASSERT_FALSE(runs-&gt;Contains(run));</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a9c1ce160d192c038c1e740c3ddc309eb" href=""></a><a id="removeat_int" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#removeat_int">&#9670;&#160;</a></span>RemoveAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Aspose::Words::NodeCollection::RemoveAt </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the node at the specified index from the collection and from the document. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The zero-based index of the node. Negative indexes are allowed and indicate access from the back of the list. For example -1 means the last node, -2 means the second before last and so on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to add and remove sections in a document. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;();</div>
<div class="line"><span class="keyword">auto</span> builder = MakeObject&lt;DocumentBuilder&gt;(doc);</div>
<div class="line"> </div>
<div class="line">builder-&gt;Write(u<span class="stringliteral">"Section 1"</span>);</div>
<div class="line">builder-&gt;InsertBreak(<a class="code" href="namespace_aspose_1_1_words.html#breaktype_sectionbreaknewpage" title="Specifies start of new section on a new page.">BreakType::SectionBreakNewPage</a>);</div>
<div class="line">builder-&gt;Write(u<span class="stringliteral">"Section 2"</span>);</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Section 1\x000c"</span></div>
<div class="line">          u<span class="stringliteral">"Section 2"</span>,</div>
<div class="line">          doc-&gt;GetText().Trim());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Delete the first section from the document.</span></div>
<div class="line">doc-&gt;get_Sections()-&gt;RemoveAt(0);</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Section 2"</span>, doc-&gt;GetText().Trim());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Append a copy of what is now the first section to the end of the document.</span></div>
<div class="line"><span class="keywordtype">int</span> lastSectionIdx = doc-&gt;get_Sections()-&gt;get_Count() - 1;</div>
<div class="line">SharedPtr&lt;Section&gt; newSection = doc-&gt;get_Sections()-&gt;idx_get(lastSectionIdx)-&gt;Clone();</div>
<div class="line">doc-&gt;get_Sections()-&gt;Add(newSection);</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(u<span class="stringliteral">"Section 2\x000c"</span></div>
<div class="line">          u<span class="stringliteral">"Section 2"</span>,</div>
<div class="line">          doc-&gt;GetText().Trim());</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a224c4eef6fb6c30cbc2e0155f4503ef3" href=""></a><a id="toarray" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#toarray">&#9670;&#160;</a></span>ToArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a64e8d7c8f13f967748bdd283b4062425">System::ArrayPtr</a>&lt;<a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/namespace/system#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt;<a class="el" href="class_aspose_1_1_words_1_1_node.html">Aspose::Words::Node</a>&gt; &gt; Aspose::Words::NodeCollection::ToArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies all nodes from the collection to a new array of nodes. </p>
<p>You should not be adding/removing nodes while iterating over a collection of nodes because it invalidates the iterator and requires refreshes for live collections.</p>
<p>To be able to add/remove nodes during iteration, use this method to copy nodes into a fixed-size array and then iterate over the array.</p>
<dl class="section return"><dt>Returns</dt><dd>An array of nodes.</dd></dl>
<dl class="section user"><dt>Examples</dt><dd></dd></dl>
<p>Shows how to replace all textbox shapes with image shapes. </p><div class="fragment" data-nosnippet=""><div class="line"><span class="keyword">auto</span> doc = MakeObject&lt;Document&gt;(MyDir + u<span class="stringliteral">"Textboxes in drawing canvas.docx"</span>);</div>
<div class="line"> </div>
<div class="line">ArrayPtr&lt;SharedPtr&lt;Shape&gt;&gt; shapes = doc-&gt;GetChildNodes(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_shape" title="A drawing object, such as an OfficeArt shape, image or an OLE object. A Shape node can contain Paragr...">NodeType::Shape</a>, <span class="keyword">true</span>)-&gt;LINQ_OfType&lt;SharedPtr&lt;Shape&gt;&gt;()-&gt;LINQ_ToArray();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> isTextBox = [](SharedPtr&lt;Shape&gt; s)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> s-&gt;get_ShapeType() == ShapeType::TextBox;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> isImage = [](SharedPtr&lt;Shape&gt; s)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> s-&gt;get_ShapeType() == ShapeType::Image;</div>
<div class="line">};</div>
<div class="line">ASSERT_EQ(3, shapes-&gt;LINQ_Count(isTextBox));</div>
<div class="line">ASSERT_EQ(1, shapes-&gt;LINQ_Count(isImage));</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (SharedPtr&lt;Shape&gt; shape : shapes)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (shape-&gt;get_ShapeType() == ShapeType::TextBox)</div>
<div class="line">    {</div>
<div class="line">        <span class="keyword">auto</span> replacementShape = MakeObject&lt;Shape&gt;(doc, ShapeType::Image);</div>
<div class="line">        replacementShape-&gt;get_ImageData()-&gt;SetImage(ImageDir + u<span class="stringliteral">"Logo.jpg"</span>);</div>
<div class="line">        replacementShape-&gt;set_Left(shape-&gt;get_Left());</div>
<div class="line">        replacementShape-&gt;set_Top(shape-&gt;get_Top());</div>
<div class="line">        replacementShape-&gt;set_Width(shape-&gt;get_Width());</div>
<div class="line">        replacementShape-&gt;set_Height(shape-&gt;get_Height());</div>
<div class="line">        replacementShape-&gt;set_RelativeHorizontalPosition(shape-&gt;get_RelativeHorizontalPosition());</div>
<div class="line">        replacementShape-&gt;set_RelativeVerticalPosition(shape-&gt;get_RelativeVerticalPosition());</div>
<div class="line">        replacementShape-&gt;set_HorizontalAlignment(shape-&gt;get_HorizontalAlignment());</div>
<div class="line">        replacementShape-&gt;set_VerticalAlignment(shape-&gt;get_VerticalAlignment());</div>
<div class="line">        replacementShape-&gt;set_WrapType(shape-&gt;get_WrapType());</div>
<div class="line">        replacementShape-&gt;set_WrapSide(shape-&gt;get_WrapSide());</div>
<div class="line"> </div>
<div class="line">        shape-&gt;get_ParentNode()-&gt;InsertAfter(replacementShape, shape);</div>
<div class="line">        shape-&gt;Remove();</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">shapes = doc-&gt;GetChildNodes(<a class="code" href="namespace_aspose_1_1_words.html#nodetype_shape" title="A drawing object, such as an OfficeArt shape, image or an OLE object. A Shape node can contain Paragr...">NodeType::Shape</a>, <span class="keyword">true</span>)-&gt;LINQ_OfType&lt;SharedPtr&lt;Shape&gt;&gt;()-&gt;LINQ_ToArray();</div>
<div class="line"> </div>
<div class="line">ASSERT_EQ(0, shapes-&gt;LINQ_Count(isTextBox));</div>
<div class="line">ASSERT_EQ(4, shapes-&gt;LINQ_Count(isImage));</div>
<div class="line"> </div>
<div class="line">doc-&gt;Save(ArtifactsDir + u<span class="stringliteral">"Shape.ReplaceTextboxesWithImages.docx"</span>);</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a78da420c638c982a6182dbc3a1ffd9b2" href=""></a><a id="type" href=""></a>
<h2 class="memtitle"><span class="permalink"><a href="#type">&#9670;&#160;</a></span>Type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="elRef" target="_blank" href="https://apireference.codeporting.com/native/cs2cpp/class/system.type_info/">System::TypeInfo</a>&amp; Aspose::Words::NodeCollection::Type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_aspose.html">Aspose</a></li><li class="navelem"><a class="el" href="namespace_aspose_1_1_words.html">Words</a></li><li class="navelem"><a class="el" href="class_aspose_1_1_words_1_1_node_collection.html">NodeCollection</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
