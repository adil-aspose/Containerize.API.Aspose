<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aspose.BarCode for C++ API Reference: CsToCppPorter::MemoryManagement Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aspose.BarCode for C++ API Reference
   &#160;<span id="projectnumber">21.11</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_cs_to_cpp_porter_1_1_memory_management.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_cs_to_cpp_porter_1_1_memory_management-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CsToCppPorter::MemoryManagement Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines a methods that changes the lifetime of objects.  
 <a href="class_cs_to_cpp_porter_1_1_memory_management.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a73f701c5cc5b18479c74fd2f47075c8a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cs_to_cpp_porter_1_1_memory_management.html#a73f701c5cc5b18479c74fd2f47075c8a">ObjectsBag</a> = System::Details::ObjectsBag</td></tr>
<tr class="memdesc:a73f701c5cc5b18479c74fd2f47075c8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Highly optimized container designed to extend objects lifetime.  <a href="#a73f701c5cc5b18479c74fd2f47075c8a">More...</a><br /></td></tr>
<tr class="separator:a73f701c5cc5b18479c74fd2f47075c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac0ed751570af7edbf09c47341c7ca4ee"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac0ed751570af7edbf09c47341c7ca4ee"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; typename T1::Pointee_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_cs_to_cpp_porter_1_1_memory_management.html#ac0ed751570af7edbf09c47341c7ca4ee">BindLifetime</a> (const T1 &amp;target, const T2 &amp;owner)</td></tr>
<tr class="memdesc:ac0ed751570af7edbf09c47341c7ca4ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a smart pointer using the aliasing constructor. Creates a pointer to the <code>target</code> object which controls lifetime of the <code>owner</code> object. This pointer's expiration is bound to expiration of the <code>owner</code> object, just like this of any other pointer that owns <code>owner</code> object. If converted to weak type, it is still consistent with other pointers to <code>owner</code> and does not expire while there is at least one shared pointer to <code>owner</code> object. Also, the returned pointer does not ensure that <code>target</code> object is alive, so some other means (e. g. shared pointer stored in the <code>owner</code> object) should do so. Should be used in the situations where <code>owner</code> owns the <code>target</code>, which effectively means that the <code>target</code> will be kept alive by <code>owner</code> even if the returned aliasing pointer no longer exists. Otherwise, doesn't guarantee that the resulting pointer will remain valid, because if <code>owner</code> doesn't actually hold shared reference to <code>target</code>, <code>target</code> can be deleted any time as the resulting pointer only owns <code>owner</code> but not the <code>target</code>.  <a href="#ac0ed751570af7edbf09c47341c7ca4ee">More...</a><br /></td></tr>
<tr class="separator:ac0ed751570af7edbf09c47341c7ca4ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00187e85dab75e4658c269304f377525"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a00187e85dab75e4658c269304f377525"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!std::is_reference&lt; T1 &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; typename T1::Pointee_ &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_cs_to_cpp_porter_1_1_memory_management.html#a00187e85dab75e4658c269304f377525">BindLifetime</a> (T1 &amp;&amp;target, const T2 &amp;owner)</td></tr>
<tr class="memdesc:a00187e85dab75e4658c269304f377525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a smart pointer using the aliasing constructor. Creates a pointer to the <code>target</code> object which controls lifetime of the <code>owner</code> object. This pointer's expiration is bound to expiration of the <code>owner</code> object, just like this of any other pointer that owns <code>owner</code> object. If converted to weak type, it is still consistent with other pointers to <code>owner</code> and does not expire while there is at least one shared pointer to <code>owner</code> object. Also, the returned pointer does not ensure that <code>target</code> object is alive, so some other means (e. g. shared pointer stored in the <code>owner</code> object) should do so. Should be used in the situations where <code>owner</code> owns the <code>target</code>, which effectively means that the <code>target</code> will be kept alive by <code>owner</code> even if the returned aliasing pointer no longer exists. Otherwise, doesn't guarantee that the returned pointer will remain valid, because if <code>owner</code> doesn't actually hold shared reference to <code>target</code>, <code>target</code> can be deleted any time as the returned pointer only owns <code>owner</code> but not the <code>target</code>.  <a href="#a00187e85dab75e4658c269304f377525">More...</a><br /></td></tr>
<tr class="separator:a00187e85dab75e4658c269304f377525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aad264fdbcfc41c4d6bb36e7cc810e6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ... Objects&gt; </td></tr>
<tr class="memitem:a9aad264fdbcfc41c4d6bb36e7cc810e6"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; typename T::Pointee_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_cs_to_cpp_porter_1_1_memory_management.html#a9aad264fdbcfc41c4d6bb36e7cc810e6">ExtendLifetime</a> (const T &amp;target, const Objects &amp;...objects)</td></tr>
<tr class="separator:a9aad264fdbcfc41c4d6bb36e7cc810e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines a methods that changes the lifetime of objects. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a73f701c5cc5b18479c74fd2f47075c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73f701c5cc5b18479c74fd2f47075c8a">&#9670;&nbsp;</a></span>ObjectsBag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_cs_to_cpp_porter_1_1_memory_management.html#a73f701c5cc5b18479c74fd2f47075c8a">CsToCppPorter::MemoryManagement::ObjectsBag</a> =  System::Details::ObjectsBag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Highly optimized container designed to extend objects lifetime. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac0ed751570af7edbf09c47341c7ca4ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ed751570af7edbf09c47341c7ca4ee">&#9670;&nbsp;</a></span>BindLifetime() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;typename T1::Pointee_&gt; CsToCppPorter::MemoryManagement::BindLifetime </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a smart pointer using the aliasing constructor. Creates a pointer to the <code>target</code> object which controls lifetime of the <code>owner</code> object. This pointer's expiration is bound to expiration of the <code>owner</code> object, just like this of any other pointer that owns <code>owner</code> object. If converted to weak type, it is still consistent with other pointers to <code>owner</code> and does not expire while there is at least one shared pointer to <code>owner</code> object. Also, the returned pointer does not ensure that <code>target</code> object is alive, so some other means (e. g. shared pointer stored in the <code>owner</code> object) should do so. Should be used in the situations where <code>owner</code> owns the <code>target</code>, which effectively means that the <code>target</code> will be kept alive by <code>owner</code> even if the returned aliasing pointer no longer exists. Otherwise, doesn't guarantee that the resulting pointer will remain valid, because if <code>owner</code> doesn't actually hold shared reference to <code>target</code>, <code>target</code> can be deleted any time as the resulting pointer only owns <code>owner</code> but not the <code>target</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of smart pointer to the object that the new smart pointer will refer to. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of smart pointer to an object whose ownership is shared with a new smart pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Smart pointer to the object that the new smart pointer will refer to. </td></tr>
    <tr><td class="paramname">owner</td><td>Smart pointer to an object whose ownership is shared with a new smart pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New smart pointer. <div class="fragment"><div class="line"><span class="preprocessor">   #include &quot;system/memory_management.h&quot;</span></div><div class="line"><span class="preprocessor">   #include &quot;system/object.h&quot;</span></div><div class="line"><span class="preprocessor">   #include &lt;iostream&gt;</span></div><div class="line">   <span class="comment">// The ChildNode-class forward declaration.</span></div><div class="line">   <span class="keyword">class </span>ChildNode;</div><div class="line">  </div><div class="line">   <span class="comment">// Stores a SharedPtr to an instance of the ChildNode class.</span></div><div class="line">   <span class="keyword">class </span>ParentNode: <span class="keyword">public</span> <a class="code" href="class_system_1_1_object.html">System::Object</a></div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <a class="code" href="class_system_1_1_smart_ptr.html">System::SharedPtr&lt;ChildNode&gt;</a> child;</div><div class="line">   };</div><div class="line">  </div><div class="line">   <span class="comment">// Stores a WeakPtr to an instance of the ParentNode-class.</span></div><div class="line">   <span class="keyword">class </span>ChildNode: <span class="keyword">public</span> <a class="code" href="class_system_1_1_object.html">System::Object</a></div><div class="line">   {</div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     <a class="code" href="class_system_1_1_weak_ptr.html">System::WeakPtr&lt;ParentNode&gt;</a> parent;</div><div class="line">   };</div><div class="line">  </div><div class="line">   <span class="comment">// The lifetime of the ChildNode- and ParentNode-class instances will be bound when true is passed as a param value.</span></div><div class="line">   <a class="code" href="class_system_1_1_smart_ptr.html">System::SharedPtr&lt;ChildNode&gt;</a> GetChildNode(<span class="keywordtype">bool</span> bindLifetime)</div><div class="line">   {</div><div class="line">     <span class="keyword">auto</span> parent = System::MakeObject&lt;ParentNode&gt;();</div><div class="line">     <span class="keyword">auto</span> child = System::MakeObject&lt;ChildNode&gt;();</div><div class="line">  </div><div class="line">     parent-&gt;child = child;</div><div class="line">     child-&gt;parent = parent;</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> bindLifetime ? <a class="code" href="class_cs_to_cpp_porter_1_1_memory_management.html#ac0ed751570af7edbf09c47341c7ca4ee">CsToCppPorter::MemoryManagement::BindLifetime</a>(child, parent) : child;</div><div class="line">   }</div><div class="line">  </div><div class="line">   <span class="comment">// This function prints information about WeakPtr to a ParentNode-class instance.</span></div><div class="line">   <span class="keywordtype">void</span> PrintInfo(<a class="code" href="class_system_1_1_weak_ptr.html">System::WeakPtr&lt;ParentNode&gt;</a> &amp;parent)</div><div class="line">   {</div><div class="line">     std::cout &lt;&lt; <span class="stringliteral">&quot;The pointer to an instance of the ParentNode class has expired: &quot;</span> &lt;&lt; (parent.<a class="code" href="class_system_1_1_weak_ptr.html#ad204453849f6a92dd441c4ef95175616">expired</a>() ? <span class="stringliteral">&quot;True&quot;</span> : <span class="stringliteral">&quot;False&quot;</span>) &lt;&lt; std::endl;</div><div class="line">   }</div><div class="line">  </div><div class="line">   <span class="keywordtype">int</span> main()</div><div class="line">   {</div><div class="line">     <span class="keyword">auto</span> child = GetChildNode(<span class="keyword">false</span>);</div><div class="line">     PrintInfo(child-&gt;parent);</div><div class="line">     child = GetChildNode(<span class="keyword">true</span>);</div><div class="line">     PrintInfo(child-&gt;parent);</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> 0;</div><div class="line">   }</div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">*  This code example produces the following output:</span></div><div class="line"><span class="comment">*  The pointer to an instance of the ParentNode class has expired: True</span></div><div class="line"><span class="comment">*  The pointer to an instance of the ParentNode class has expired: False</span></div><div class="line"><span class="comment">   */</span></div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a00187e85dab75e4658c269304f377525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00187e85dab75e4658c269304f377525">&#9670;&nbsp;</a></span>BindLifetime() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!std::is_reference&lt;T1&gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;typename T1::Pointee_&gt; &gt;::type CsToCppPorter::MemoryManagement::BindLifetime </td>
          <td>(</td>
          <td class="paramtype">T1 &amp;&amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>owner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a smart pointer using the aliasing constructor. Creates a pointer to the <code>target</code> object which controls lifetime of the <code>owner</code> object. This pointer's expiration is bound to expiration of the <code>owner</code> object, just like this of any other pointer that owns <code>owner</code> object. If converted to weak type, it is still consistent with other pointers to <code>owner</code> and does not expire while there is at least one shared pointer to <code>owner</code> object. Also, the returned pointer does not ensure that <code>target</code> object is alive, so some other means (e. g. shared pointer stored in the <code>owner</code> object) should do so. Should be used in the situations where <code>owner</code> owns the <code>target</code>, which effectively means that the <code>target</code> will be kept alive by <code>owner</code> even if the returned aliasing pointer no longer exists. Otherwise, doesn't guarantee that the returned pointer will remain valid, because if <code>owner</code> doesn't actually hold shared reference to <code>target</code>, <code>target</code> can be deleted any time as the returned pointer only owns <code>owner</code> but not the <code>target</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Type of smart pointer to the object that the new smart pointer will refer to. </td></tr>
    <tr><td class="paramname">T2</td><td>Type of smart pointer to an object whose ownership is shared with a new smart pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Smart pointer to the object that the new smart pointer will refer to. </td></tr>
    <tr><td class="paramname">owner</td><td>Smart pointer to an object whose ownership is shared with a new smart pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New smart pointer. </dd></dl>

</div>
</div>
<a id="a9aad264fdbcfc41c4d6bb36e7cc810e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aad264fdbcfc41c4d6bb36e7cc810e6">&#9670;&nbsp;</a></span>ExtendLifetime()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ... Objects&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;typename T::Pointee_&gt; CsToCppPorter::MemoryManagement::ExtendLifetime </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Objects &amp;...&#160;</td>
          <td class="paramname"><em>objects</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a smart pointer using the aliasing constructor and copies <code>target</code> and <code>objects</code> pointers to the "proxy" objects holder. Creates a pointer to the <code>target</code> and extends the lifetime of all objects to the lifetime of this pointer. The resulting pointer guarantees all parameters to remain alive, even if it is the only pointer that keeps track of them. The resulting pointer effectively owns all objects passed to this method, however, it has its own expiration track. This means, that converting its own copy to weak type will expire it, even if all objects it tracks are still alive. Should be used in the situations when there are several unrelated (not holding shared references to each other) objects that should be guaranteed to remain alive together. The returned pointer will own a temporary objects that keeps all of them alive, and this lifetime extension stops working once the returned pointer no longer exists (or all of its copies become weak). </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the object that the new smart pointer will refer to. </td></tr>
    <tr><td class="paramname">Objects</td><td>Types of the objects whose ownership is shared with a new smart pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Smart pointer to the object that the new smart pointer will refer to. </td></tr>
    <tr><td class="paramname">objects</td><td>Smart pointers to the objects whose ownership is shared with a new smart pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>New smart pointer. <div class="fragment"><div class="line"><span class="preprocessor">   #include &quot;system/memory_management.h&quot;</span></div><div class="line"><span class="preprocessor">   #include &quot;system/object.h&quot;</span></div><div class="line"><span class="preprocessor">   #include &lt;iostream&gt;</span></div><div class="line">  </div><div class="line">   <span class="comment">// Create a class that stores links to the previous node and to the next one.</span></div><div class="line">   <span class="keyword">class </span><a class="code" href="namespace_system_1_1_xml_1_1_schema.html#ac728d2cc5b09a5956f8da14930af590ea6c3a6944a808a7c0bbb6788dbec54a9f">Node</a>: <span class="keyword">public</span> <a class="code" href="class_system_1_1_object.html">System::Object</a></div><div class="line">   {</div><div class="line">     <span class="keyword">using</span> NodePtr = <a class="code" href="class_system_1_1_weak_ptr.html">System::WeakPtr&lt;Node&gt;</a>;</div><div class="line">  </div><div class="line">     int32_t m_value;</div><div class="line">  </div><div class="line">   <span class="keyword">public</span>:</div><div class="line">     NodePtr previous;</div><div class="line">     NodePtr next;</div><div class="line">  </div><div class="line">     <span class="keyword">explicit</span> <a class="code" href="namespace_system_1_1_xml_1_1_schema.html#ac728d2cc5b09a5956f8da14930af590ea6c3a6944a808a7c0bbb6788dbec54a9f">Node</a>(int32_t value): m_value(value) {}</div><div class="line">  </div><div class="line">     int32_t GetValue()<span class="keyword"> const</span></div><div class="line"><span class="keyword">     </span>{</div><div class="line">       <span class="keywordflow">return</span> m_value;</div><div class="line">     }</div><div class="line">   };</div><div class="line">  </div><div class="line">   <span class="comment">// This function prints a value that is stored by the specified node.</span></div><div class="line">   <span class="keywordtype">void</span> PrintValue(<a class="code" href="class_system_1_1_smart_ptr.html">System::SmartPtr&lt;Node&gt;</a> &amp;node)</div><div class="line">   {</div><div class="line">     std::cout &lt;&lt; (node == <span class="keyword">nullptr</span> ? <span class="stringliteral">&quot;nullptr&quot;</span> : std::to_string(node-&gt;GetValue())) &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">   }</div><div class="line">  </div><div class="line">   <span class="keywordtype">int</span> main()</div><div class="line">   {</div><div class="line">     <a class="code" href="class_system_1_1_smart_ptr.html">System::SharedPtr&lt;Node&gt;</a> node;</div><div class="line">  </div><div class="line">     {</div><div class="line">       <span class="keyword">auto</span> first = System::MakeObject&lt;Node&gt;(1);</div><div class="line">       node = System::MakeObject&lt;Node&gt;(2);</div><div class="line">       <span class="keyword">auto</span> last = System::MakeObject&lt;Node&gt;(3);</div><div class="line">  </div><div class="line">       first-&gt;next = node;</div><div class="line">       node-&gt;previous = first;</div><div class="line">       node-&gt;next = last;</div><div class="line">       last-&gt;previous = node;</div><div class="line">     }</div><div class="line">  </div><div class="line">     PrintValue(node-&gt;previous);</div><div class="line">     PrintValue(node);</div><div class="line">     PrintValue(node-&gt;next);</div><div class="line">     std::cout &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">     {</div><div class="line">       <span class="keyword">auto</span> first = System::MakeObject&lt;Node&gt;(4);</div><div class="line">       <span class="keyword">auto</span> middle = System::MakeObject&lt;Node&gt;(5);</div><div class="line">       <span class="keyword">auto</span> last = System::MakeObject&lt;Node&gt;(6);</div><div class="line">  </div><div class="line">       first-&gt;next = middle;</div><div class="line">       middle-&gt;previous = first;</div><div class="line">       middle-&gt;next = last;</div><div class="line">       last-&gt;previous = middle;</div><div class="line">  </div><div class="line">       node = <a class="code" href="class_cs_to_cpp_porter_1_1_memory_management.html#a9aad264fdbcfc41c4d6bb36e7cc810e6">CsToCppPorter::MemoryManagement::ExtendLifetime</a>(middle, first, last);</div><div class="line">     }</div><div class="line">  </div><div class="line">     PrintValue(node-&gt;previous);</div><div class="line">     PrintValue(node);</div><div class="line">     PrintValue(node-&gt;next);</div><div class="line">     std::cout &lt;&lt; std::endl;</div><div class="line">  </div><div class="line">     <span class="keywordflow">return</span> 0;</div><div class="line">   }</div><div class="line">   <span class="comment">/*</span></div><div class="line"><span class="comment">*  This code example produces the following output:</span></div><div class="line"><span class="comment">*  nullptr 2 nullptr</span></div><div class="line"><span class="comment">*  4 5 6</span></div><div class="line"><span class="comment">   */</span></div></div><!-- fragment --> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_cs_to_cpp_porter.html">CsToCppPorter</a></li><li class="navelem"><a class="el" href="class_cs_to_cpp_porter_1_1_memory_management.html">MemoryManagement</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
