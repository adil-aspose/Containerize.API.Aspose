<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aspose.PDF for C++: System::SmartPtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aspose.PDF for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_system_1_1_smart_ptr.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_system_1_1_smart_ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">System::SmartPtr&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. This pointer type follows intrusive pointer semantics. Reference counter is stored either in <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> itself or in counter structure which is tied to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> instance tightly. In any case, all <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> instances form single ownership group regardless how they were created which is unlike how std::shared_ptr class behaves. Converting raw pointer to <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> is safe given there are other <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> instances holding shared references to the same object. <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class instance can be in one of two states: shared pointer and weak pointer. To keep object alive, one should have count of shared references to it positive. Both weak and shared pointers can be used to access pointed object (to call methods, read or write fields, etc.), but weak pointers do not participate to shared pointer reference counting. <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> is being deleted when the last 'shared' <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointer to it is being destroyed. So, make sure that this doesn't happen when no other shared <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointers to object exist, e. g. during object construction or destruction. Use System::Object::ThisProtector sentry objects (in C++ code) or CppCTORSelfReference or CppSelfReference attribute (in C# code being ported) to fix this issue. Similarily, make sure to break loop references by using <a class="el" href="class_system_1_1_weak_ptr.html" title="Subclass of System::SmartPtr which sets itself to weak mode at construction. Please note that this cl...">System::WeakPtr</a> pointer class or <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45a7324e3727807d95037eb19d304fd91ec" title="Weak mode: pointer does not participate in reference counting. ">System::SmartPtrMode::Weak</a> pointer mode (in C++ code) or CppWeakPtr attribute (in C# code being ported). If two or more objects reference each other using 'shared' pointers, they will never be deleted. If pointer type (weak or shared) should be switched in runtime, use <a class="el" href="class_system_1_1_smart_ptr.html#a385f3f04c1c03af17ba1488e6610756f" title="Sets pointer mode. May alter referenced object&#39;s reference counts. ">System::SmartPtr&lt;T&gt;::set_Mode()</a> method or <a class="el" href="class_system_1_1_dynamic_weak_ptr.html" title="Smart pointer class which tracks pointer modes of template arguments of stored object and updates the...">System::DynamicWeakPtr</a> class. <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class doesn't contain any virtual methods. You should only inherit it if you're creating a memory management strategy of your own. This type is a pointer to manage other object's deletion. It should be allocated on stack and passed to functions either by value or by const reference.  
 <a href="class_system_1_1_smart_ptr.html#details">More...</a></p>

<p>Inherited by <a class="el" href="class_system_1_1_collections_1_1_bit_array_ptr.html">System::Collections::BitArrayPtr</a>, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_dictionary_ptr.html">System::Collections::Generic::DictionaryPtr&lt; T, V &gt;</a>, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_hash_set_ptr.html">System::Collections::Generic::HashSetPtr&lt; T &gt;</a>, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">System::Collections::Generic::ListPtr&lt; T &gt;</a>, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_queue_ptr.html">System::Collections::Generic::QueuePtr&lt; T &gt;</a>, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_sorted_dictionary_ptr.html">System::Collections::Generic::SortedDictionaryPtr&lt; T, V &gt;</a>, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_stack_ptr.html">System::Collections::Generic::StackPtr&lt; T &gt;</a>, <a class="el" href="class_system_1_1_collections_1_1_specialized_1_1_string_collection_ptr.html">System::Collections::Specialized::StringCollectionPtr</a>, <a class="el" href="class_system_1_1_dynamic_weak_ptr.html">System::DynamicWeakPtr&lt; T, trunkMode, weakLeafs &gt;</a>, <a class="el" href="class_system_1_1_security_1_1_cryptography_1_1_x509_certificates_1_1_x509_certificate2_collection_ptr.html">System::Security::Cryptography::X509Certificates::X509Certificate2CollectionPtr</a>, <a class="el" href="class_system_1_1_security_1_1_cryptography_1_1_x509_certificates_1_1_x509_certificate_collection_ptr.html">System::Security::Cryptography::X509Certificates::X509CertificateCollectionPtr</a>, <a class="el" href="class_system_1_1_security_1_1_cryptography_1_1_x509_certificates_1_1_x509_extension_collection_ptr.html">System::Security::Cryptography::X509Certificates::X509ExtensionCollectionPtr</a>, <a class="el" href="class_system_1_1_text_1_1_regular_expressions_1_1_group_collection_ptr.html">System::Text::RegularExpressions::GroupCollectionPtr</a>, and <a class="el" href="class_system_1_1_weak_ptr.html">System::WeakPtr&lt; T &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr_1_1_data.html">Data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal data storage class which hides data members and enforces neccessary asserts around them.  <a href="class_system_1_1_smart_ptr_1_1_data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae5fa4ef8254b0633e5e7c72aea89a8b7"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a></td></tr>
<tr class="memdesc:ae5fa4ef8254b0633e5e7c72aea89a8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointed type.  <a href="#ae5fa4ef8254b0633e5e7c72aea89a8b7">More...</a><br /></td></tr>
<tr class="separator:ae5fa4ef8254b0633e5e7c72aea89a8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e11d1bcc30087b34a421716673fc24"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a></td></tr>
<tr class="memdesc:a17e11d1bcc30087b34a421716673fc24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized smart pointer type.  <a href="#a17e11d1bcc30087b34a421716673fc24">More...</a><br /></td></tr>
<tr class="separator:a17e11d1bcc30087b34a421716673fc24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecc0b987116c3c26399a869bc3f8e4b"><td class="memItemLeft" align="right" valign="top">typedef System::Details::ArrayTypeResolver&lt; T &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a8ecc0b987116c3c26399a869bc3f8e4b">ArrayType</a></td></tr>
<tr class="memdesc:a8ecc0b987116c3c26399a869bc3f8e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as Pointee_, if it is a specialization of <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">System::Array</a>, and void otherwise.  <a href="#a8ecc0b987116c3c26399a869bc3f8e4b">More...</a><br /></td></tr>
<tr class="separator:a8ecc0b987116c3c26399a869bc3f8e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd6d9ab409a697ea43c37b437a2c0a9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a3bd6d9ab409a697ea43c37b437a2c0a9">ValueType</a> = typename System::Details::SelectType&lt; typename System::Details::ArrayTypeResolver&lt; T &gt;::value_type &gt;::type</td></tr>
<tr class="memdesc:a3bd6d9ab409a697ea43c37b437a2c0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage type of pointed array. Only meaningful if T is a specialization of <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">System::Array</a>.  <a href="#a3bd6d9ab409a697ea43c37b437a2c0a9">More...</a><br /></td></tr>
<tr class="separator:a3bd6d9ab409a697ea43c37b437a2c0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a33d8fda4db8d2775b2582c1e95df3b14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a33d8fda4db8d2775b2582c1e95df3b14">SmartPtr</a> (<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> mode)</td></tr>
<tr class="memdesc:a33d8fda4db8d2775b2582c1e95df3b14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object of required mode.  <a href="#a33d8fda4db8d2775b2582c1e95df3b14">More...</a><br /></td></tr>
<tr class="separator:a33d8fda4db8d2775b2582c1e95df3b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2233902636b1e8f57f0841920f6dab10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a2233902636b1e8f57f0841920f6dab10">SmartPtr</a> (std::nullptr_t=nullptr, <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> mode=<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a>)</td></tr>
<tr class="memdesc:a2233902636b1e8f57f0841920f6dab10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates null-pointer <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object of required mode.  <a href="#a2233902636b1e8f57f0841920f6dab10">More...</a><br /></td></tr>
<tr class="separator:a2233902636b1e8f57f0841920f6dab10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d867b542a1b23498794922d3771c2fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a7d867b542a1b23498794922d3771c2fb">SmartPtr</a> (<a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *<a class="el" href="class_system_1_1_object.html">object</a>, <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> mode=<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a>)</td></tr>
<tr class="memdesc:a7d867b542a1b23498794922d3771c2fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointing to specified object, or converts raw pointer to <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a>.  <a href="#a7d867b542a1b23498794922d3771c2fb">More...</a><br /></td></tr>
<tr class="separator:a7d867b542a1b23498794922d3771c2fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c95c3d30a9129908da48b9cc1f10e2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#aa7c95c3d30a9129908da48b9cc1f10e2">SmartPtr</a> (const <a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;ptr, <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> mode=<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a>)</td></tr>
<tr class="memdesc:aa7c95c3d30a9129908da48b9cc1f10e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Both pointers point to the same object afterwards.  <a href="#aa7c95c3d30a9129908da48b9cc1f10e2">More...</a><br /></td></tr>
<tr class="separator:aa7c95c3d30a9129908da48b9cc1f10e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49897bcf9e2d8b6a4a9ae17dcc68de81"><td class="memTemplParams" colspan="2">template&lt;class Q , typename  = typename std::enable_if&lt;System::detail::is_pointer_convertible&lt;Q, Pointee_&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:a49897bcf9e2d8b6a4a9ae17dcc68de81"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a49897bcf9e2d8b6a4a9ae17dcc68de81">SmartPtr</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;x, <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> mode=<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a>)</td></tr>
<tr class="memdesc:a49897bcf9e2d8b6a4a9ae17dcc68de81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructs <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Both pointers point to the same object afterwards. Performs type conversion if allowed.  <a href="#a49897bcf9e2d8b6a4a9ae17dcc68de81">More...</a><br /></td></tr>
<tr class="separator:a49897bcf9e2d8b6a4a9ae17dcc68de81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b0a88d3d08332e399ed45de4f078cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#aa4b0a88d3d08332e399ed45de4f078cf">SmartPtr</a> (<a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&amp;x, <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> mode=<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a>) noexcept</td></tr>
<tr class="memdesc:aa4b0a88d3d08332e399ed45de4f078cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructs <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Effectively, swaps two pointers, if they are both of same mode. x may be unusable after call.  <a href="#aa4b0a88d3d08332e399ed45de4f078cf">More...</a><br /></td></tr>
<tr class="separator:aa4b0a88d3d08332e399ed45de4f078cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f8bd76b9a4d2bb7181c3ca86bf5d1d"><td class="memTemplParams" colspan="2">template&lt;typename Y &gt; </td></tr>
<tr class="memitem:a30f8bd76b9a4d2bb7181c3ca86bf5d1d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a30f8bd76b9a4d2bb7181c3ca86bf5d1d">SmartPtr</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; Y &gt;&gt; &amp;src, <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> mode=<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a>)</td></tr>
<tr class="memdesc:a30f8bd76b9a4d2bb7181c3ca86bf5d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts type of referenced array by creating a new array of different type. Useful if in C# there is an array type cast which is unsupported in C++.  <a href="#a30f8bd76b9a4d2bb7181c3ca86bf5d1d">More...</a><br /></td></tr>
<tr class="separator:a30f8bd76b9a4d2bb7181c3ca86bf5d1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4148ee591bf6cf4accb1f033e5f38b6e"><td class="memTemplParams" colspan="2">template&lt;typename Y , typename  = typename std::enable_if&lt;std::is_same&lt;Y, EmptyArrayInitializer&gt;::value, void&gt;::type&gt; </td></tr>
<tr class="memitem:a4148ee591bf6cf4accb1f033e5f38b6e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a4148ee591bf6cf4accb1f033e5f38b6e">SmartPtr</a> (const Y &amp;)</td></tr>
<tr class="memdesc:a4148ee591bf6cf4accb1f033e5f38b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes empty array. Used to port some C# code constructs.  <a href="#a4148ee591bf6cf4accb1f033e5f38b6e">More...</a><br /></td></tr>
<tr class="separator:a4148ee591bf6cf4accb1f033e5f38b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121c4f3d4560def4734439f86c47626f"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a121c4f3d4560def4734439f86c47626f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a121c4f3d4560def4734439f86c47626f">SmartPtr</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; P &gt; &amp;ptr, <a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *p, <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> mode=<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a>)</td></tr>
<tr class="memdesc:a121c4f3d4560def4734439f86c47626f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> which shares ownership information with the initial value of ptr, but holds an unrelated and unmanaged pointer p.  <a href="#a121c4f3d4560def4734439f86c47626f">More...</a><br /></td></tr>
<tr class="separator:a121c4f3d4560def4734439f86c47626f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9ecbd0ae8a75e0f8b2f0f3090b8b5e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a6e9ecbd0ae8a75e0f8b2f0f3090b8b5e">~SmartPtr</a> ()</td></tr>
<tr class="memdesc:a6e9ecbd0ae8a75e0f8b2f0f3090b8b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. If required, decreases pointed object's reference counter and deletes object.  <a href="#a6e9ecbd0ae8a75e0f8b2f0f3090b8b5e">More...</a><br /></td></tr>
<tr class="separator:a6e9ecbd0ae8a75e0f8b2f0f3090b8b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e9b6a69857b328e11189e4c0d048838"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a2e9b6a69857b328e11189e4c0d048838">operator=</a> (<a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&amp;x) noexcept</td></tr>
<tr class="memdesc:a2e9b6a69857b328e11189e4c0d048838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assigns <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. x becomes unusable.  <a href="#a2e9b6a69857b328e11189e4c0d048838">More...</a><br /></td></tr>
<tr class="separator:a2e9b6a69857b328e11189e4c0d048838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e679a8b76c64a4fc65dc2c82e1388f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a26e679a8b76c64a4fc65dc2c82e1388f">operator=</a> (const <a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;x)</td></tr>
<tr class="memdesc:a26e679a8b76c64a4fc65dc2c82e1388f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assigns <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object.  <a href="#a26e679a8b76c64a4fc65dc2c82e1388f">More...</a><br /></td></tr>
<tr class="separator:a26e679a8b76c64a4fc65dc2c82e1388f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298afbc403cec691d95f9a472dd82312"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a298afbc403cec691d95f9a472dd82312"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a298afbc403cec691d95f9a472dd82312">operator=</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;x)</td></tr>
<tr class="memdesc:a298afbc403cec691d95f9a472dd82312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assigns <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Does required type conversions.  <a href="#a298afbc403cec691d95f9a472dd82312">More...</a><br /></td></tr>
<tr class="separator:a298afbc403cec691d95f9a472dd82312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812c0239d6626c46b48a88ce836520b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a812c0239d6626c46b48a88ce836520b1">operator=</a> (<a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *p)</td></tr>
<tr class="memdesc:a812c0239d6626c46b48a88ce836520b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assigns raw pointer to <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object.  <a href="#a812c0239d6626c46b48a88ce836520b1">More...</a><br /></td></tr>
<tr class="separator:a812c0239d6626c46b48a88ce836520b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01d5a86f8a9c8c7adedcf5367298b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#ad01d5a86f8a9c8c7adedcf5367298b8f">operator=</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:ad01d5a86f8a9c8c7adedcf5367298b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointer value to nullptr.  <a href="#ad01d5a86f8a9c8c7adedcf5367298b8f">More...</a><br /></td></tr>
<tr class="separator:ad01d5a86f8a9c8c7adedcf5367298b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c7e6a1459f68db229aad33a1794a598"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a6c7e6a1459f68db229aad33a1794a598">operator-&gt;</a> () const</td></tr>
<tr class="memdesc:a6c7e6a1459f68db229aad33a1794a598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to access members of referenced object.  <a href="#a6c7e6a1459f68db229aad33a1794a598">More...</a><br /></td></tr>
<tr class="separator:a6c7e6a1459f68db229aad33a1794a598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c88e79d275eeb8573cb7b2fb0908464"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a1c88e79d275eeb8573cb7b2fb0908464">operator==</a> (std::nullptr_t) const</td></tr>
<tr class="memdesc:a1c88e79d275eeb8573cb7b2fb0908464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if pointer points to nullptr.  <a href="#a1c88e79d275eeb8573cb7b2fb0908464">More...</a><br /></td></tr>
<tr class="separator:a1c88e79d275eeb8573cb7b2fb0908464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ca299886b9c92177ff371b3f2b2240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a89ca299886b9c92177ff371b3f2b2240">get</a> () const</td></tr>
<tr class="memdesc:a89ca299886b9c92177ff371b3f2b2240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointed object.  <a href="#a89ca299886b9c92177ff371b3f2b2240">More...</a><br /></td></tr>
<tr class="separator:a89ca299886b9c92177ff371b3f2b2240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173213a7a16c0b0d6f1f55c5f6f68f9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a173213a7a16c0b0d6f1f55c5f6f68f9b">get_shared</a> () const</td></tr>
<tr class="memdesc:a173213a7a16c0b0d6f1f55c5f6f68f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointed object, but asserts that pointer is in shared mode.  <a href="#a173213a7a16c0b0d6f1f55c5f6f68f9b">More...</a><br /></td></tr>
<tr class="separator:a173213a7a16c0b0d6f1f55c5f6f68f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95aa8d542947f56f9437f144af2dbfef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a95aa8d542947f56f9437f144af2dbfef">reset</a> (<a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *ptr)</td></tr>
<tr class="memdesc:a95aa8d542947f56f9437f144af2dbfef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointed object.  <a href="#a95aa8d542947f56f9437f144af2dbfef">More...</a><br /></td></tr>
<tr class="separator:a95aa8d542947f56f9437f144af2dbfef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0d2cf3905a511a44cd390ac130d4c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a8c0d2cf3905a511a44cd390ac130d4c7">reset</a> ()</td></tr>
<tr class="memdesc:a8c0d2cf3905a511a44cd390ac130d4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes pointer pointing to nullptr.  <a href="#a8c0d2cf3905a511a44cd390ac130d4c7">More...</a><br /></td></tr>
<tr class="separator:a8c0d2cf3905a511a44cd390ac130d4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa92876859dfb3fa431d1e67149fe9e0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#aa92876859dfb3fa431d1e67149fe9e0f">get_Mode</a> () const</td></tr>
<tr class="memdesc:aa92876859dfb3fa431d1e67149fe9e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointer mode.  <a href="#aa92876859dfb3fa431d1e67149fe9e0f">More...</a><br /></td></tr>
<tr class="separator:aa92876859dfb3fa431d1e67149fe9e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f9848b9f2a4d43d113c20f7d809461"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a56f9848b9f2a4d43d113c20f7d809461">IsShared</a> () const</td></tr>
<tr class="memdesc:a56f9848b9f2a4d43d113c20f7d809461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if pointer is in shared mode.  <a href="#a56f9848b9f2a4d43d113c20f7d809461">More...</a><br /></td></tr>
<tr class="separator:a56f9848b9f2a4d43d113c20f7d809461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ae11690e04c0ca8c91af774fc21d9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a76ae11690e04c0ca8c91af774fc21d9e">IsWeak</a> () const</td></tr>
<tr class="memdesc:a76ae11690e04c0ca8c91af774fc21d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if pointer is in weak mode.  <a href="#a76ae11690e04c0ca8c91af774fc21d9e">More...</a><br /></td></tr>
<tr class="separator:a76ae11690e04c0ca8c91af774fc21d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb146194629f48ed9b73c00dcaa25871"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#acb146194629f48ed9b73c00dcaa25871">IsAliasingPtr</a> () const</td></tr>
<tr class="memdesc:acb146194629f48ed9b73c00dcaa25871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if pointer is pointed to another object than owned (created by an aliasing constructor).  <a href="#acb146194629f48ed9b73c00dcaa25871">More...</a><br /></td></tr>
<tr class="separator:acb146194629f48ed9b73c00dcaa25871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4706d9e3df03bfba5e8522b484629d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a7d4706d9e3df03bfba5e8522b484629d">RemoveAliasing</a> () const</td></tr>
<tr class="memdesc:a7d4706d9e3df03bfba5e8522b484629d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes aliasing (created by an aliasing constructor) from pointer, makes sure it manages (if shared) or tracks (if weak) the same object it points to.  <a href="#a7d4706d9e3df03bfba5e8522b484629d">More...</a><br /></td></tr>
<tr class="separator:a7d4706d9e3df03bfba5e8522b484629d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a385f3f04c1c03af17ba1488e6610756f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a385f3f04c1c03af17ba1488e6610756f">set_Mode</a> (<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> mode)</td></tr>
<tr class="memdesc:a385f3f04c1c03af17ba1488e6610756f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointer mode. May alter referenced object's reference counts.  <a href="#a385f3f04c1c03af17ba1488e6610756f">More...</a><br /></td></tr>
<tr class="separator:a385f3f04c1c03af17ba1488e6610756f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178dc1f2002d8bed885957faddb5abce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a178dc1f2002d8bed885957faddb5abce">operator*</a> () const</td></tr>
<tr class="memdesc:a178dc1f2002d8bed885957faddb5abce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets reference to pointed object. Asserts that pointer is not null.  <a href="#a178dc1f2002d8bed885957faddb5abce">More...</a><br /></td></tr>
<tr class="separator:a178dc1f2002d8bed885957faddb5abce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbc4396d2b1370661e7012dda41f634"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a5bbc4396d2b1370661e7012dda41f634">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a5bbc4396d2b1370661e7012dda41f634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if pointer is not null.  <a href="#a5bbc4396d2b1370661e7012dda41f634">More...</a><br /></td></tr>
<tr class="separator:a5bbc4396d2b1370661e7012dda41f634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5fe0a1b3e5df4d79ed7a049af785fcb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#af5fe0a1b3e5df4d79ed7a049af785fcb">operator!</a> () const noexcept</td></tr>
<tr class="memdesc:af5fe0a1b3e5df4d79ed7a049af785fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if pointer is null.  <a href="#af5fe0a1b3e5df4d79ed7a049af785fcb">More...</a><br /></td></tr>
<tr class="separator:af5fe0a1b3e5df4d79ed7a049af785fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa517c819d174bc84a3fbf12bda848775"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:aa517c819d174bc84a3fbf12bda848775"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#aa517c819d174bc84a3fbf12bda848775">operator&lt;</a> (Y *p) const</td></tr>
<tr class="memdesc:aa517c819d174bc84a3fbf12bda848775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides less-compare semantics for <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class.  <a href="#aa517c819d174bc84a3fbf12bda848775">More...</a><br /></td></tr>
<tr class="separator:aa517c819d174bc84a3fbf12bda848775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bcc5c6335da82f0d896a3c74ce8d7c"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ae5bcc5c6335da82f0d896a3c74ce8d7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#ae5bcc5c6335da82f0d896a3c74ce8d7c">operator&lt;</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt; const &amp;x) const</td></tr>
<tr class="memdesc:ae5bcc5c6335da82f0d896a3c74ce8d7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides less-compare semantics for <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class.  <a href="#ae5bcc5c6335da82f0d896a3c74ce8d7c">More...</a><br /></td></tr>
<tr class="separator:ae5bcc5c6335da82f0d896a3c74ce8d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f80f917ff95b23cf5f6ddd8cb676f67"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a8f80f917ff95b23cf5f6ddd8cb676f67"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a8f80f917ff95b23cf5f6ddd8cb676f67">static_pointer_cast</a> () const</td></tr>
<tr class="memdesc:a8f80f917ff95b23cf5f6ddd8cb676f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts pointer to different type using static_cast on pointed object.  <a href="#a8f80f917ff95b23cf5f6ddd8cb676f67">More...</a><br /></td></tr>
<tr class="separator:a8f80f917ff95b23cf5f6ddd8cb676f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00aac4fd85b6626b59a4e5e292504ae"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:ab00aac4fd85b6626b59a4e5e292504ae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#ab00aac4fd85b6626b59a4e5e292504ae">dynamic_pointer_cast</a> () const</td></tr>
<tr class="memdesc:ab00aac4fd85b6626b59a4e5e292504ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts pointer to different type using dynamic_cast on pointed object.  <a href="#ab00aac4fd85b6626b59a4e5e292504ae">More...</a><br /></td></tr>
<tr class="separator:ab00aac4fd85b6626b59a4e5e292504ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795c9af8d7225a8ec66d27fa38e3938c"><td class="memTemplParams" colspan="2">template&lt;class Y &gt; </td></tr>
<tr class="memitem:a795c9af8d7225a8ec66d27fa38e3938c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a795c9af8d7225a8ec66d27fa38e3938c">const_pointer_cast</a> () const</td></tr>
<tr class="memdesc:a795c9af8d7225a8ec66d27fa38e3938c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts pointer to different type using const_cast on pointed object.  <a href="#a795c9af8d7225a8ec66d27fa38e3938c">More...</a><br /></td></tr>
<tr class="separator:a795c9af8d7225a8ec66d27fa38e3938c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5347a40d958c3c8569c4d319cee961"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a9c5347a40d958c3c8569c4d319cee961">Is</a> (const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;target) const</td></tr>
<tr class="memdesc:a9c5347a40d958c3c8569c4d319cee961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if pointed object is of specific type or its child type. Follows C# 'is' semantics.  <a href="#a9c5347a40d958c3c8569c4d319cee961">More...</a><br /></td></tr>
<tr class="separator:a9c5347a40d958c3c8569c4d319cee961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad071a0bdeeeefe7b7af879de7d33c9c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#ad071a0bdeeeefe7b7af879de7d33c9c9">GetObjectOrNull</a> () const</td></tr>
<tr class="memdesc:ad071a0bdeeeefe7b7af879de7d33c9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointed object (if any) or nullptr. Same as <a class="el" href="class_system_1_1_smart_ptr.html#a89ca299886b9c92177ff371b3f2b2240" title="Gets pointed object. ">get()</a>.  <a href="#ad071a0bdeeeefe7b7af879de7d33c9c9">More...</a><br /></td></tr>
<tr class="separator:ad071a0bdeeeefe7b7af879de7d33c9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b3e7dbcd96c4c306e88f3a92533789"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a22b3e7dbcd96c4c306e88f3a92533789">ToObjectPtr</a> () const</td></tr>
<tr class="memdesc:a22b3e7dbcd96c4c306e88f3a92533789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts any pointer type to pointer to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Doesn't require Pointee_ type to be complete.  <a href="#a22b3e7dbcd96c4c306e88f3a92533789">More...</a><br /></td></tr>
<tr class="separator:a22b3e7dbcd96c4c306e88f3a92533789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9005a9200f464e90c188bbf26f1f0be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#ad9005a9200f464e90c188bbf26f1f0be">GetPointer</a> () const</td></tr>
<tr class="memdesc:ad9005a9200f464e90c188bbf26f1f0be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets pointed object (if any) or nullptr. Same as <a class="el" href="class_system_1_1_smart_ptr.html#a89ca299886b9c92177ff371b3f2b2240" title="Gets pointed object. ">get()</a>.  <a href="#ad9005a9200f464e90c188bbf26f1f0be">More...</a><br /></td></tr>
<tr class="separator:ad9005a9200f464e90c188bbf26f1f0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978b5e81c223dd2d9cc0b9b92b4544a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a978b5e81c223dd2d9cc0b9b92b4544a8">get_shared_count</a> () const</td></tr>
<tr class="memdesc:a978b5e81c223dd2d9cc0b9b92b4544a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets number of shared pointers existing to referenced object, including current one. Asserts current pointer being in shared mode.  <a href="#a978b5e81c223dd2d9cc0b9b92b4544a8">More...</a><br /></td></tr>
<tr class="separator:a978b5e81c223dd2d9cc0b9b92b4544a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785edb8e734692c89b7e216796d51f60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a785edb8e734692c89b7e216796d51f60">SetContainedTemplateWeakPtr</a> (uint32_t argument) const</td></tr>
<tr class="memdesc:a785edb8e734692c89b7e216796d51f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls SetTemplateWeakPtr() method on pointed object (if any).  <a href="#a785edb8e734692c89b7e216796d51f60">More...</a><br /></td></tr>
<tr class="separator:a785edb8e734692c89b7e216796d51f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40e41a74ffc04d7881e449bd02ec862"><td class="memTemplParams" colspan="2">template&lt;typename Q  = T&gt; </td></tr>
<tr class="memitem:aa40e41a74ffc04d7881e449bd02ec862"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#aa40e41a74ffc04d7881e449bd02ec862">begin</a> () noexcept -&gt; decltype(std::declval&lt; Q &gt;().begin())</td></tr>
<tr class="memdesc:aa40e41a74ffc04d7881e449bd02ec862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#aa40e41a74ffc04d7881e449bd02ec862" title="Accessor for begin() method of an underling collection. Only compiles if SmartPtr_ is specialization ...">begin()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#aa40e41a74ffc04d7881e449bd02ec862" title="Accessor for begin() method of an underling collection. Only compiles if SmartPtr_ is specialization ...">begin()</a> method.  <a href="#aa40e41a74ffc04d7881e449bd02ec862">More...</a><br /></td></tr>
<tr class="separator:aa40e41a74ffc04d7881e449bd02ec862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585eca7a81ec7d16239f6c1988770d4f"><td class="memTemplParams" colspan="2">template&lt;typename Q  = T&gt; </td></tr>
<tr class="memitem:a585eca7a81ec7d16239f6c1988770d4f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a585eca7a81ec7d16239f6c1988770d4f">end</a> () noexcept -&gt; decltype(std::declval&lt; Q &gt;().end())</td></tr>
<tr class="memdesc:a585eca7a81ec7d16239f6c1988770d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#a585eca7a81ec7d16239f6c1988770d4f" title="Accessor for end() method of an underling collection. Only compiles if SmartPtr_ is specialization ty...">end()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#a585eca7a81ec7d16239f6c1988770d4f" title="Accessor for end() method of an underling collection. Only compiles if SmartPtr_ is specialization ty...">end()</a> method.  <a href="#a585eca7a81ec7d16239f6c1988770d4f">More...</a><br /></td></tr>
<tr class="separator:a585eca7a81ec7d16239f6c1988770d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eed15dc0f5a13cf5493ba33b44774c"><td class="memTemplParams" colspan="2">template&lt;typename Q  = T&gt; </td></tr>
<tr class="memitem:a02eed15dc0f5a13cf5493ba33b44774c"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a02eed15dc0f5a13cf5493ba33b44774c">begin</a> () const noexcept -&gt; decltype(std::declval&lt; const Q &gt;().begin())</td></tr>
<tr class="memdesc:a02eed15dc0f5a13cf5493ba33b44774c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#aa40e41a74ffc04d7881e449bd02ec862" title="Accessor for begin() method of an underling collection. Only compiles if SmartPtr_ is specialization ...">begin()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#aa40e41a74ffc04d7881e449bd02ec862" title="Accessor for begin() method of an underling collection. Only compiles if SmartPtr_ is specialization ...">begin()</a> method.  <a href="#a02eed15dc0f5a13cf5493ba33b44774c">More...</a><br /></td></tr>
<tr class="separator:a02eed15dc0f5a13cf5493ba33b44774c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d99a4c6d427503c95641d932747af4"><td class="memTemplParams" colspan="2">template&lt;typename Q  = T&gt; </td></tr>
<tr class="memitem:aa3d99a4c6d427503c95641d932747af4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#aa3d99a4c6d427503c95641d932747af4">end</a> () const noexcept -&gt; decltype(std::declval&lt; const Q &gt;().end())</td></tr>
<tr class="memdesc:aa3d99a4c6d427503c95641d932747af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#a585eca7a81ec7d16239f6c1988770d4f" title="Accessor for end() method of an underling collection. Only compiles if SmartPtr_ is specialization ty...">end()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#a585eca7a81ec7d16239f6c1988770d4f" title="Accessor for end() method of an underling collection. Only compiles if SmartPtr_ is specialization ty...">end()</a> method.  <a href="#aa3d99a4c6d427503c95641d932747af4">More...</a><br /></td></tr>
<tr class="separator:aa3d99a4c6d427503c95641d932747af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadea97557340ffa13ff6996eae24ed8"><td class="memTemplParams" colspan="2">template&lt;typename Q  = T&gt; </td></tr>
<tr class="memitem:acadea97557340ffa13ff6996eae24ed8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#acadea97557340ffa13ff6996eae24ed8">cbegin</a> () const noexcept -&gt; decltype(std::declval&lt; const Q &gt;().cbegin())</td></tr>
<tr class="memdesc:acadea97557340ffa13ff6996eae24ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#acadea97557340ffa13ff6996eae24ed8" title="Accessor for cbegin() method of an underling collection. Only compiles if SmartPtr_ is specialization...">cbegin()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#acadea97557340ffa13ff6996eae24ed8" title="Accessor for cbegin() method of an underling collection. Only compiles if SmartPtr_ is specialization...">cbegin()</a> method.  <a href="#acadea97557340ffa13ff6996eae24ed8">More...</a><br /></td></tr>
<tr class="separator:acadea97557340ffa13ff6996eae24ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949ade5ac2636ccf3073dd71be937b5b"><td class="memTemplParams" colspan="2">template&lt;typename Q  = T&gt; </td></tr>
<tr class="memitem:a949ade5ac2636ccf3073dd71be937b5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a949ade5ac2636ccf3073dd71be937b5b">cend</a> () const noexcept -&gt; decltype(std::declval&lt; const Q &gt;().cend())</td></tr>
<tr class="memdesc:a949ade5ac2636ccf3073dd71be937b5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#a949ade5ac2636ccf3073dd71be937b5b" title="Accessor for cend() method of an underling collection. Only compiles if SmartPtr_ is specialization t...">cend()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#a949ade5ac2636ccf3073dd71be937b5b" title="Accessor for cend() method of an underling collection. Only compiles if SmartPtr_ is specialization t...">cend()</a> method.  <a href="#a949ade5ac2636ccf3073dd71be937b5b">More...</a><br /></td></tr>
<tr class="separator:a949ade5ac2636ccf3073dd71be937b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00dd28a9a6cff88272a3cf0f98beefdc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a00dd28a9a6cff88272a3cf0f98beefdc">GetHashCode</a> () const</td></tr>
<tr class="memdesc:a00dd28a9a6cff88272a3cf0f98beefdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="class_system_1_1_smart_ptr.html#a00dd28a9a6cff88272a3cf0f98beefdc" title="Calls GetHashCode() on pointed object. ">GetHashCode()</a> on pointed object.  <a href="#a00dd28a9a6cff88272a3cf0f98beefdc">More...</a><br /></td></tr>
<tr class="separator:a00dd28a9a6cff88272a3cf0f98beefdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32985dae73c069674e7e36368ba562c7"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a32985dae73c069674e7e36368ba562c7">GetObjectNotNull</a> () const</td></tr>
<tr class="memdesc:a32985dae73c069674e7e36368ba562c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets currently referenced object (if any) or throws.  <a href="#a32985dae73c069674e7e36368ba562c7">More...</a><br /></td></tr>
<tr class="separator:a32985dae73c069674e7e36368ba562c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a995a1d453658632e43becdb65592f7bf"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a995a1d453658632e43becdb65592f7bf">Type</a> ()</td></tr>
<tr class="memdesc:a995a1d453658632e43becdb65592f7bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcut to get <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">System::TypeInfo</a> object for the Pointee_ type.  <a href="#a995a1d453658632e43becdb65592f7bf">More...</a><br /></td></tr>
<tr class="separator:a995a1d453658632e43becdb65592f7bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a714365e177e62944d731d8f84711de20"><td class="memTemplParams" colspan="2">template&lt;typename IdxType &gt; </td></tr>
<tr class="memitem:a714365e177e62944d731d8f84711de20"><td class="memTemplItemLeft" align="right" valign="top">decltype(System::Details::GetByIndex(std::declval&lt; const <a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> * &gt;(), std::declval&lt; IdxType &gt;())&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a714365e177e62944d731d8f84711de20">operator[]</a> )(IdxType idx) const</td></tr>
<tr class="memdesc:a714365e177e62944d731d8f84711de20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor for array elements. Only compiles if SmartPtr_ is specialization of <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">System::Array</a>.  <a href="#a714365e177e62944d731d8f84711de20">More...</a><br /></td></tr>
<tr class="separator:a714365e177e62944d731d8f84711de20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a589a37b44d605011f86db234679f9742"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_system_1_1_object.html">Object</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a589a37b44d605011f86db234679f9742">SharedRefReleaser</a></td></tr>
<tr class="memdesc:a589a37b44d605011f86db234679f9742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to use to release shared pointers. Depends on whether external refcount is on or off.  <a href="#a589a37b44d605011f86db234679f9742">More...</a><br /></td></tr>
<tr class="separator:a589a37b44d605011f86db234679f9742"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4ddf2525f32d5338e911ec0d3bc1b037"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a4ddf2525f32d5338e911ec0d3bc1b037">Lock</a> (<a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *<a class="el" href="class_system_1_1_object.html">object</a>)</td></tr>
<tr class="memdesc:a4ddf2525f32d5338e911ec0d3bc1b037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointee object. Increments shared or weak reference count, depending on pointer mode.  <a href="#a4ddf2525f32d5338e911ec0d3bc1b037">More...</a><br /></td></tr>
<tr class="separator:a4ddf2525f32d5338e911ec0d3bc1b037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d165e8054c5cdaf10d8668a73da60d"><td class="memTemplParams" colspan="2">template&lt;class Q &gt; </td></tr>
<tr class="memitem:a87d165e8054c5cdaf10d8668a73da60d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a87d165e8054c5cdaf10d8668a73da60d">Lock</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a87d165e8054c5cdaf10d8668a73da60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointee object. Increments shared or weak reference count, depending on pointer mode.  <a href="#a87d165e8054c5cdaf10d8668a73da60d">More...</a><br /></td></tr>
<tr class="separator:a87d165e8054c5cdaf10d8668a73da60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027a1056b8d0c6e9ace66505b7ea8b43"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a027a1056b8d0c6e9ace66505b7ea8b43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a027a1056b8d0c6e9ace66505b7ea8b43">LockSharedFromShared</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a027a1056b8d0c6e9ace66505b7ea8b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointee object. Asserts that both current object and ptr are in shared mode.  <a href="#a027a1056b8d0c6e9ace66505b7ea8b43">More...</a><br /></td></tr>
<tr class="separator:a027a1056b8d0c6e9ace66505b7ea8b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edce4ef76508fc370e331f94764519e"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:a4edce4ef76508fc370e331f94764519e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a4edce4ef76508fc370e331f94764519e">LockSharedFromWeak</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a4edce4ef76508fc370e331f94764519e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointee object. Asserts that current object is in shared mode and ptr is in weak mode.  <a href="#a4edce4ef76508fc370e331f94764519e">More...</a><br /></td></tr>
<tr class="separator:a4edce4ef76508fc370e331f94764519e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac453356c08003795d0184130e4370884"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ac453356c08003795d0184130e4370884"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#ac453356c08003795d0184130e4370884">LockWeakFromShared</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;ptr)</td></tr>
<tr class="memdesc:ac453356c08003795d0184130e4370884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointee object. Asserts that current object is in weak mode and ptr is in shared mode.  <a href="#ac453356c08003795d0184130e4370884">More...</a><br /></td></tr>
<tr class="separator:ac453356c08003795d0184130e4370884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10d24eb3d99e4e3e64b8c7e8ef1b7e8"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:af10d24eb3d99e4e3e64b8c7e8ef1b7e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#af10d24eb3d99e4e3e64b8c7e8ef1b7e8">LockWeakFromWeak</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;ptr)</td></tr>
<tr class="memdesc:af10d24eb3d99e4e3e64b8c7e8ef1b7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets pointee object. Asserts that both current object and ptr are in weak mode.  <a href="#af10d24eb3d99e4e3e64b8c7e8ef1b7e8">More...</a><br /></td></tr>
<tr class="separator:af10d24eb3d99e4e3e64b8c7e8ef1b7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbafb7ca2ad65ea55d4cc1928002db01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#afbafb7ca2ad65ea55d4cc1928002db01">ReleaseAndGetObjectToDelete</a> ()</td></tr>
<tr class="memdesc:afbafb7ca2ad65ea55d4cc1928002db01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements currently referenced object's shared or weak pointer counter, depending on current pointer mode.  <a href="#afbafb7ca2ad65ea55d4cc1928002db01">More...</a><br /></td></tr>
<tr class="separator:afbafb7ca2ad65ea55d4cc1928002db01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8ce7201566a90b7e9c738d4cd12fff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html#a589a37b44d605011f86db234679f9742">SharedRefReleaser</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#aee8ce7201566a90b7e9c738d4cd12fff">GetSharedReleaser</a> () const</td></tr>
<tr class="memdesc:aee8ce7201566a90b7e9c738d4cd12fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets object to use to release shared pointer to.  <a href="#aee8ce7201566a90b7e9c738d4cd12fff">More...</a><br /></td></tr>
<tr class="separator:aee8ce7201566a90b7e9c738d4cd12fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8edea637363fcfdae7895292fd3b67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a2e8edea637363fcfdae7895292fd3b67">ReleaseSharedAndGetObjectToDelete</a> ()</td></tr>
<tr class="memdesc:a2e8edea637363fcfdae7895292fd3b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements currently referenced object's shared pointer counter.  <a href="#a2e8edea637363fcfdae7895292fd3b67">More...</a><br /></td></tr>
<tr class="separator:a2e8edea637363fcfdae7895292fd3b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc398c7a2a917efb9e11a1e50efed4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a2fbc398c7a2a917efb9e11a1e50efed4">ReleaseWeak</a> ()</td></tr>
<tr class="memdesc:a2fbc398c7a2a917efb9e11a1e50efed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements currently referenced object's weak pointer counter.  <a href="#a2fbc398c7a2a917efb9e11a1e50efed4">More...</a><br /></td></tr>
<tr class="separator:a2fbc398c7a2a917efb9e11a1e50efed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cd8800596928f8e2cfdc0eb2013746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#ab1cd8800596928f8e2cfdc0eb2013746">MoveSharedFromWeak</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:ab1cd8800596928f8e2cfdc0eb2013746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements move semantics. Asserts that current object is in shared mode and x is in weak mode.  <a href="#ab1cd8800596928f8e2cfdc0eb2013746">More...</a><br /></td></tr>
<tr class="separator:ab1cd8800596928f8e2cfdc0eb2013746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832f9561657fc1eb7cb1306d323d00ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a832f9561657fc1eb7cb1306d323d00ec">MoveWeakFromShared</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> &amp;&amp;x)</td></tr>
<tr class="memdesc:a832f9561657fc1eb7cb1306d323d00ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements move semantics. Asserts that current object is in weak mode and x is in shared mode.  <a href="#a832f9561657fc1eb7cb1306d323d00ec">More...</a><br /></td></tr>
<tr class="separator:a832f9561657fc1eb7cb1306d323d00ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd525096f933cbd94a807d32344333ec"><td class="memTemplParams" colspan="2">template&lt;typename Q , typename R  = decltype(std::declval&lt;Q*&gt;()-&gt;GetHashCode())&gt; </td></tr>
<tr class="memitem:afd525096f933cbd94a807d32344333ec"><td class="memTemplItemLeft" align="right" valign="top">R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#afd525096f933cbd94a807d32344333ec">GetHashCodeImpl</a> (Q *) const</td></tr>
<tr class="memdesc:afd525096f933cbd94a807d32344333ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls into <a class="el" href="class_system_1_1_smart_ptr.html#a00dd28a9a6cff88272a3cf0f98beefdc" title="Calls GetHashCode() on pointed object. ">GetHashCode()</a> method if it is available on Pointee_ type (which is true if it is a complete type).  <a href="#afd525096f933cbd94a807d32344333ec">More...</a><br /></td></tr>
<tr class="separator:afd525096f933cbd94a807d32344333ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69caf8f25f5602a5afc2af6d2221525"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#aa69caf8f25f5602a5afc2af6d2221525">GetHashCodeImpl</a> (void *) const</td></tr>
<tr class="memdesc:aa69caf8f25f5602a5afc2af6d2221525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <a class="el" href="class_system_1_1_smart_ptr.html#a00dd28a9a6cff88272a3cf0f98beefdc" title="Calls GetHashCode() on pointed object. ">GetHashCode()</a> method from <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> if it is not available on Pointee_ type (e. g. if it is incomplete).  <a href="#aa69caf8f25f5602a5afc2af6d2221525">More...</a><br /></td></tr>
<tr class="separator:aa69caf8f25f5602a5afc2af6d2221525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab58eb3135234d91805cec40729214a15"><td class="memTemplParams" colspan="2">template&lt;typename Q &gt; </td></tr>
<tr class="memitem:ab58eb3135234d91805cec40729214a15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#ab58eb3135234d91805cec40729214a15">Assign</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;x)</td></tr>
<tr class="memdesc:ab58eb3135234d91805cec40729214a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assigns <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Does type conversions, if required.  <a href="#ab58eb3135234d91805cec40729214a15">More...</a><br /></td></tr>
<tr class="separator:ab58eb3135234d91805cec40729214a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a1c5e88dd8bf377d2493318521c0a54d6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_system_1_1_object.html">Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a1c5e88dd8bf377d2493318521c0a54d6">ReleaseSharedAndGetObjectToDelete</a> (<a class="el" href="class_system_1_1_smart_ptr.html#a589a37b44d605011f86db234679f9742">SharedRefReleaser</a> *releaser)</td></tr>
<tr class="memdesc:a1c5e88dd8bf377d2493318521c0a54d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes shared pointer of a specific object, possibly deleting it.  <a href="#a1c5e88dd8bf377d2493318521c0a54d6">More...</a><br /></td></tr>
<tr class="separator:a1c5e88dd8bf377d2493318521c0a54d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd218029a40f5d966362aa9a3f8d165b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#acd218029a40f5d966362aa9a3f8d165b">ReleaseWeak</a> (System::Detail::SmartPtrCounter *counter)</td></tr>
<tr class="memdesc:acd218029a40f5d966362aa9a3f8d165b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decrements weak pointer counter.  <a href="#acd218029a40f5d966362aa9a3f8d165b">More...</a><br /></td></tr>
<tr class="separator:acd218029a40f5d966362aa9a3f8d165b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d05aa584e2ec96aba3cb4ca5ba87db"><td class="memTemplParams" colspan="2">template&lt;typename X , typename Y &gt; </td></tr>
<tr class="memitem:a51d05aa584e2ec96aba3cb4ca5ba87db"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a51d05aa584e2ec96aba3cb4ca5ba87db">InitArray</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; X &gt;&gt; *ptr, const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; Y &gt;&gt; &amp;src)</td></tr>
<tr class="memdesc:a51d05aa584e2ec96aba3cb4ca5ba87db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs actual array copying on cast constructor calls.  <a href="#a51d05aa584e2ec96aba3cb4ca5ba87db">More...</a><br /></td></tr>
<tr class="separator:a51d05aa584e2ec96aba3cb4ca5ba87db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a373c9f5a4878f1580597285f4a983540"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_system_1_1_smart_ptr_1_1_data.html">System::SmartPtr::Data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html#a373c9f5a4878f1580597285f4a983540">m_data</a></td></tr>
<tr class="memdesc:a373c9f5a4878f1580597285f4a983540"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of <a class="el" href="class_system_1_1_smart_ptr_1_1_data.html" title="Internal data storage class which hides data members and enforces neccessary asserts around them...">Data</a> class.  <a href="#a373c9f5a4878f1580597285f4a983540">More...</a><br /></td></tr>
<tr class="separator:a373c9f5a4878f1580597285f4a983540"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class System::SmartPtr&lt; T &gt;</h3>

<p>Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. This pointer type follows intrusive pointer semantics. Reference counter is stored either in <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> itself or in counter structure which is tied to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> instance tightly. In any case, all <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> instances form single ownership group regardless how they were created which is unlike how std::shared_ptr class behaves. Converting raw pointer to <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> is safe given there are other <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> instances holding shared references to the same object. <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class instance can be in one of two states: shared pointer and weak pointer. To keep object alive, one should have count of shared references to it positive. Both weak and shared pointers can be used to access pointed object (to call methods, read or write fields, etc.), but weak pointers do not participate to shared pointer reference counting. <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> is being deleted when the last 'shared' <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointer to it is being destroyed. So, make sure that this doesn't happen when no other shared <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointers to object exist, e. g. during object construction or destruction. Use System::Object::ThisProtector sentry objects (in C++ code) or CppCTORSelfReference or CppSelfReference attribute (in C# code being ported) to fix this issue. Similarily, make sure to break loop references by using <a class="el" href="class_system_1_1_weak_ptr.html" title="Subclass of System::SmartPtr which sets itself to weak mode at construction. Please note that this cl...">System::WeakPtr</a> pointer class or <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45a7324e3727807d95037eb19d304fd91ec" title="Weak mode: pointer does not participate in reference counting. ">System::SmartPtrMode::Weak</a> pointer mode (in C++ code) or CppWeakPtr attribute (in C# code being ported). If two or more objects reference each other using 'shared' pointers, they will never be deleted. If pointer type (weak or shared) should be switched in runtime, use <a class="el" href="class_system_1_1_smart_ptr.html#a385f3f04c1c03af17ba1488e6610756f" title="Sets pointer mode. May alter referenced object&#39;s reference counts. ">System::SmartPtr&lt;T&gt;::set_Mode()</a> method or <a class="el" href="class_system_1_1_dynamic_weak_ptr.html" title="Smart pointer class which tracks pointer modes of template arguments of stored object and updates the...">System::DynamicWeakPtr</a> class. <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class doesn't contain any virtual methods. You should only inherit it if you're creating a memory management strategy of your own. This type is a pointer to manage other object's deletion. It should be allocated on stack and passed to functions either by value or by const reference. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the pointed object. Must be either <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">System::Object</a> or subclass of it. <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;system/object.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;system/smart_ptr.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// The forward declaration of ChildNode.</span></div><div class="line"><span class="keyword">class </span>ChildNode;</div><div class="line"></div><div class="line"><span class="comment">// This class contains SharedPtr to the ChildNode-class instance.</span></div><div class="line"><span class="keyword">class </span>ParentNode: <span class="keyword">public</span> <a class="code" href="class_system_1_1_object.html">System::Object</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="class_system_1_1_smart_ptr.html">System::SharedPtr&lt;ChildNode&gt;</a> childNode;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// This class stores an int32_t value and contains WeakPtr to the ParentNode-class instance to exclude circular</span></div><div class="line"><span class="comment">// dependencies.</span></div><div class="line"><span class="keyword">class </span>ChildNode: <span class="keyword">public</span> <a class="code" href="class_system_1_1_object.html">System::Object</a></div><div class="line">{</div><div class="line">  int32_t m_value;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <a class="code" href="class_system_1_1_weak_ptr.html">System::WeakPtr&lt;ParentNode&gt;</a> parentNode;</div><div class="line"></div><div class="line">  <span class="keyword">explicit</span> ChildNode(int32_t value) : m_value(value) {}</div><div class="line"></div><div class="line">  int32_t getValue()<span class="keyword"> const</span></div><div class="line"><span class="keyword">  </span>{</div><div class="line">    <span class="keywordflow">return</span> m_value;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// The function constructs instances and creates dependencies between instances of the ParentNode and ChildNode classes.</span></div><div class="line"><a class="code" href="class_system_1_1_smart_ptr.html">System::SharedPtr&lt;ParentNode&gt;</a> getParenNode()</div><div class="line">{</div><div class="line">  <span class="keyword">auto</span> parent = System::MakeObject&lt;ParentNode&gt;();</div><div class="line">  <span class="keyword">auto</span> child = System::MakeObject&lt;ChildNode&gt;(16);</div><div class="line"></div><div class="line">  parent-&gt;childNode = child;</div><div class="line">  child-&gt;parentNode = parent;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> parent;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// This function prints information about instances.</span></div><div class="line"><span class="keywordtype">void</span> PrintInfo(<a class="code" href="class_system_1_1_weak_ptr.html">System::WeakPtr&lt;ChildNode&gt;</a> &amp;childNode)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The pointer to an instance of the ChildNode class has expired: &quot;</span> &lt;&lt; (childNode.<a class="code" href="class_system_1_1_weak_ptr.html#ad204453849f6a92dd441c4ef95175616">expired</a>() ? <span class="stringliteral">&quot;True&quot;</span> : <span class="stringliteral">&quot;False&quot;</span>) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (!childNode.<a class="code" href="class_system_1_1_weak_ptr.html#ad204453849f6a92dd441c4ef95175616">expired</a>())</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Stored value: &quot;</span> &lt;&lt; childNode-&gt;getValue() &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;The pointer to a parent node has expired: &quot;</span> &lt;&lt; (childNode-&gt;parentNode.<a class="code" href="class_system_1_1_weak_ptr.html#ad204453849f6a92dd441c4ef95175616">expired</a>() ? <span class="stringliteral">&quot;True&quot;</span> : <span class="stringliteral">&quot;False&quot;</span>) &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <a class="code" href="class_system_1_1_weak_ptr.html">System::WeakPtr&lt;ChildNode&gt;</a> child;</div><div class="line"></div><div class="line">  {</div><div class="line">    <span class="keyword">auto</span> parent = getParenNode();</div><div class="line">    child = parent-&gt;childNode;</div><div class="line">    PrintInfo(child);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;------&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line"></div><div class="line">  PrintInfo(child);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">This code example produces the following output:</span></div><div class="line"><span class="comment">The pointer to an instance of the ChildNode class has expired: False</span></div><div class="line"><span class="comment">Stored value: 16</span></div><div class="line"><span class="comment">The pointer to a parent node has expired: False</span></div><div class="line"><span class="comment">------</span></div><div class="line"><span class="comment">The pointer to an instance of the ChildNode class has expired: True</span></div><div class="line"><span class="comment">*/</span></div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8ecc0b987116c3c26399a869bc3f8e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecc0b987116c3c26399a869bc3f8e4b">&#9670;&nbsp;</a></span>ArrayType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef System::Details::ArrayTypeResolver&lt;T&gt;::type <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html#a8ecc0b987116c3c26399a869bc3f8e4b">ArrayType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as Pointee_, if it is a specialization of <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">System::Array</a>, and void otherwise. </p>

</div>
</div>
<a id="ae5fa4ef8254b0633e5e7c72aea89a8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fa4ef8254b0633e5e7c72aea89a8b7">&#9670;&nbsp;</a></span>Pointee_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pointed type. </p>

</div>
</div>
<a id="a589a37b44d605011f86db234679f9742"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589a37b44d605011f86db234679f9742">&#9670;&nbsp;</a></span>SharedRefReleaser</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_system_1_1_object.html">Object</a> <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html#a589a37b44d605011f86db234679f9742">SharedRefReleaser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Type to use to release shared pointers. Depends on whether external refcount is on or off. </p>

</div>
</div>
<a id="a17e11d1bcc30087b34a421716673fc24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e11d1bcc30087b34a421716673fc24">&#9670;&nbsp;</a></span>SmartPtr_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;T&gt; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialized smart pointer type. </p>

</div>
</div>
<a id="a3bd6d9ab409a697ea43c37b437a2c0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd6d9ab409a697ea43c37b437a2c0a9">&#9670;&nbsp;</a></span>ValueType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html#a3bd6d9ab409a697ea43c37b437a2c0a9">ValueType</a> =  typename System::Details::SelectType&lt;typename System::Details::ArrayTypeResolver&lt;T&gt;::value_type&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Storage type of pointed array. Only meaningful if T is a specialization of <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">System::Array</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a33d8fda4db8d2775b2582c1e95df3b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d8fda4db8d2775b2582c1e95df3b14">&#9670;&nbsp;</a></span>SmartPtr() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object of required mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Pointer mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2233902636b1e8f57f0841920f6dab10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2233902636b1e8f57f0841920f6dab10">&#9670;&nbsp;</a></span>SmartPtr() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates null-pointer <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object of required mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>Pointer mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d867b542a1b23498794922d3771c2fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d867b542a1b23498794922d3771c2fb">&#9670;&nbsp;</a></span>SmartPtr() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointing to specified object, or converts raw pointer to <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td>Pointee. </td></tr>
    <tr><td class="paramname">mode</td><td>Pointer mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7c95c3d30a9129908da48b9cc1f10e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c95c3d30a9129908da48b9cc1f10e2">&#9670;&nbsp;</a></span>SmartPtr() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Both pointers point to the same object afterwards. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to copy. </td></tr>
    <tr><td class="paramname">mode</td><td>Pointer mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49897bcf9e2d8b6a4a9ae17dcc68de81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49897bcf9e2d8b6a4a9ae17dcc68de81">&#9670;&nbsp;</a></span>SmartPtr() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Q , typename  = typename std::enable_if&lt;System::detail::is_pointer_convertible&lt;Q, Pointee_&gt;::type::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructs <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Both pointers point to the same object afterwards. Performs type conversion if allowed. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>Type of object pointed by x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to copy. </td></tr>
    <tr><td class="paramname">mode</td><td>Pointer mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa4b0a88d3d08332e399ed45de4f078cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b0a88d3d08332e399ed45de4f078cf">&#9670;&nbsp;</a></span>SmartPtr() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructs <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Effectively, swaps two pointers, if they are both of same mode. x may be unusable after call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to move. </td></tr>
    <tr><td class="paramname">mode</td><td>Pointer mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30f8bd76b9a4d2bb7181c3ca86bf5d1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f8bd76b9a4d2bb7181c3ca86bf5d1d">&#9670;&nbsp;</a></span>SmartPtr() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; Y &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts type of referenced array by creating a new array of different type. Useful if in C# there is an array type cast which is unsupported in C++. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of source array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Pointer to array to create a copy of, but with different type of elements. </td></tr>
    <tr><td class="paramname">mode</td><td>Pointer mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4148ee591bf6cf4accb1f033e5f38b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4148ee591bf6cf4accb1f033e5f38b6e">&#9670;&nbsp;</a></span>SmartPtr() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Y , typename  = typename std::enable_if&lt;std::is_same&lt;Y, EmptyArrayInitializer&gt;::value, void&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const Y &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes empty array. Used to port some C# code constructs. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Placeholder of <a class="el" href="struct_system_1_1_empty_array_initializer.html">EmptyArrayInitializer</a> type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a121c4f3d4560def4734439f86c47626f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121c4f3d4560def4734439f86c47626f">&#9670;&nbsp;</a></span>SmartPtr() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; P &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> which shares ownership information with the initial value of ptr, but holds an unrelated and unmanaged pointer p. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Another smart pointer to share the ownership to the ownership from. </td></tr>
    <tr><td class="paramname">p</td><td>Pointer to an object to manage. </td></tr>
    <tr><td class="paramname">mode</td><td>Pointer mode. <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;system/object.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;system/smart_ptr.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// This class contains a field that will be printed.</span></div><div class="line"><span class="keyword">class </span>Foo : <span class="keyword">public</span> <a class="code" href="class_system_1_1_object.html">System::Object</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  std::string value = <span class="stringliteral">&quot;Hello, world!&quot;</span>;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// This class contains an instance of the Foo class.</span></div><div class="line"><span class="keyword">class </span>Bar : <span class="keyword">public</span> <a class="code" href="class_system_1_1_object.html">System::Object</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  Foo data;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Used to print a string from the Foo-class instance.</span></div><div class="line"><span class="keywordtype">void</span> PrintMessage(<span class="keyword">const</span> <a class="code" href="class_system_1_1_smart_ptr.html">System::SharedPtr&lt;Foo&gt;</a> &amp;foo)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; foo-&gt;value &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Prints the number of shared pointers pointing to the object.</span></div><div class="line"><span class="keywordtype">void</span> PrintSharedCount(<span class="keyword">const</span> <a class="code" href="class_system_1_1_smart_ptr.html">System::SharedPtr&lt;Bar&gt;</a> &amp;ptr)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of shared pointers: &quot;</span> &lt;&lt; ptr.<a class="code" href="class_system_1_1_smart_ptr.html#a978b5e81c223dd2d9cc0b9b92b4544a8">get_shared_count</a>() &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Create SharedPtr to an instance of the Bar class.</span></div><div class="line">  <span class="keyword">auto</span> bar = System::MakeObject&lt;Bar&gt;();</div><div class="line">  PrintSharedCount(bar);</div><div class="line">  <span class="comment">// Create SharedPtr that will point to the field of the Bar-class instance.</span></div><div class="line">  <span class="keyword">auto</span> foo = <a class="code" href="class_system_1_1_smart_ptr.html">System::SharedPtr&lt;Foo&gt;</a>(bar, &amp;bar-&gt;data);</div><div class="line">  PrintSharedCount(bar);</div><div class="line"></div><div class="line">  <span class="comment">// Make the &#39;bar&#39; pointer pointing to nullptr.</span></div><div class="line">  bar.<a class="code" href="class_system_1_1_smart_ptr.html#a95aa8d542947f56f9437f144af2dbfef">reset</a>();</div><div class="line">  PrintSharedCount(bar);</div><div class="line">  <span class="comment">// bar-&gt;data still exists and the &#39;foo&#39; pointer is valid.</span></div><div class="line">  PrintMessage(foo);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">This code example produces the following output:</span></div><div class="line"><span class="comment">Number of shared pointers: 1</span></div><div class="line"><span class="comment">Number of shared pointers: 2</span></div><div class="line"><span class="comment">Number of shared pointers: 0</span></div><div class="line"><span class="comment">Hello, world!</span></div><div class="line"><span class="comment">*/</span></div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6e9ecbd0ae8a75e0f8b2f0f3090b8b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9ecbd0ae8a75e0f8b2f0f3090b8b5e">&#9670;&nbsp;</a></span>~SmartPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::~<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. If required, decreases pointed object's reference counter and deletes object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab58eb3135234d91805cec40729214a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab58eb3135234d91805cec40729214a15">&#9670;&nbsp;</a></span>Assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::Assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assigns <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Does type conversions, if required. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>Type of object pointed by x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to copy-assign. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa40e41a74ffc04d7881e449bd02ec862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40e41a74ffc04d7881e449bd02ec862">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;Q&gt;().begin())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#aa40e41a74ffc04d7881e449bd02ec862" title="Accessor for begin() method of an underling collection. Only compiles if SmartPtr_ is specialization ...">begin()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#aa40e41a74ffc04d7881e449bd02ec862" title="Accessor for begin() method of an underling collection. Only compiles if SmartPtr_ is specialization ...">begin()</a> method. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the begin of collection </dd></dl>

</div>
</div>
<a id="a02eed15dc0f5a13cf5493ba33b44774c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02eed15dc0f5a13cf5493ba33b44774c">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const Q&gt;().begin())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#aa40e41a74ffc04d7881e449bd02ec862" title="Accessor for begin() method of an underling collection. Only compiles if SmartPtr_ is specialization ...">begin()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#aa40e41a74ffc04d7881e449bd02ec862" title="Accessor for begin() method of an underling collection. Only compiles if SmartPtr_ is specialization ...">begin()</a> method. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the begin of collection </dd></dl>

</div>
</div>
<a id="acadea97557340ffa13ff6996eae24ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acadea97557340ffa13ff6996eae24ed8">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const Q&gt;().cbegin())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#acadea97557340ffa13ff6996eae24ed8" title="Accessor for cbegin() method of an underling collection. Only compiles if SmartPtr_ is specialization...">cbegin()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#acadea97557340ffa13ff6996eae24ed8" title="Accessor for cbegin() method of an underling collection. Only compiles if SmartPtr_ is specialization...">cbegin()</a> method. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the begin of collection </dd></dl>

</div>
</div>
<a id="a949ade5ac2636ccf3073dd71be937b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a949ade5ac2636ccf3073dd71be937b5b">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const Q&gt;().cend())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#a949ade5ac2636ccf3073dd71be937b5b" title="Accessor for cend() method of an underling collection. Only compiles if SmartPtr_ is specialization t...">cend()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#a949ade5ac2636ccf3073dd71be937b5b" title="Accessor for cend() method of an underling collection. Only compiles if SmartPtr_ is specialization t...">cend()</a> method. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the end of collection </dd></dl>

</div>
</div>
<a id="a795c9af8d7225a8ec66d27fa38e3938c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795c9af8d7225a8ec66d27fa38e3938c">&#9670;&nbsp;</a></span>const_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;Y&gt; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::const_pointer_cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts pointer to different type using const_cast on pointed object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Target type of pointed object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer of changed type which is always in shared mode. </dd></dl>

</div>
</div>
<a id="ab00aac4fd85b6626b59a4e5e292504ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00aac4fd85b6626b59a4e5e292504ae">&#9670;&nbsp;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;Y&gt; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts pointer to different type using dynamic_cast on pointed object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Target type of pointed object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer of changed type which is always in shared mode. </dd></dl>

</div>
</div>
<a id="a585eca7a81ec7d16239f6c1988770d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585eca7a81ec7d16239f6c1988770d4f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;Q&gt;().end())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#a585eca7a81ec7d16239f6c1988770d4f" title="Accessor for end() method of an underling collection. Only compiles if SmartPtr_ is specialization ty...">end()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#a585eca7a81ec7d16239f6c1988770d4f" title="Accessor for end() method of an underling collection. Only compiles if SmartPtr_ is specialization ty...">end()</a> method. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the end of collection </dd></dl>

</div>
</div>
<a id="aa3d99a4c6d427503c95641d932747af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d99a4c6d427503c95641d932747af4">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const -&gt; decltype(std::declval&lt;const Q&gt;().end())
    </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for <a class="el" href="class_system_1_1_smart_ptr.html#a585eca7a81ec7d16239f6c1988770d4f" title="Accessor for end() method of an underling collection. Only compiles if SmartPtr_ is specialization ty...">end()</a> method of an underling collection. Only compiles if SmartPtr_ is specialization type with <a class="el" href="class_system_1_1_smart_ptr.html#a585eca7a81ec7d16239f6c1988770d4f" title="Accessor for end() method of an underling collection. Only compiles if SmartPtr_ is specialization ty...">end()</a> method. </p>
<dl class="section return"><dt>Returns</dt><dd>iterator to the end of collection </dd></dl>

</div>
</div>
<a id="a89ca299886b9c92177ff371b3f2b2240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ca299886b9c92177ff371b3f2b2240">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a>* <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets pointed object. </p>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to referenced object. </dd></dl>

</div>
</div>
<a id="aa92876859dfb3fa431d1e67149fe9e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa92876859dfb3fa431d1e67149fe9e0f">&#9670;&nbsp;</a></span>get_Mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::get_Mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets pointer mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Mode of pointer object. </dd></dl>

</div>
</div>
<a id="a173213a7a16c0b0d6f1f55c5f6f68f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173213a7a16c0b0d6f1f55c5f6f68f9b">&#9670;&nbsp;</a></span>get_shared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a>* <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::get_shared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets pointed object, but asserts that pointer is in shared mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to referenced object. </dd></dl>

</div>
</div>
<a id="a978b5e81c223dd2d9cc0b9b92b4544a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978b5e81c223dd2d9cc0b9b92b4544a8">&#9670;&nbsp;</a></span>get_shared_count()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::get_shared_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets number of shared pointers existing to referenced object, including current one. Asserts current pointer being in shared mode. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of shared pointers existing to referenced object, if any. If pointer is null, returns 0. </dd></dl>

</div>
</div>
<a id="a00dd28a9a6cff88272a3cf0f98beefdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00dd28a9a6cff88272a3cf0f98beefdc">&#9670;&nbsp;</a></span>GetHashCode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::GetHashCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="class_system_1_1_smart_ptr.html#a00dd28a9a6cff88272a3cf0f98beefdc" title="Calls GetHashCode() on pointed object. ">GetHashCode()</a> on pointed object. </p>
<dl class="section return"><dt>Returns</dt><dd>Result of <a class="el" href="class_system_1_1_smart_ptr.html#a00dd28a9a6cff88272a3cf0f98beefdc" title="Calls GetHashCode() on pointed object. ">GetHashCode()</a> call on referenced object (if any) or 0. </dd></dl>

</div>
</div>
<a id="afd525096f933cbd94a807d32344333ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd525096f933cbd94a807d32344333ec">&#9670;&nbsp;</a></span>GetHashCodeImpl() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q , typename R  = decltype(std::declval&lt;Q*&gt;()-&gt;GetHashCode())&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::GetHashCodeImpl </td>
          <td>(</td>
          <td class="paramtype">Q *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls into <a class="el" href="class_system_1_1_smart_ptr.html#a00dd28a9a6cff88272a3cf0f98beefdc" title="Calls GetHashCode() on pointed object. ">GetHashCode()</a> method if it is available on Pointee_ type (which is true if it is a complete type). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>Same as Pointee_, needed for template magic here. </td></tr>
    <tr><td class="paramname">R</td><td>Result of <a class="el" href="class_system_1_1_smart_ptr.html#a00dd28a9a6cff88272a3cf0f98beefdc" title="Calls GetHashCode() on pointed object. ">GetHashCode()</a> call, should be int. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa69caf8f25f5602a5afc2af6d2221525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69caf8f25f5602a5afc2af6d2221525">&#9670;&nbsp;</a></span>GetHashCodeImpl() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::GetHashCodeImpl </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls <a class="el" href="class_system_1_1_smart_ptr.html#a00dd28a9a6cff88272a3cf0f98beefdc" title="Calls GetHashCode() on pointed object. ">GetHashCode()</a> method from <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> if it is not available on Pointee_ type (e. g. if it is incomplete). </p>

</div>
</div>
<a id="a32985dae73c069674e7e36368ba562c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32985dae73c069674e7e36368ba562c7">&#9670;&nbsp;</a></span>GetObjectNotNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::GetObjectNotNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets currently referenced object (if any) or throws. </p>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to referenced object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System::NullReferenceException</td><td>Thrown if called on null-pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad071a0bdeeeefe7b7af879de7d33c9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad071a0bdeeeefe7b7af879de7d33c9c9">&#9670;&nbsp;</a></span>GetObjectOrNull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_object.html">Object</a>* <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::GetObjectOrNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets pointed object (if any) or nullptr. Same as <a class="el" href="class_system_1_1_smart_ptr.html#a89ca299886b9c92177ff371b3f2b2240" title="Gets pointed object. ">get()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to referenced object (if any) or nullptr. </dd></dl>

</div>
</div>
<a id="ad9005a9200f464e90c188bbf26f1f0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9005a9200f464e90c188bbf26f1f0be">&#9670;&nbsp;</a></span>GetPointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a>* <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::GetPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets pointed object (if any) or nullptr. Same as <a class="el" href="class_system_1_1_smart_ptr.html#a89ca299886b9c92177ff371b3f2b2240" title="Gets pointed object. ">get()</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to referenced object (if any) or nullptr. </dd></dl>

</div>
</div>
<a id="aee8ce7201566a90b7e9c738d4cd12fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8ce7201566a90b7e9c738d4cd12fff">&#9670;&nbsp;</a></span>GetSharedReleaser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#a589a37b44d605011f86db234679f9742">SharedRefReleaser</a>* <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::GetSharedReleaser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets object to use to release shared pointer to. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to owned object. </dd></dl>

</div>
</div>
<a id="a51d05aa584e2ec96aba3cb4ca5ba87db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d05aa584e2ec96aba3cb4ca5ba87db">&#9670;&nbsp;</a></span>InitArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename X , typename Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::InitArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; X &gt;&gt; *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; Y &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs actual array copying on cast constructor calls. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Target array element type. </td></tr>
    <tr><td class="paramname">Y</td><td>Source array element type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Target array pointer. </td></tr>
    <tr><td class="paramname">src</td><td>Source array pointer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c5347a40d958c3c8569c4d319cee961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5347a40d958c3c8569c4d319cee961">&#9670;&nbsp;</a></span>Is()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if pointed object is of specific type or its child type. Follows C# 'is' semantics. </p>
<p>Implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">target</td><td>Specifies target type to check against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if C# 'is'-style check is positive and false otherwise. </dd></dl>

</div>
</div>
<a id="acb146194629f48ed9b73c00dcaa25871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb146194629f48ed9b73c00dcaa25871">&#9670;&nbsp;</a></span>IsAliasingPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::IsAliasingPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if pointer is pointed to another object than owned (created by an aliasing constructor). </p>
<dl class="section return"><dt>Returns</dt><dd>True if pointer has a difference in pointed and owned objects, false otherwise. </dd></dl>

</div>
</div>
<a id="a56f9848b9f2a4d43d113c20f7d809461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f9848b9f2a4d43d113c20f7d809461">&#9670;&nbsp;</a></span>IsShared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::IsShared </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if pointer is in shared mode. </p>
<dl class="section return"><dt>Returns</dt><dd>True if pointer is in shared mode, false otherwise. </dd></dl>

</div>
</div>
<a id="a76ae11690e04c0ca8c91af774fc21d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ae11690e04c0ca8c91af774fc21d9e">&#9670;&nbsp;</a></span>IsWeak()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::IsWeak </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if pointer is in weak mode. </p>
<dl class="section return"><dt>Returns</dt><dd>True if pointer is in weak mode, false otherwise. </dd></dl>

</div>
</div>
<a id="a4ddf2525f32d5338e911ec0d3bc1b037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddf2525f32d5338e911ec0d3bc1b037">&#9670;&nbsp;</a></span>Lock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::Lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pointee object. Increments shared or weak reference count, depending on pointer mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">object</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87d165e8054c5cdaf10d8668a73da60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87d165e8054c5cdaf10d8668a73da60d">&#9670;&nbsp;</a></span>Lock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::Lock </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pointee object. Increments shared or weak reference count, depending on pointer mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>Source object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a027a1056b8d0c6e9ace66505b7ea8b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027a1056b8d0c6e9ace66505b7ea8b43">&#9670;&nbsp;</a></span>LockSharedFromShared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::LockSharedFromShared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pointee object. Asserts that both current object and ptr are in shared mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>Source object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4edce4ef76508fc370e331f94764519e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edce4ef76508fc370e331f94764519e">&#9670;&nbsp;</a></span>LockSharedFromWeak()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::LockSharedFromWeak </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pointee object. Asserts that current object is in shared mode and ptr is in weak mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>Source object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac453356c08003795d0184130e4370884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac453356c08003795d0184130e4370884">&#9670;&nbsp;</a></span>LockWeakFromShared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::LockWeakFromShared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pointee object. Asserts that current object is in weak mode and ptr is in shared mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>Source object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af10d24eb3d99e4e3e64b8c7e8ef1b7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10d24eb3d99e4e3e64b8c7e8ef1b7e8">&#9670;&nbsp;</a></span>LockWeakFromWeak()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::LockWeakFromWeak </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pointee object. Asserts that both current object and ptr are in weak mode. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>Source object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to object to lock. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1cd8800596928f8e2cfdc0eb2013746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cd8800596928f8e2cfdc0eb2013746">&#9670;&nbsp;</a></span>MoveSharedFromWeak()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::MoveSharedFromWeak </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements move semantics. Asserts that current object is in shared mode and x is in weak mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to move value from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a832f9561657fc1eb7cb1306d323d00ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832f9561657fc1eb7cb1306d323d00ec">&#9670;&nbsp;</a></span>MoveWeakFromShared()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::MoveWeakFromShared </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements move semantics. Asserts that current object is in weak mode and x is in shared mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to move value from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bbc4396d2b1370661e7012dda41f634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbc4396d2b1370661e7012dda41f634">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if pointer is not null. </p>
<dl class="section return"><dt>Returns</dt><dd>False if pointer is null, true otherwise. </dd></dl>

</div>
</div>
<a id="af5fe0a1b3e5df4d79ed7a049af785fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5fe0a1b3e5df4d79ed7a049af785fcb">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if pointer is null. </p>
<dl class="section return"><dt>Returns</dt><dd>True if pointer is null, false otherwise. </dd></dl>

</div>
</div>
<a id="a178dc1f2002d8bed885957faddb5abce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178dc1f2002d8bed885957faddb5abce">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a>&amp; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets reference to pointed object. Asserts that pointer is not null. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to pointed object. </dd></dl>

</div>
</div>
<a id="a6c7e6a1459f68db229aad33a1794a598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c7e6a1459f68db229aad33a1794a598">&#9670;&nbsp;</a></span>operator->()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a>* <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allows to access members of referenced object. </p>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to referenced object. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">System::NullReferenceException</td><td>If pointer is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa517c819d174bc84a3fbf12bda848775"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa517c819d174bc84a3fbf12bda848775">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">Y *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides less-compare semantics for <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of pointer to compare current one to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer to compare current one to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the object referenced by <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> is 'less' than p and false otherwise. </dd></dl>

</div>
</div>
<a id="ae5bcc5c6335da82f0d896a3c74ce8d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bcc5c6335da82f0d896a3c74ce8d7c">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides less-compare semantics for <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Type of pointer to compare current one to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to compare current one to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the object referenced by <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> is 'less' than x and false otherwise. </dd></dl>

</div>
</div>
<a id="a2e9b6a69857b328e11189e4c0d048838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e9b6a69857b328e11189e4c0d048838">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a>&amp; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move-assigns <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. x becomes unusable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to move-assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this object. </dd></dl>

</div>
</div>
<a id="a26e679a8b76c64a4fc65dc2c82e1388f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e679a8b76c64a4fc65dc2c82e1388f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a>&amp; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assigns <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to copy-assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this object. </dd></dl>

</div>
</div>
<a id="a298afbc403cec691d95f9a472dd82312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298afbc403cec691d95f9a472dd82312">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename Q &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a>&amp; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Q &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy-assigns <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. Does required type conversions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>Type of object pointed by x. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to copy-assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this object. </dd></dl>

</div>
</div>
<a id="a812c0239d6626c46b48a88ce836520b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812c0239d6626c46b48a88ce836520b1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a>&amp; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assigns raw pointer to <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Pointer value to assign. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this object. </dd></dl>

</div>
</div>
<a id="ad01d5a86f8a9c8c7adedcf5367298b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01d5a86f8a9c8c7adedcf5367298b8f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a>&amp; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pointer value to nullptr. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to this object. </dd></dl>

</div>
</div>
<a id="a1c88e79d275eeb8573cb7b2fb0908464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c88e79d275eeb8573cb7b2fb0908464">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if pointer points to nullptr. </p>
<dl class="section return"><dt>Returns</dt><dd>True if pointer points to nullptr and false otherwise. </dd></dl>

</div>
</div>
<a id="afbafb7ca2ad65ea55d4cc1928002db01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbafb7ca2ad65ea55d4cc1928002db01">&#9670;&nbsp;</a></span>ReleaseAndGetObjectToDelete()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_object.html">Object</a>* <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::ReleaseAndGetObjectToDelete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements currently referenced object's shared or weak pointer counter, depending on current pointer mode. </p>

</div>
</div>
<a id="a1c5e88dd8bf377d2493318521c0a54d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5e88dd8bf377d2493318521c0a54d6">&#9670;&nbsp;</a></span>ReleaseSharedAndGetObjectToDelete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_object.html">Object</a> * <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::ReleaseSharedAndGetObjectToDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html#a589a37b44d605011f86db234679f9742">SharedRefReleaser</a> *&#160;</td>
          <td class="paramname"><em>releaser</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes shared pointer of a specific object, possibly deleting it. </p>
<p>Implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">releaser</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to release. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e8edea637363fcfdae7895292fd3b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8edea637363fcfdae7895292fd3b67">&#9670;&nbsp;</a></span>ReleaseSharedAndGetObjectToDelete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_object.html">Object</a>* <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::ReleaseSharedAndGetObjectToDelete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements currently referenced object's shared pointer counter. </p>

</div>
</div>
<a id="acd218029a40f5d966362aa9a3f8d165b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd218029a40f5d966362aa9a3f8d165b">&#9670;&nbsp;</a></span>ReleaseWeak() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::ReleaseWeak </td>
          <td>(</td>
          <td class="paramtype">System::Detail::SmartPtrCounter *&#160;</td>
          <td class="paramname"><em>counter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements weak pointer counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">counter</td><td>Counter to decrement. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2fbc398c7a2a917efb9e11a1e50efed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc398c7a2a917efb9e11a1e50efed4">&#9670;&nbsp;</a></span>ReleaseWeak() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::ReleaseWeak </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decrements currently referenced object's weak pointer counter. </p>

</div>
</div>
<a id="a7d4706d9e3df03bfba5e8522b484629d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4706d9e3df03bfba5e8522b484629d">&#9670;&nbsp;</a></span>RemoveAliasing()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a> <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::RemoveAliasing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes aliasing (created by an aliasing constructor) from pointer, makes sure it manages (if shared) or tracks (if weak) the same object it points to. </p>
<dl class="section return"><dt>Returns</dt><dd>The pointer to the same object this pointer points to which looks after the lifetime of the same object. </dd></dl>

</div>
</div>
<a id="a95aa8d542947f56f9437f144af2dbfef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95aa8d542947f56f9437f144af2dbfef">&#9670;&nbsp;</a></span>reset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html#ae5fa4ef8254b0633e5e7c72aea89a8b7">Pointee_</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pointed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Raw pointer to new referenced object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c0d2cf3905a511a44cd390ac130d4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c0d2cf3905a511a44cd390ac130d4c7">&#9670;&nbsp;</a></span>reset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes pointer pointing to nullptr. </p>

</div>
</div>
<a id="a385f3f04c1c03af17ba1488e6610756f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a385f3f04c1c03af17ba1488e6610756f">&#9670;&nbsp;</a></span>set_Mode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::set_Mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets pointer mode. May alter referenced object's reference counts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>New mode of pointer. <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;system/smart_ptr.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span><a class="code" href="namespace_system_1_1_xml_1_1_schema.html#ac728d2cc5b09a5956f8da14930af590ea7d74f3b92b19da5e606d737d339a9679">Item</a> final : <span class="keyword">public</span> <a class="code" href="class_system_1_1_object.html">System::Object</a></div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  ~<a class="code" href="namespace_system_1_1_xml_1_1_schema.html#ac728d2cc5b09a5956f8da14930af590ea7d74f3b92b19da5e606d737d339a9679">Item</a>() final</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;~Item()&quot;</span> &lt;&lt; std::endl;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">using</span> ItemPtr = <a class="code" href="class_system_1_1_smart_ptr.html">System::SmartPtr&lt;Item&gt;</a>;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> PrintSharedCount(ItemPtr &amp;ptr)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Number of shared pointers: &quot;</span> &lt;&lt; ptr.<a class="code" href="class_system_1_1_smart_ptr.html#a978b5e81c223dd2d9cc0b9b92b4544a8">get_shared_count</a>() &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> ChangeModeToWeak(ItemPtr &amp;ptr)</div><div class="line">{</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The mode will be changed to System::SmartPtrMode::Weak&quot;</span> &lt;&lt; std::endl;</div><div class="line">  ptr.set_Mode(<a class="code" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45a7324e3727807d95037eb19d304fd91ec">System::SmartPtrMode::Weak</a>);</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;The mode has been changed to System::SmartPtrMode::Weak&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  ItemPtr ptr1 = System::MakeObject&lt;Item&gt;();</div><div class="line">  ItemPtr ptr2{ptr1, <a class="code" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45a7324e3727807d95037eb19d304fd91ec">System::SmartPtrMode::Weak</a>};</div><div class="line">  PrintSharedCount(ptr1);</div><div class="line"></div><div class="line">  ptr2.set_Mode(<a class="code" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">System::SmartPtrMode::Shared</a>);</div><div class="line">  PrintSharedCount(ptr1);</div><div class="line"></div><div class="line">  ChangeModeToWeak(ptr1);</div><div class="line">  ChangeModeToWeak(ptr2);</div><div class="line">  std::cout &lt;&lt;</div><div class="line">    <span class="stringliteral">&quot;The pointer to an instance of the Item class expired: &quot;</span> &lt;&lt;</div><div class="line">    (<span class="keyword">static_cast&lt;</span><a class="code" href="class_system_1_1_weak_ptr.html">System::WeakPtr&lt;ItemPtr::Pointee_&gt;</a><span class="keyword">&gt;</span>(ptr1).expired() ? <span class="stringliteral">&quot;True&quot;</span> : <span class="stringliteral">&quot;False&quot;</span>) &lt;&lt;</div><div class="line">    std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">This code example produces the following output:</span></div><div class="line"><span class="comment">Number of shared pointers: 1</span></div><div class="line"><span class="comment">Number of shared pointers: 2</span></div><div class="line"><span class="comment">The mode will be changed to System::SmartPtrMode::Weak</span></div><div class="line"><span class="comment">The mode has been changed to System::SmartPtrMode::Weak</span></div><div class="line"><span class="comment">The mode will be changed to System::SmartPtrMode::Weak</span></div><div class="line"><span class="comment">~Item()</span></div><div class="line"><span class="comment">The mode has been changed to System::SmartPtrMode::Weak</span></div><div class="line"><span class="comment">The pointer to an instance of the Item class expired: True</span></div><div class="line"><span class="comment">*/</span></div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a785edb8e734692c89b7e216796d51f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785edb8e734692c89b7e216796d51f60">&#9670;&nbsp;</a></span>SetContainedTemplateWeakPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::SetContainedTemplateWeakPtr </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>argument</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls SetTemplateWeakPtr() method on pointed object (if any). </p>
<p>Implementation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argument</td><td>Argument of SetTemplateWeakPtr method called on referenced object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f80f917ff95b23cf5f6ddd8cb676f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f80f917ff95b23cf5f6ddd8cb676f67">&#9670;&nbsp;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;class Y &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;Y&gt; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::static_pointer_cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Casts pointer to different type using static_cast on pointed object. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Y</td><td>Target type of pointed object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer of changed type which is always in shared mode. </dd></dl>

</div>
</div>
<a id="a22b3e7dbcd96c4c306e88f3a92533789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b3e7dbcd96c4c306e88f3a92533789">&#9670;&nbsp;</a></span>ToObjectPtr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::ToObjectPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts any pointer type to pointer to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Doesn't require Pointee_ type to be complete. </p>
<p>Implementation.</p>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to referenced object (if any) or nullptr. </dd></dl>

</div>
</div>
<a id="a995a1d453658632e43becdb65592f7bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995a1d453658632e43becdb65592f7bf">&#9670;&nbsp;</a></span>Type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp; <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::Type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shortcut to get <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">System::TypeInfo</a> object for the Pointee_ type. </p>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure which describes Pointee_ type. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a373c9f5a4878f1580597285f4a983540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373c9f5a4878f1580597285f4a983540">&#9670;&nbsp;</a></span>m_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_system_1_1_smart_ptr_1_1_data.html">System::SmartPtr::Data</a>
     <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::m_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An instance of <a class="el" href="class_system_1_1_smart_ptr_1_1_data.html" title="Internal data storage class which hides data members and enforces neccessary asserts around them...">Data</a> class. </p>

</div>
</div>
<a id="a714365e177e62944d731d8f84711de20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714365e177e62944d731d8f84711de20">&#9670;&nbsp;</a></span>operator[]</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T&gt; </div>
<div class="memtemplate">
template&lt;typename IdxType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">decltype(System::Details::GetByIndex(std::declval&lt;const <a class="el" href="class_system_1_1_smart_ptr.html#a17e11d1bcc30087b34a421716673fc24">SmartPtr_</a>*&gt;(), std::declval&lt;IdxType&gt;()) <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt;::operator[]) (IdxType idx) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Accessor for array elements. Only compiles if SmartPtr_ is specialization of <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">System::Array</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IdxType</td><td>Type of index (assumed integral). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>Index in array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> value at idx position. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_system.html">System</a></li><li class="navelem"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
