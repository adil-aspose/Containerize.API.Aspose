<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aspose.PDF for C++: System::ObjectExt Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aspose.PDF for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('class_system_1_1_object_ext.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_system_1_1_object_ext-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">System::ObjectExt Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Provides static methods that emulate C# <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> methods called for non-Object C++ types (strings, numbers, etc.). This is a static type with no instance services. You should never create instances of it by any means.  
 <a href="class_system_1_1_object_ext.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5a852245e87101f4b1625180a52dbed6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a5a852245e87101f4b1625180a52dbed6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a5a852245e87101f4b1625180a52dbed6">Equals</a> (const float &amp;obj, const float &amp;another)</td></tr>
<tr class="memdesc:a5a852245e87101f4b1625180a52dbed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulates C#-style floating point comparison where two NaNs are considered equal even though according to IEC 60559:1989 NaN is not equal to any value, including NaN.  <a href="#a5a852245e87101f4b1625180a52dbed6">More...</a><br /></td></tr>
<tr class="separator:a5a852245e87101f4b1625180a52dbed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a95d61c6ae0ceb942a528fec1de24d9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a4a95d61c6ae0ceb942a528fec1de24d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a4a95d61c6ae0ceb942a528fec1de24d9">Equals</a> (const double &amp;obj, const double &amp;another)</td></tr>
<tr class="memdesc:a4a95d61c6ae0ceb942a528fec1de24d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emulates C#-style floating point comparison where two NaNs are considered equal even though according to IEC 60559:1989 NaN is not equal to any value, including NaN.  <a href="#a4a95d61c6ae0ceb942a528fec1de24d9">More...</a><br /></td></tr>
<tr class="separator:a4a95d61c6ae0ceb942a528fec1de24d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab678c616a7ca83827fb013210a20e705"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab678c616a7ca83827fb013210a20e705"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ab678c616a7ca83827fb013210a20e705">Box</a> (const <a class="el" href="class_system_1_1_string.html">String</a> &amp;value)</td></tr>
<tr class="memdesc:ab678c616a7ca83827fb013210a20e705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boxes string values.  <a href="#ab678c616a7ca83827fb013210a20e705">More...</a><br /></td></tr>
<tr class="separator:ab678c616a7ca83827fb013210a20e705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea417154034a572b4f76419047dbad0"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a5ea417154034a572b4f76419047dbad0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_string.html">String</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a5ea417154034a572b4f76419047dbad0">Unbox</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:a5ea417154034a572b4f76419047dbad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unboxes string values.  <a href="#a5ea417154034a572b4f76419047dbad0">More...</a><br /></td></tr>
<tr class="separator:a5ea417154034a572b4f76419047dbad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a8c586e5350ff4a8f80f39714ced2d932">GetType</a> ()</td></tr>
<tr class="memdesc:a8c586e5350ff4a8f80f39714ced2d932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for uint8_t.  <a href="#a8c586e5350ff4a8f80f39714ced2d932">More...</a><br /></td></tr>
<tr class="separator:a8c586e5350ff4a8f80f39714ced2d932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a8c586e5350ff4a8f80f39714ced2d932">GetType</a> ()</td></tr>
<tr class="memdesc:a8c586e5350ff4a8f80f39714ced2d932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for char16_t.  <a href="#a8c586e5350ff4a8f80f39714ced2d932">More...</a><br /></td></tr>
<tr class="separator:a8c586e5350ff4a8f80f39714ced2d932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a8c586e5350ff4a8f80f39714ced2d932">GetType</a> ()</td></tr>
<tr class="memdesc:a8c586e5350ff4a8f80f39714ced2d932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for int32_t.  <a href="#a8c586e5350ff4a8f80f39714ced2d932">More...</a><br /></td></tr>
<tr class="separator:a8c586e5350ff4a8f80f39714ced2d932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a8c586e5350ff4a8f80f39714ced2d932">GetType</a> ()</td></tr>
<tr class="memdesc:a8c586e5350ff4a8f80f39714ced2d932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for int64_t.  <a href="#a8c586e5350ff4a8f80f39714ced2d932">More...</a><br /></td></tr>
<tr class="separator:a8c586e5350ff4a8f80f39714ced2d932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8c586e5350ff4a8f80f39714ced2d932"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a8c586e5350ff4a8f80f39714ced2d932">GetType</a> ()</td></tr>
<tr class="memdesc:a8c586e5350ff4a8f80f39714ced2d932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for bool.  <a href="#a8c586e5350ff4a8f80f39714ced2d932">More...</a><br /></td></tr>
<tr class="separator:a8c586e5350ff4a8f80f39714ced2d932"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a889c6b314efc4b36a74530a36197b185"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a889c6b314efc4b36a74530a36197b185"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a889c6b314efc4b36a74530a36197b185">GetType</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a889c6b314efc4b36a74530a36197b185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for smart pointers.  <a href="#a889c6b314efc4b36a74530a36197b185">More...</a><br /></td></tr>
<tr class="separator:a889c6b314efc4b36a74530a36197b185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f1cc31120286c27814737981803975"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a65f1cc31120286c27814737981803975"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;!std::is_fundamental&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a65f1cc31120286c27814737981803975">GetType</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a65f1cc31120286c27814737981803975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for structures.  <a href="#a65f1cc31120286c27814737981803975">More...</a><br /></td></tr>
<tr class="separator:a65f1cc31120286c27814737981803975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3de067dce017e6fb9b060272d4f9a06"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab3de067dce017e6fb9b060272d4f9a06"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ab3de067dce017e6fb9b060272d4f9a06">GetType</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:ab3de067dce017e6fb9b060272d4f9a06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for exceptions.  <a href="#ab3de067dce017e6fb9b060272d4f9a06">More...</a><br /></td></tr>
<tr class="separator:ab3de067dce017e6fb9b060272d4f9a06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832e74c3b66ab54ad05c418e72d21915"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a832e74c3b66ab54ad05c418e72d21915"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_fundamental&lt; T &gt;::value||std::is_enum&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a832e74c3b66ab54ad05c418e72d21915">GetType</a> (const T obj)</td></tr>
<tr class="memdesc:a832e74c3b66ab54ad05c418e72d21915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for primitive types.  <a href="#a832e74c3b66ab54ad05c418e72d21915">More...</a><br /></td></tr>
<tr class="separator:a832e74c3b66ab54ad05c418e72d21915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d5f688cdb532abb442461a6e449b7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51d5f688cdb532abb442461a6e449b7d"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a51d5f688cdb532abb442461a6e449b7d">GetType</a> (const T obj)</td></tr>
<tr class="memdesc:a51d5f688cdb532abb442461a6e449b7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> types.  <a href="#a51d5f688cdb532abb442461a6e449b7d">More...</a><br /></td></tr>
<tr class="separator:a51d5f688cdb532abb442461a6e449b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0a85b1c353073c6bfbc2a18d32b438"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaa0a85b1c353073c6bfbc2a18d32b438"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_fundamental&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#aaa0a85b1c353073c6bfbc2a18d32b438">GetType</a> ()</td></tr>
<tr class="memdesc:aaa0a85b1c353073c6bfbc2a18d32b438"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for primitive types.  <a href="#aaa0a85b1c353073c6bfbc2a18d32b438">More...</a><br /></td></tr>
<tr class="separator:aaa0a85b1c353073c6bfbc2a18d32b438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37e1ea4676744572b2208ef2d351768"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac37e1ea4676744572b2208ef2d351768"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_enum&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ac37e1ea4676744572b2208ef2d351768">GetType</a> ()</td></tr>
<tr class="memdesc:ac37e1ea4676744572b2208ef2d351768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for enum types.  <a href="#ac37e1ea4676744572b2208ef2d351768">More...</a><br /></td></tr>
<tr class="separator:ac37e1ea4676744572b2208ef2d351768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af5e56f4a9d0bd4680a85053a612d6a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2af5e56f4a9d0bd4680a85053a612d6a"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;(!std::is_fundamental&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_boxable.html">IsBoxable</a>&lt; T &gt;::value)||<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a2af5e56f4a9d0bd4680a85053a612d6a">GetType</a> ()</td></tr>
<tr class="memdesc:a2af5e56f4a9d0bd4680a85053a612d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for structures and pointers.  <a href="#a2af5e56f4a9d0bd4680a85053a612d6a">More...</a><br /></td></tr>
<tr class="separator:a2af5e56f4a9d0bd4680a85053a612d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e458ce41a7f5849cffde3f05384186"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae3e458ce41a7f5849cffde3f05384186"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ae3e458ce41a7f5849cffde3f05384186">GetType</a> ()</td></tr>
<tr class="memdesc:ae3e458ce41a7f5849cffde3f05384186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a>.  <a href="#ae3e458ce41a7f5849cffde3f05384186">More...</a><br /></td></tr>
<tr class="separator:ae3e458ce41a7f5849cffde3f05384186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d038ae37ecabd2fec8971f3894b627d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d038ae37ecabd2fec8971f3894b627d"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!std::is_fundamental&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_boxable.html">IsBoxable</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a6d038ae37ecabd2fec8971f3894b627d">GetType</a> ()</td></tr>
<tr class="memdesc:a6d038ae37ecabd2fec8971f3894b627d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for structures and pointers.  <a href="#a6d038ae37ecabd2fec8971f3894b627d">More...</a><br /></td></tr>
<tr class="separator:a6d038ae37ecabd2fec8971f3894b627d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57843daf6b0d8b04db2fde73720dca01"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a57843daf6b0d8b04db2fde73720dca01">GetType</a> (const <a class="el" href="class_system_1_1_string.html">String</a> &amp;obj)</td></tr>
<tr class="memdesc:a57843daf6b0d8b04db2fde73720dca01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for string type.  <a href="#a57843daf6b0d8b04db2fde73720dca01">More...</a><br /></td></tr>
<tr class="separator:a57843daf6b0d8b04db2fde73720dca01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911fa57b654ba73ed1f1fd24389ea94b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a911fa57b654ba73ed1f1fd24389ea94b"><td class="memTemplItemLeft" align="right" valign="top">static int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a911fa57b654ba73ed1f1fd24389ea94b">GetHashCode</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a911fa57b654ba73ed1f1fd24389ea94b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="class_system_1_1_object_ext.html#a911fa57b654ba73ed1f1fd24389ea94b" title="Implements GetHashCode() calls; works on both Object subclasses and unrelated types. ">GetHashCode()</a> calls; works on both <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> subclasses and unrelated types.  <a href="#a911fa57b654ba73ed1f1fd24389ea94b">More...</a><br /></td></tr>
<tr class="separator:a911fa57b654ba73ed1f1fd24389ea94b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9791ccafc34838cafa0b436d737cc14a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a9791ccafc34838cafa0b436d737cc14a"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a9791ccafc34838cafa0b436d737cc14a">Equals</a> (const T &amp;obj, const T2 &amp;another)</td></tr>
<tr class="separator:a9791ccafc34838cafa0b436d737cc14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a5e542d0a98828390376ffc225a662"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ac3a5e542d0a98828390376ffc225a662"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ac3a5e542d0a98828390376ffc225a662">Equals</a> (const T &amp;obj, const T2 &amp;another)</td></tr>
<tr class="memdesc:ac3a5e542d0a98828390376ffc225a662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for smart pointer types.  <a href="#ac3a5e542d0a98828390376ffc225a662">More...</a><br /></td></tr>
<tr class="separator:ac3a5e542d0a98828390376ffc225a662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e03c839c736632a991901075c96ed8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a39e03c839c736632a991901075c96ed8"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;!std::is_scalar&lt; T &gt;::value &amp;&amp;!::System::Details::HasIsNull&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a39e03c839c736632a991901075c96ed8">Equals</a> (T obj, const T2 &amp;another)</td></tr>
<tr class="memdesc:a39e03c839c736632a991901075c96ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for structure types without IsNull methods.  <a href="#a39e03c839c736632a991901075c96ed8">More...</a><br /></td></tr>
<tr class="separator:a39e03c839c736632a991901075c96ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2813c99a8bccc8f93fe864462f3a5c3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ae2813c99a8bccc8f93fe864462f3a5c3"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;!std::is_scalar&lt; T &gt;::value &amp;&amp;::System::Details::HasIsNull&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ae2813c99a8bccc8f93fe864462f3a5c3">Equals</a> (T obj, const T2 &amp;another)</td></tr>
<tr class="memdesc:ae2813c99a8bccc8f93fe864462f3a5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for structure types with IsNull method implemented.  <a href="#ae2813c99a8bccc8f93fe864462f3a5c3">More...</a><br /></td></tr>
<tr class="separator:ae2813c99a8bccc8f93fe864462f3a5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091ca4f5b75d122071fe2d7c2d597c66"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a091ca4f5b75d122071fe2d7c2d597c66"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;std::is_scalar&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a091ca4f5b75d122071fe2d7c2d597c66">Equals</a> (const T &amp;obj, const T2 &amp;another)</td></tr>
<tr class="memdesc:a091ca4f5b75d122071fe2d7c2d597c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for scalar types.  <a href="#a091ca4f5b75d122071fe2d7c2d597c66">More...</a><br /></td></tr>
<tr class="separator:a091ca4f5b75d122071fe2d7c2d597c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d253ed24f9fddfaa1f546a014743d22"><td class="memTemplParams" colspan="2">template&lt;size_t N&gt; </td></tr>
<tr class="memitem:a2d253ed24f9fddfaa1f546a014743d22"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a2d253ed24f9fddfaa1f546a014743d22">Equals</a> (const char_t(&amp;obj)[N], <a class="el" href="class_system_1_1_string.html">String</a> another)</td></tr>
<tr class="memdesc:a2d253ed24f9fddfaa1f546a014743d22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for string literal with string comparison.  <a href="#a2d253ed24f9fddfaa1f546a014743d22">More...</a><br /></td></tr>
<tr class="separator:a2d253ed24f9fddfaa1f546a014743d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a47581b14b298ef9da890fb37918da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_system_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a02a47581b14b298ef9da890fb37918da">ToString</a> (const char_t *obj)</td></tr>
<tr class="memdesc:a02a47581b14b298ef9da890fb37918da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#a02a47581b14b298ef9da890fb37918da">More...</a><br /></td></tr>
<tr class="separator:a02a47581b14b298ef9da890fb37918da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb22bf85b79ad7730f7aca725ae959f0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adb22bf85b79ad7730f7aca725ae959f0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_system_1_1_string.html">String</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#adb22bf85b79ad7730f7aca725ae959f0">ToString</a> (const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &amp;obj)</td></tr>
<tr class="memdesc:adb22bf85b79ad7730f7aca725ae959f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#adb22bf85b79ad7730f7aca725ae959f0">More...</a><br /></td></tr>
<tr class="separator:adb22bf85b79ad7730f7aca725ae959f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa7b9f131b6f192454915bd0fb6019f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1aa7b9f131b6f192454915bd0fb6019f"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_enum&lt; T &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a1aa7b9f131b6f192454915bd0fb6019f">ToString</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a1aa7b9f131b6f192454915bd0fb6019f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#a1aa7b9f131b6f192454915bd0fb6019f">More...</a><br /></td></tr>
<tr class="separator:a1aa7b9f131b6f192454915bd0fb6019f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ad494118cc5b1fff421605b4896665"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92ad494118cc5b1fff421605b4896665"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a92ad494118cc5b1fff421605b4896665">ToString</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a92ad494118cc5b1fff421605b4896665"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#a92ad494118cc5b1fff421605b4896665">More...</a><br /></td></tr>
<tr class="separator:a92ad494118cc5b1fff421605b4896665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896a0422afa5db270187afebc0be5744"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a896a0422afa5db270187afebc0be5744"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value||std::is_pointer&lt; T &gt;::value||<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a896a0422afa5db270187afebc0be5744">ToString</a> (T &amp;obj)</td></tr>
<tr class="memdesc:a896a0422afa5db270187afebc0be5744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#a896a0422afa5db270187afebc0be5744">More...</a><br /></td></tr>
<tr class="separator:a896a0422afa5db270187afebc0be5744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0682cdf3abcdc9d8e94bd92d3513ce9e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0682cdf3abcdc9d8e94bd92d3513ce9e"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;std::is_scalar&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a0682cdf3abcdc9d8e94bd92d3513ce9e">ToString</a> (T &amp;obj)</td></tr>
<tr class="memdesc:a0682cdf3abcdc9d8e94bd92d3513ce9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#a0682cdf3abcdc9d8e94bd92d3513ce9e">More...</a><br /></td></tr>
<tr class="separator:a0682cdf3abcdc9d8e94bd92d3513ce9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43d9617b5d564872e82ea43219ec7434"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43d9617b5d564872e82ea43219ec7434"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;std::is_scalar&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a43d9617b5d564872e82ea43219ec7434">ToString</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:a43d9617b5d564872e82ea43219ec7434"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#a43d9617b5d564872e82ea43219ec7434">More...</a><br /></td></tr>
<tr class="separator:a43d9617b5d564872e82ea43219ec7434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6962046fcc6a9961ba139ae96812420"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae6962046fcc6a9961ba139ae96812420"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;!std::is_scalar&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ae6962046fcc6a9961ba139ae96812420">ToString</a> (T &amp;obj)</td></tr>
<tr class="memdesc:ae6962046fcc6a9961ba139ae96812420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#ae6962046fcc6a9961ba139ae96812420">More...</a><br /></td></tr>
<tr class="separator:ae6962046fcc6a9961ba139ae96812420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf3fb6e53532ecb3cfe7e71ecef76d6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:accf3fb6e53532ecb3cfe7e71ecef76d6"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;!std::is_scalar&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#accf3fb6e53532ecb3cfe7e71ecef76d6">ToString</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:accf3fb6e53532ecb3cfe7e71ecef76d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#accf3fb6e53532ecb3cfe7e71ecef76d6">More...</a><br /></td></tr>
<tr class="separator:accf3fb6e53532ecb3cfe7e71ecef76d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afa396da62ca6b0a755921006c6936d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1afa396da62ca6b0a755921006c6936d"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;!std::is_scalar&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value &amp;&amp;!std::is_reference&lt; T &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a1afa396da62ca6b0a755921006c6936d">ToString</a> (T &amp;&amp;obj)</td></tr>
<tr class="memdesc:a1afa396da62ca6b0a755921006c6936d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Substitution for C# ToString method to work on any C++ type.  <a href="#a1afa396da62ca6b0a755921006c6936d">More...</a><br /></td></tr>
<tr class="separator:a1afa396da62ca6b0a755921006c6936d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72261cf4a90feb02c81197f3c4e68e62"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a72261cf4a90feb02c81197f3c4e68e62"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_enum&lt; T &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">System::Object</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a72261cf4a90feb02c81197f3c4e68e62">Box</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a72261cf4a90feb02c81197f3c4e68e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boxes value types for converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for enum types.  <a href="#a72261cf4a90feb02c81197f3c4e68e62">More...</a><br /></td></tr>
<tr class="separator:a72261cf4a90feb02c81197f3c4e68e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572f03f51606d89db1be2f3177f549bd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a572f03f51606d89db1be2f3177f549bd"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">System::Object</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a572f03f51606d89db1be2f3177f549bd">Box</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a572f03f51606d89db1be2f3177f549bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boxes value types for converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for non-enum types.  <a href="#a572f03f51606d89db1be2f3177f549bd">More...</a><br /></td></tr>
<tr class="separator:a572f03f51606d89db1be2f3177f549bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d529e06fa9229ae703f6d52d688bd15"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d529e06fa9229ae703f6d52d688bd15"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">System::Object</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a2d529e06fa9229ae703f6d52d688bd15">Box</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a2d529e06fa9229ae703f6d52d688bd15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boxes <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> types for converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>.  <a href="#a2d529e06fa9229ae703f6d52d688bd15">More...</a><br /></td></tr>
<tr class="separator:a2d529e06fa9229ae703f6d52d688bd15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023ec6df6bf0aa6c399cbd82f68dfb6f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a023ec6df6bf0aa6c399cbd82f68dfb6f"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_enum&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a023ec6df6bf0aa6c399cbd82f68dfb6f">Unbox</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:a023ec6df6bf0aa6c399cbd82f68dfb6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unboxes value types after converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for enum types.  <a href="#a023ec6df6bf0aa6c399cbd82f68dfb6f">More...</a><br /></td></tr>
<tr class="separator:a023ec6df6bf0aa6c399cbd82f68dfb6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e7fb742074d0321f488de426b22cbb0"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4e7fb742074d0321f488de426b22cbb0"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;detail::has_operator_equal&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a4e7fb742074d0321f488de426b22cbb0">Unbox</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:a4e7fb742074d0321f488de426b22cbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unboxes value types after converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for non-enum &amp; non-nullable types.  <a href="#a4e7fb742074d0321f488de426b22cbb0">More...</a><br /></td></tr>
<tr class="separator:a4e7fb742074d0321f488de426b22cbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8ecee4a4d4ffdf1cfc0cedd38457b5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:adc8ecee4a4d4ffdf1cfc0cedd38457b5"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!std::is_enum&lt; T &gt;::value &amp;&amp;!detail::has_operator_equal&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#adc8ecee4a4d4ffdf1cfc0cedd38457b5">Unbox</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:adc8ecee4a4d4ffdf1cfc0cedd38457b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unboxes value types after converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for non-enum &amp; non-nullable types.  <a href="#adc8ecee4a4d4ffdf1cfc0cedd38457b5">More...</a><br /></td></tr>
<tr class="separator:adc8ecee4a4d4ffdf1cfc0cedd38457b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a929a80f83df453b3f65a1227d6d6ef"><td class="memTemplParams" colspan="2">template&lt;class T , class E &gt; </td></tr>
<tr class="memitem:a5a929a80f83df453b3f65a1227d6d6ef"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_enum&lt; E &gt;::value &amp;&amp;std::numeric_limits&lt; T &gt;::is_integer, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a5a929a80f83df453b3f65a1227d6d6ef">Unbox</a> (E e)</td></tr>
<tr class="memdesc:a5a929a80f83df453b3f65a1227d6d6ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unboxes enum types to integer.  <a href="#a5a929a80f83df453b3f65a1227d6d6ef">More...</a><br /></td></tr>
<tr class="separator:a5a929a80f83df453b3f65a1227d6d6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a355ccf651b9c222f754c450c39b0a"><td class="memTemplParams" colspan="2">template&lt;class T , class E &gt; </td></tr>
<tr class="memitem:ac3a355ccf651b9c222f754c450c39b0a"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_enum&lt; E &gt;::value &amp;&amp;std::is_enum&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ac3a355ccf651b9c222f754c450c39b0a">Unbox</a> (E e)</td></tr>
<tr class="memdesc:ac3a355ccf651b9c222f754c450c39b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts enum types.  <a href="#ac3a355ccf651b9c222f754c450c39b0a">More...</a><br /></td></tr>
<tr class="separator:ac3a355ccf651b9c222f754c450c39b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25d74c06b5a5358709f8a686cfb5704"><td class="memItemLeft" align="right" valign="top">static ASPOSECPP_SHARED_API <a class="el" href="class_system_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ab25d74c06b5a5358709f8a686cfb5704">UnboxStringSafe</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:ab25d74c06b5a5358709f8a686cfb5704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unboxes string from boxed value.  <a href="#ab25d74c06b5a5358709f8a686cfb5704">More...</a><br /></td></tr>
<tr class="separator:ab25d74c06b5a5358709f8a686cfb5704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29cc615475a61710c0f66a75996a826a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a29cc615475a61710c0f66a75996a826a"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a29cc615475a61710c0f66a75996a826a">UnboxToNullable</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj, bool safe=true)</td></tr>
<tr class="memdesc:a29cc615475a61710c0f66a75996a826a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unboxes object to nullable type.  <a href="#a29cc615475a61710c0f66a75996a826a">More...</a><br /></td></tr>
<tr class="separator:a29cc615475a61710c0f66a75996a826a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1768558a413d489928155230fe108a3f"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1768558a413d489928155230fe108a3f"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_convertible&lt; T, <a class="el" href="class_system_1_1_object.html">Object</a> &gt;::value &amp;&amp;std::is_final&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; U &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a1768558a413d489928155230fe108a3f">Is</a> (const U &amp;obj)</td></tr>
<tr class="memdesc:a1768558a413d489928155230fe108a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for pointer types optimized for 'final' classes.  <a href="#a1768558a413d489928155230fe108a3f">More...</a><br /></td></tr>
<tr class="separator:a1768558a413d489928155230fe108a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515c352a2797ea5f452bf30e317c2ee9"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a515c352a2797ea5f452bf30e317c2ee9"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_convertible&lt; T, <a class="el" href="class_system_1_1_object.html">Object</a> &gt;::value &amp;&amp;!std::is_final&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; U &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a515c352a2797ea5f452bf30e317c2ee9">Is</a> (const U &amp;obj)</td></tr>
<tr class="memdesc:a515c352a2797ea5f452bf30e317c2ee9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for pointer types.  <a href="#a515c352a2797ea5f452bf30e317c2ee9">More...</a><br /></td></tr>
<tr class="separator:a515c352a2797ea5f452bf30e317c2ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2ef66070b4b919a0a7360742cd857e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9f2ef66070b4b919a0a7360742cd857e"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_convertible&lt; T, <a class="el" href="class_system_1_1_object.html">Object</a> &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a9f2ef66070b4b919a0a7360742cd857e">Is</a> (const <a class="el" href="class_system_1_1_object.html">Object</a> &amp;obj)</td></tr>
<tr class="memdesc:a9f2ef66070b4b919a0a7360742cd857e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for value types.  <a href="#a9f2ef66070b4b919a0a7360742cd857e">More...</a><br /></td></tr>
<tr class="separator:a9f2ef66070b4b919a0a7360742cd857e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244ce8386343662ee1b11fae54870f30"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a244ce8386343662ee1b11fae54870f30"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!std::is_convertible&lt; T, <a class="el" href="class_system_1_1_object.html">Object</a> &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a244ce8386343662ee1b11fae54870f30">Is</a> (const <a class="el" href="class_system_1_1_object.html">Object</a> &amp;obj)</td></tr>
<tr class="memdesc:a244ce8386343662ee1b11fae54870f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for unconvertible types.  <a href="#a244ce8386343662ee1b11fae54870f30">More...</a><br /></td></tr>
<tr class="separator:a244ce8386343662ee1b11fae54870f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2be835c2cf5c52b670a5bb05c51f400"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:af2be835c2cf5c52b670a5bb05c51f400"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#af2be835c2cf5c52b670a5bb05c51f400">Is</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; U &gt; &amp;obj)</td></tr>
<tr class="memdesc:af2be835c2cf5c52b670a5bb05c51f400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for pointer types.  <a href="#af2be835c2cf5c52b670a5bb05c51f400">More...</a><br /></td></tr>
<tr class="separator:af2be835c2cf5c52b670a5bb05c51f400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb51603ce5ce39512ff2dfa4c762ca9"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a1bb51603ce5ce39512ff2dfa4c762ca9"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a1bb51603ce5ce39512ff2dfa4c762ca9">Is</a> (const <a class="el" href="class_system_1_1_exception_wrapper.html">ExceptionWrapper</a>&lt; U &gt; &amp;obj)</td></tr>
<tr class="memdesc:a1bb51603ce5ce39512ff2dfa4c762ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for exception wrapper types.  <a href="#a1bb51603ce5ce39512ff2dfa4c762ca9">More...</a><br /></td></tr>
<tr class="separator:a1bb51603ce5ce39512ff2dfa4c762ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee9d8d508655e22b36687e5a76886db"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acee9d8d508655e22b36687e5a76886db"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#acee9d8d508655e22b36687e5a76886db">Is</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:acee9d8d508655e22b36687e5a76886db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for nullable types.  <a href="#acee9d8d508655e22b36687e5a76886db">More...</a><br /></td></tr>
<tr class="separator:acee9d8d508655e22b36687e5a76886db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5379415d39f2faa77f0a862ea720e5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acc5379415d39f2faa77f0a862ea720e5"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &amp;&amp;detail::has_operator_equal&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#acc5379415d39f2faa77f0a862ea720e5">Is</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:acc5379415d39f2faa77f0a862ea720e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for boxable types with == operator defined.  <a href="#acc5379415d39f2faa77f0a862ea720e5">More...</a><br /></td></tr>
<tr class="separator:acc5379415d39f2faa77f0a862ea720e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b69b932b7d71a3cd26b8e506c8c6de7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a8b69b932b7d71a3cd26b8e506c8c6de7"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value &amp;&amp;!std::is_enum&lt; T &gt;::value &amp;&amp;!detail::has_operator_equal&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a8b69b932b7d71a3cd26b8e506c8c6de7">Is</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:a8b69b932b7d71a3cd26b8e506c8c6de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for boxable types without defined ==.  <a href="#a8b69b932b7d71a3cd26b8e506c8c6de7">More...</a><br /></td></tr>
<tr class="separator:a8b69b932b7d71a3cd26b8e506c8c6de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5d3e14d184a87bdc1a4ebd3f76655c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6a5d3e14d184a87bdc1a4ebd3f76655c"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_enum&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a6a5d3e14d184a87bdc1a4ebd3f76655c">Is</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:a6a5d3e14d184a87bdc1a4ebd3f76655c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for enum types.  <a href="#a6a5d3e14d184a87bdc1a4ebd3f76655c">More...</a><br /></td></tr>
<tr class="separator:a6a5d3e14d184a87bdc1a4ebd3f76655c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d98ab8c89ef061c4594aa61c2c3d4c7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4d98ab8c89ef061c4594aa61c2c3d4c7"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_enum&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a4d98ab8c89ef061c4594aa61c2c3d4c7">Is</a> (const <a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:a4d98ab8c89ef061c4594aa61c2c3d4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for enum types vs weak pointers.  <a href="#a4d98ab8c89ef061c4594aa61c2c3d4c7">More...</a><br /></td></tr>
<tr class="separator:a4d98ab8c89ef061c4594aa61c2c3d4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42212f76edcd834ffb08b2388b2dee63"><td class="memTemplParams" colspan="2">template&lt;class T , class U &gt; </td></tr>
<tr class="memitem:a42212f76edcd834ffb08b2388b2dee63"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a42212f76edcd834ffb08b2388b2dee63">Is</a> (const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; U &gt; &amp;value)</td></tr>
<tr class="memdesc:a42212f76edcd834ffb08b2388b2dee63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements 'is' operator translation. Specialization for <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> type.  <a href="#a42212f76edcd834ffb08b2388b2dee63">More...</a><br /></td></tr>
<tr class="separator:a42212f76edcd834ffb08b2388b2dee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a9d22662302a4edf430ba3cc7536424"><td class="memItemLeft" align="right" valign="top">static ASPOSECPP_SHARED_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a6a9d22662302a4edf430ba3cc7536424">IsBoxedValue</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="memdesc:a6a9d22662302a4edf430ba3cc7536424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if object is a boxed value.  <a href="#a6a9d22662302a4edf430ba3cc7536424">More...</a><br /></td></tr>
<tr class="separator:a6a9d22662302a4edf430ba3cc7536424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1091aa12d47816759617c01886ba3b3f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1091aa12d47816759617c01886ba3b3f"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a1091aa12d47816759617c01886ba3b3f">UnknownToObject</a> (T obj)</td></tr>
<tr class="memdesc:a1091aa12d47816759617c01886ba3b3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts unknown type to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>, handling both smart pointer type and value type situations.  <a href="#a1091aa12d47816759617c01886ba3b3f">More...</a><br /></td></tr>
<tr class="separator:a1091aa12d47816759617c01886ba3b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fc835218949ce3d15404737c80e08f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5fc835218949ce3d15404737c80e08f7"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a5fc835218949ce3d15404737c80e08f7">UnknownToObject</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a5fc835218949ce3d15404737c80e08f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts unknown type to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>, handling both smart pointer type and value type situations.  <a href="#a5fc835218949ce3d15404737c80e08f7">More...</a><br /></td></tr>
<tr class="separator:a5fc835218949ce3d15404737c80e08f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31495e6d8ed761eb33e0f53abcfc46ed"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a31495e6d8ed761eb33e0f53abcfc46ed"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a31495e6d8ed761eb33e0f53abcfc46ed">ObjectToUnknown</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; obj)</td></tr>
<tr class="memdesc:a31495e6d8ed761eb33e0f53abcfc46ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to unknown type, handling both smart pointer type and bpxed value situations.  <a href="#a31495e6d8ed761eb33e0f53abcfc46ed">More...</a><br /></td></tr>
<tr class="separator:a31495e6d8ed761eb33e0f53abcfc46ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf7825f7a366300f2413e0576a61631"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3bf7825f7a366300f2413e0576a61631"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a3bf7825f7a366300f2413e0576a61631">ObjectToUnknown</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; obj)</td></tr>
<tr class="memdesc:a3bf7825f7a366300f2413e0576a61631"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to unknown type, handling both smart pointer type and boxed value situations.  <a href="#a3bf7825f7a366300f2413e0576a61631">More...</a><br /></td></tr>
<tr class="separator:a3bf7825f7a366300f2413e0576a61631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4050a2ce3c7c37f252dab5e95971b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adc4050a2ce3c7c37f252dab5e95971b9"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;!std::is_scalar&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#adc4050a2ce3c7c37f252dab5e95971b9">UnknownIsNull</a> (T obj)</td></tr>
<tr class="memdesc:adc4050a2ce3c7c37f252dab5e95971b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether unknown type object is nullptr. Overload for non-scalar types.  <a href="#adc4050a2ce3c7c37f252dab5e95971b9">More...</a><br /></td></tr>
<tr class="separator:adc4050a2ce3c7c37f252dab5e95971b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd4bfbe9c9879dde2e5e167eb8a642d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8bd4bfbe9c9879dde2e5e167eb8a642d"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; std::is_scalar&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a8bd4bfbe9c9879dde2e5e167eb8a642d">UnknownIsNull</a> (T obj)</td></tr>
<tr class="memdesc:a8bd4bfbe9c9879dde2e5e167eb8a642d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether unknown type object is nullptr. Overload for scalar types.  <a href="#a8bd4bfbe9c9879dde2e5e167eb8a642d">More...</a><br /></td></tr>
<tr class="separator:a8bd4bfbe9c9879dde2e5e167eb8a642d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abd174f62953abd85670c81a9473985"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:a9abd174f62953abd85670c81a9473985"><td class="memTemplItemLeft" align="right" valign="top">static T0&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a9abd174f62953abd85670c81a9473985">Coalesce</a> (T0 value, T1 func)</td></tr>
<tr class="memdesc:a9abd174f62953abd85670c81a9473985"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of '?' operator translation for non-nullable types.  <a href="#a9abd174f62953abd85670c81a9473985">More...</a><br /></td></tr>
<tr class="separator:a9abd174f62953abd85670c81a9473985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e2de2e4accde43b92a19ecbdc635b4"><td class="memTemplParams" colspan="2">template&lt;typename T0 , typename T1 &gt; </td></tr>
<tr class="memitem:a04e2de2e4accde43b92a19ecbdc635b4"><td class="memTemplItemLeft" align="right" valign="top">static T0&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a04e2de2e4accde43b92a19ecbdc635b4">Coalesce</a> (<a class="el" href="class_system_1_1_nullable.html">System::Nullable</a>&lt; T0 &gt; value, T1 func)</td></tr>
<tr class="memdesc:a04e2de2e4accde43b92a19ecbdc635b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of '?' operator translation for nullable types.  <a href="#a04e2de2e4accde43b92a19ecbdc635b4">More...</a><br /></td></tr>
<tr class="separator:a04e2de2e4accde43b92a19ecbdc635b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a5485eed695ea2506b69c6f57bdff7d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6a5485eed695ea2506b69c6f57bdff7d"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_boxed_value_base.html">System::BoxedValueBase</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a6a5485eed695ea2506b69c6f57bdff7d">BoxEnum</a> (T enumValue)</td></tr>
<tr class="memdesc:a6a5485eed695ea2506b69c6f57bdff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boxes enum types for being propagated as <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>.  <a href="#a6a5485eed695ea2506b69c6f57bdff7d">More...</a><br /></td></tr>
<tr class="separator:a6a5485eed695ea2506b69c6f57bdff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48083da3eeddaeb87ee16b1145f6780b"><td class="memTemplParams" colspan="2">template&lt;typename To , typename ... From&gt; </td></tr>
<tr class="memitem:a48083da3eeddaeb87ee16b1145f6780b"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt;(std::is_fundamental&lt; To &gt;::value), std::initializer_list&lt; To &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a48083da3eeddaeb87ee16b1145f6780b">ArrayInitializerCast</a> (From ...args)</td></tr>
<tr class="memdesc:a48083da3eeddaeb87ee16b1145f6780b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts array fundamental values (which C# does implicitly but C++ apparently does not).  <a href="#a48083da3eeddaeb87ee16b1145f6780b">More...</a><br /></td></tr>
<tr class="separator:a48083da3eeddaeb87ee16b1145f6780b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b94b6ffbe7765e03f2c15c164e79c9b"><td class="memItemLeft" align="right" valign="top">static ASPOSECPP_SHARED_API <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_collections_1_1_i_list.html">System::Collections::IList</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a1b94b6ffbe7765e03f2c15c164e79c9b">CastToIList</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;obj)</td></tr>
<tr class="separator:a1b94b6ffbe7765e03f2c15c164e79c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e00b54729955846625499c2be8dae4d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e00b54729955846625499c2be8dae4d"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt; T &gt;::value, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">System::Object</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#a8e00b54729955846625499c2be8dae4d">ExplicitCastToObject</a> (const T &amp;value)</td></tr>
<tr class="separator:a8e00b54729955846625499c2be8dae4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab495944ed57b5dda23a53e3232dc0092"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab495944ed57b5dda23a53e3232dc0092"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; T &gt;::value, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">System::Object</a> &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html#ab495944ed57b5dda23a53e3232dc0092">ExplicitCastToObject</a> (const T &amp;value)</td></tr>
<tr class="separator:ab495944ed57b5dda23a53e3232dc0092"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provides static methods that emulate C# <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> methods called for non-Object C++ types (strings, numbers, etc.). This is a static type with no instance services. You should never create instances of it by any means. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a48083da3eeddaeb87ee16b1145f6780b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48083da3eeddaeb87ee16b1145f6780b">&#9670;&nbsp;</a></span>ArrayInitializerCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename ... From&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;(std::is_fundamental&lt;To&gt;::value), std::initializer_list&lt;To&gt; &gt;::type System::ObjectExt::ArrayInitializerCast </td>
          <td>(</td>
          <td class="paramtype">From ...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts array fundamental values (which C# does implicitly but C++ apparently does not). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>Target type. </td></tr>
    <tr><td class="paramname">From</td><td>Source types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Values to convert and push to target array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> containing converted copies of all arguments in the same order. </dd></dl>

</div>
</div>
<a id="a72261cf4a90feb02c81197f3c4e68e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72261cf4a90feb02c81197f3c4e68e62">&#9670;&nbsp;</a></span>Box() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_enum&lt;T&gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">System::Object</a>&gt; &gt;::type System::ObjectExt::Box </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boxes value types for converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for enum types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="struct_system_1_1_enum.html" title="Provides methods that perform some operations on values of enum type. This is a static type with no i...">Enum</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><a class="el" href="struct_system_1_1_enum.html" title="Provides methods that perform some operations on values of enum type. This is a static type with no i...">Enum</a> value to box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to object keeping boxed value. </dd></dl>

</div>
</div>
<a id="a572f03f51606d89db1be2f3177f549bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572f03f51606d89db1be2f3177f549bd">&#9670;&nbsp;</a></span>Box() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!std::is_enum&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">System::Object</a>&gt; &gt;::type System::ObjectExt::Box </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boxes value types for converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for non-enum types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to object keeping boxed value. </dd></dl>

</div>
</div>
<a id="a2d529e06fa9229ae703f6d52d688bd15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d529e06fa9229ae703f6d52d688bd15">&#9670;&nbsp;</a></span>Box() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">System::Object</a>&gt; &gt;::type System::ObjectExt::Box </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boxes <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> types for converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to object keeping boxed value. </dd></dl>

</div>
</div>
<a id="ab678c616a7ca83827fb013210a20e705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab678c616a7ca83827fb013210a20e705">&#9670;&nbsp;</a></span>Box() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">Object</a>&gt; System::ObjectExt::Box </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boxes string values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boxed value or null, if source string is null. </dd></dl>

</div>
</div>
<a id="a6a5485eed695ea2506b69c6f57bdff7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5485eed695ea2506b69c6f57bdff7d">&#9670;&nbsp;</a></span>BoxEnum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="class_system_1_1_boxed_value_base.html">System::BoxedValueBase</a>&gt; System::ObjectExt::BoxEnum </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>enumValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Boxes enum types for being propagated as <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="struct_system_1_1_enum.html" title="Provides methods that perform some operations on values of enum type. This is a static type with no i...">Enum</a> type to box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumValue</td><td><a class="el" href="struct_system_1_1_enum.html" title="Provides methods that perform some operations on values of enum type. This is a static type with no i...">Enum</a> value to box. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Boxed enum value. </dd></dl>

</div>
</div>
<a id="a1b94b6ffbe7765e03f2c15c164e79c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b94b6ffbe7765e03f2c15c164e79c9b">&#9670;&nbsp;</a></span>CastToIList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ASPOSECPP_SHARED_API <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="class_system_1_1_collections_1_1_i_list.html">System::Collections::IList</a>&gt; System::ObjectExt::CastToIList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9abd174f62953abd85670c81a9473985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abd174f62953abd85670c81a9473985">&#9670;&nbsp;</a></span>Coalesce() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T0 System::ObjectExt::Coalesce </td>
          <td>(</td>
          <td class="paramtype">T0&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of '?' operator translation for non-nullable types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T0</td><td>LHS value type. </td></tr>
    <tr><td class="paramname">T1</td><td>Type of lambda encapsulating RHS expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>LHS value. </td></tr>
    <tr><td class="paramname">func</td><td>RHS expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If LHS value is not null, returns LHS, otherwise calculates RHS expression and returns result. </dd></dl>

</div>
</div>
<a id="a04e2de2e4accde43b92a19ecbdc635b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e2de2e4accde43b92a19ecbdc635b4">&#9670;&nbsp;</a></span>Coalesce() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T0 , typename T1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static T0 System::ObjectExt::Coalesce </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_nullable.html">System::Nullable</a>&lt; T0 &gt;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation of '?' operator translation for nullable types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T0</td><td>LHS value type. </td></tr>
    <tr><td class="paramname">T1</td><td>Type of lambda encapsulating RHS expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>LHS value. </td></tr>
    <tr><td class="paramname">func</td><td>RHS expression. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If LHS value is not null, returns LHS, otherwise calculates RHS expression and returns result. </dd></dl>

</div>
</div>
<a id="a9791ccafc34838cafa0b436d737cc14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9791ccafc34838cafa0b436d737cc14a">&#9670;&nbsp;</a></span>Equals() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Equals </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3a5e542d0a98828390376ffc225a662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a5e542d0a98828390376ffc225a662">&#9670;&nbsp;</a></span>Equals() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Equals </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for smart pointer types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>First object type. </td></tr>
    <tr><td class="paramname">T2</td><td>Second object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>First object. </td></tr>
    <tr><td class="paramname">another</td><td>Second object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if objects are considered equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a39e03c839c736632a991901075c96ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e03c839c736632a991901075c96ed8">&#9670;&nbsp;</a></span>Equals() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; !std::is_scalar&lt;T&gt;::value &amp;&amp; !::System::Details::HasIsNull&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Equals </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for structure types without IsNull methods. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>First object type. </td></tr>
    <tr><td class="paramname">T2</td><td>Second object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>First object. </td></tr>
    <tr><td class="paramname">another</td><td>Second object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if objects are considered equal, false otherwise. </dd></dl>

</div>
</div>
<a id="ae2813c99a8bccc8f93fe864462f3a5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2813c99a8bccc8f93fe864462f3a5c3">&#9670;&nbsp;</a></span>Equals() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; !std::is_scalar&lt;T&gt;::value &amp;&amp; ::System::Details::HasIsNull&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Equals </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for structure types with IsNull method implemented. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>First object type. </td></tr>
    <tr><td class="paramname">T2</td><td>Second object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>First object. </td></tr>
    <tr><td class="paramname">another</td><td>Second object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if objects are considered equal, false otherwise. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">NullReferenceException</td><td>if <code>obj</code> is null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a091ca4f5b75d122071fe2d7c2d597c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091ca4f5b75d122071fe2d7c2d597c66">&#9670;&nbsp;</a></span>Equals() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; std::is_scalar&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Equals </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for scalar types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>First object type. </td></tr>
    <tr><td class="paramname">T2</td><td>Second object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>First object. </td></tr>
    <tr><td class="paramname">another</td><td>Second object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if objects are considered equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a2d253ed24f9fddfaa1f546a014743d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d253ed24f9fddfaa1f546a014743d22">&#9670;&nbsp;</a></span>Equals() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool System::ObjectExt::Equals </td>
          <td>(</td>
          <td class="paramtype">const char_t(&amp;)&#160;</td>
          <td class="paramname"><em>obj</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_string.html">String</a>&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">Object.Equals</a> calls working for any type in C++. Overload for string literal with string comparison. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> literal size. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> literal. </td></tr>
    <tr><td class="paramname">another</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if strings match, false otherwise. </dd></dl>

</div>
</div>
<a id="a5a852245e87101f4b1625180a52dbed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a852245e87101f4b1625180a52dbed6">&#9670;&nbsp;</a></span>Equals() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::ObjectExt::Equals </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emulates C#-style floating point comparison where two NaNs are considered equal even though according to IEC 60559:1989 NaN is not equal to any value, including NaN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>LHS floating point value. </td></tr>
    <tr><td class="paramname">another</td><td>RHS floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>obj</code> and <code>another</code> are both NaN or equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a4a95d61c6ae0ceb942a528fec1de24d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a95d61c6ae0ceb942a528fec1de24d9">&#9670;&nbsp;</a></span>Equals() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::ObjectExt::Equals </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>another</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emulates C#-style floating point comparison where two NaNs are considered equal even though according to IEC 60559:1989 NaN is not equal to any value, including NaN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>LHS floating point value. </td></tr>
    <tr><td class="paramname">another</td><td>RHS floating point value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>obj</code> and <code>another</code> are both NaN or equal, false otherwise. </dd></dl>

</div>
</div>
<a id="a8e00b54729955846625499c2be8dae4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e00b54729955846625499c2be8dae4d">&#9670;&nbsp;</a></span>ExplicitCastToObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt;T&gt;::value, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">System::Object</a>&gt; &gt;::type System::ObjectExt::ExplicitCastToObject </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab495944ed57b5dda23a53e3232dc0092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab495944ed57b5dda23a53e3232dc0092">&#9670;&nbsp;</a></span>ExplicitCastToObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;T&gt;::value, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">System::Object</a>&gt; &gt;::type System::ObjectExt::ExplicitCastToObject </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a911fa57b654ba73ed1f1fd24389ea94b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911fa57b654ba73ed1f1fd24389ea94b">&#9670;&nbsp;</a></span>GetHashCode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int System::ObjectExt::GetHashCode </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="class_system_1_1_object_ext.html#a911fa57b654ba73ed1f1fd24389ea94b" title="Implements GetHashCode() calls; works on both Object subclasses and unrelated types. ">GetHashCode()</a> calls; works on both <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> subclasses and unrelated types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to calculate hash code for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to calculate hash code for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Hash code calculated for object passed. </dd></dl>

</div>
</div>
<a id="a889c6b314efc4b36a74530a36197b185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889c6b314efc4b36a74530a36197b185">&#9670;&nbsp;</a></span>GetType() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for smart pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointer object type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to get <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the final class of object passed. </dd></dl>

</div>
</div>
<a id="a65f1cc31120286c27814737981803975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f1cc31120286c27814737981803975">&#9670;&nbsp;</a></span>GetType() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; !std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for structures. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Structure type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to get <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the final class of object passed. </dd></dl>

</div>
</div>
<a id="ab3de067dce017e6fb9b060272d4f9a06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3de067dce017e6fb9b060272d4f9a06">&#9670;&nbsp;</a></span>GetType() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for exceptions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Exception type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to get <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the final class of object passed. </dd></dl>

</div>
</div>
<a id="a832e74c3b66ab54ad05c418e72d21915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832e74c3b66ab54ad05c418e72d21915">&#9670;&nbsp;</a></span>GetType() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_fundamental&lt;T&gt;::value || std::is_enum&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for primitive types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Primitive type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>IGNORED </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the type of object passed. </dd></dl>

</div>
</div>
<a id="a51d5f688cdb532abb442461a6e449b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51d5f688cdb532abb442461a6e449b7d">&#9670;&nbsp;</a></span>GetType() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>IGNORED </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the type of object passed. </dd></dl>

</div>
</div>
<a id="aaa0a85b1c353073c6bfbc2a18d32b438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0a85b1c353073c6bfbc2a18d32b438">&#9670;&nbsp;</a></span>GetType() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for primitive types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Primitive type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the type specified. </dd></dl>

</div>
</div>
<a id="ac37e1ea4676744572b2208ef2d351768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37e1ea4676744572b2208ef2d351768">&#9670;&nbsp;</a></span>GetType() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_enum&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for enum types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Primitive type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the type specified. </dd></dl>

</div>
</div>
<a id="a2af5e56f4a9d0bd4680a85053a612d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af5e56f4a9d0bd4680a85053a612d6a">&#9670;&nbsp;</a></span>GetType() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;(!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_boxable.html">IsBoxable</a>&lt;T&gt;::value) || <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for structures and pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Primitive type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the strcture specified. </dd></dl>

</div>
</div>
<a id="ae3e458ce41a7f5849cffde3f05384186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e458ce41a7f5849cffde3f05384186">&#9670;&nbsp;</a></span>GetType() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the strcture specified. </dd></dl>

</div>
</div>
<a id="a6d038ae37ecabd2fec8971f3894b627d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d038ae37ecabd2fec8971f3894b627d">&#9670;&nbsp;</a></span>GetType() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!std::is_fundamental&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_boxable.html">IsBoxable</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value, const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp;&gt;::type System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for structures and pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Primitive type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing the strcture specified or pointee type if called for <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a>. </dd></dl>

</div>
</div>
<a id="a57843daf6b0d8b04db2fde73720dca01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57843daf6b0d8b04db2fde73720dca01">&#9670;&nbsp;</a></span>GetType() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp; System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for string type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Primitive type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> structure describing <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> type. </dd></dl>

</div>
</div>
<a id="a8c586e5350ff4a8f80f39714ced2d932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c586e5350ff4a8f80f39714ced2d932">&#9670;&nbsp;</a></span>GetType() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp; System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for uint8_t. </p>

</div>
</div>
<a id="a8c586e5350ff4a8f80f39714ced2d932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c586e5350ff4a8f80f39714ced2d932">&#9670;&nbsp;</a></span>GetType() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp; System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for char16_t. </p>

</div>
</div>
<a id="a8c586e5350ff4a8f80f39714ced2d932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c586e5350ff4a8f80f39714ced2d932">&#9670;&nbsp;</a></span>GetType() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp; System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for int32_t. </p>

</div>
</div>
<a id="a8c586e5350ff4a8f80f39714ced2d932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c586e5350ff4a8f80f39714ced2d932">&#9670;&nbsp;</a></span>GetType() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp; System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for int64_t. </p>

</div>
</div>
<a id="a8c586e5350ff4a8f80f39714ced2d932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c586e5350ff4a8f80f39714ced2d932">&#9670;&nbsp;</a></span>GetType() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp; System::ObjectExt::GetType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for bool. </p>

</div>
</div>
<a id="a1768558a413d489928155230fe108a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1768558a413d489928155230fe108a3f">&#9670;&nbsp;</a></span>Is() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_convertible&lt;T, <a class="el" href="class_system_1_1_object.html">Object</a>&gt;::value &amp;&amp; std::is_final&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;U&gt;::value, bool&gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for pointer types optimized for 'final' classes. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
    <tr><td class="paramname">U</td><td>Tested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="a515c352a2797ea5f452bf30e317c2ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515c352a2797ea5f452bf30e317c2ee9">&#9670;&nbsp;</a></span>Is() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_convertible&lt;T, <a class="el" href="class_system_1_1_object.html">Object</a>&gt;::value&amp;&amp; !std::is_final&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;U&gt;::value, bool&gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for pointer types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
    <tr><td class="paramname">U</td><td>Tested type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="a9f2ef66070b4b919a0a7360742cd857e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2ef66070b4b919a0a7360742cd857e">&#9670;&nbsp;</a></span>Is() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_convertible&lt;T, <a class="el" href="class_system_1_1_object.html">Object</a>&gt;::value, bool&gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for value types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="a244ce8386343662ee1b11fae54870f30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244ce8386343662ee1b11fae54870f30">&#9670;&nbsp;</a></span>Is() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!std::is_convertible&lt;T, <a class="el" href="class_system_1_1_object.html">Object</a>&gt;::value, bool&gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_object.html">Object</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for unconvertible types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns false as types are unconvertible. </dd></dl>

</div>
</div>
<a id="af2be835c2cf5c52b670a5bb05c51f400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2be835c2cf5c52b670a5bb05c51f400">&#9670;&nbsp;</a></span>Is() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for pointer types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="a1bb51603ce5ce39512ff2dfa4c762ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb51603ce5ce39512ff2dfa4c762ca9">&#9670;&nbsp;</a></span>Is() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_exception_wrapper.html">ExceptionWrapper</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for exception wrapper types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="acee9d8d508655e22b36687e5a76886db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee9d8d508655e22b36687e5a76886db">&#9670;&nbsp;</a></span>Is() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for nullable types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="acc5379415d39f2faa77f0a862ea720e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5379415d39f2faa77f0a862ea720e5">&#9670;&nbsp;</a></span>Is() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value &amp;&amp; detail::has_operator_equal&lt;T&gt;::value, bool &gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for boxable types with == operator defined. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="a8b69b932b7d71a3cd26b8e506c8c6de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b69b932b7d71a3cd26b8e506c8c6de7">&#9670;&nbsp;</a></span>Is() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt; <a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value &amp;&amp; !detail::has_operator_equal&lt;T&gt;::value, bool &gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for boxable types without defined ==. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="a6a5d3e14d184a87bdc1a4ebd3f76655c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a5d3e14d184a87bdc1a4ebd3f76655c">&#9670;&nbsp;</a></span>Is() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_enum&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for enum types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="a4d98ab8c89ef061c4594aa61c2c3d4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d98ab8c89ef061c4594aa61c2c3d4c7">&#9670;&nbsp;</a></span>Is() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_enum&lt;T&gt;::value, bool&gt;::type System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for enum types vs weak pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for 'is' operator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="a42212f76edcd834ffb08b2388b2dee63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42212f76edcd834ffb08b2388b2dee63">&#9670;&nbsp;</a></span>Is() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool System::ObjectExt::Is </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements 'is' operator translation. Specialization for <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Target type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'is' returns true, false otherwise. </dd></dl>

</div>
</div>
<a id="a6a9d22662302a4edf430ba3cc7536424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a9d22662302a4edf430ba3cc7536424">&#9670;&nbsp;</a></span>IsBoxedValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ASPOSECPP_SHARED_API bool System::ObjectExt::IsBoxedValue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if object is a boxed value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to test for being boxed value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>obj</code> is a boxed value, false otherwise. </dd></dl>

</div>
</div>
<a id="a31495e6d8ed761eb33e0f53abcfc46ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31495e6d8ed761eb33e0f53abcfc46ed">&#9670;&nbsp;</a></span>ObjectToUnknown() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, T&gt;::type System::ObjectExt::ObjectToUnknown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to unknown type, handling both smart pointer type and bpxed value situations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either unboxed value or converted pointer. </dd></dl>

</div>
</div>
<a id="a3bf7825f7a366300f2413e0576a61631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf7825f7a366300f2413e0576a61631">&#9670;&nbsp;</a></span>ObjectToUnknown() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, T&gt;::type System::ObjectExt::ObjectToUnknown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to unknown type, handling both smart pointer type and boxed value situations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either unboxed value or converted pointer. </dd></dl>

</div>
</div>
<a id="a02a47581b14b298ef9da890fb37918da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a47581b14b298ef9da890fb37918da">&#9670;&nbsp;</a></span>ToString() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_system_1_1_string.html">String</a> System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">const char_t *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> literal to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="adb22bf85b79ad7730f7aca725ae959f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb22bf85b79ad7730f7aca725ae959f0">&#9670;&nbsp;</a></span>ToString() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_system_1_1_string.html">String</a> System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="a1aa7b9f131b6f192454915bd0fb6019f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa7b9f131b6f192454915bd0fb6019f">&#9670;&nbsp;</a></span>ToString() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_enum&lt;T&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="struct_system_1_1_enum.html" title="Provides methods that perform some operations on values of enum type. This is a static type with no i...">Enum</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="struct_system_1_1_enum.html" title="Provides methods that perform some operations on values of enum type. This is a static type with no i...">Enum</a> value to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="a92ad494118cc5b1fff421605b4896665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ad494118cc5b1fff421605b4896665">&#9670;&nbsp;</a></span>ToString() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Smart pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> value to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="a896a0422afa5db270187afebc0be5744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896a0422afa5db270187afebc0be5744">&#9670;&nbsp;</a></span>ToString() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value || std::is_pointer&lt;T&gt;::value || <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Smart pointer type or <a class="el" href="class_system_1_1_exception_wrapper.html" title="Template that represents wrapper of exceptions that are derived from Exception class. ">ExceptionWrapper</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Smart pointer or <a class="el" href="class_system_1_1_exception_wrapper.html" title="Template that represents wrapper of exceptions that are derived from Exception class. ">ExceptionWrapper</a> to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="a0682cdf3abcdc9d8e94bd92d3513ce9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0682cdf3abcdc9d8e94bd92d3513ce9e">&#9670;&nbsp;</a></span>ToString() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; std::is_scalar&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Scalar value to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="a43d9617b5d564872e82ea43219ec7434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43d9617b5d564872e82ea43219ec7434">&#9670;&nbsp;</a></span>ToString() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; std::is_scalar&lt;T&gt;::value &amp;&amp; !std::is_enum&lt;T&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Scalar value to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="ae6962046fcc6a9961ba139ae96812420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6962046fcc6a9961ba139ae96812420">&#9670;&nbsp;</a></span>ToString() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; !std::is_scalar&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Structure type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Structure value to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="accf3fb6e53532ecb3cfe7e71ecef76d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf3fb6e53532ecb3cfe7e71ecef76d6">&#9670;&nbsp;</a></span>ToString() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; !std::is_scalar&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Structure type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Structure value to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="a1afa396da62ca6b0a755921006c6936d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afa396da62ca6b0a755921006c6936d">&#9670;&nbsp;</a></span>ToString() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; !std::is_scalar&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value &amp;&amp; !std::is_reference&lt;T&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::ObjectExt::ToString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Substitution for C# ToString method to work on any C++ type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Scalar type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Scalar value to convert to string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of <code>obj</code>. </dd></dl>

</div>
</div>
<a id="a023ec6df6bf0aa6c399cbd82f68dfb6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023ec6df6bf0aa6c399cbd82f68dfb6f">&#9670;&nbsp;</a></span>Unbox() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_enum&lt;T&gt;::value, T&gt;::type System::ObjectExt::Unbox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unboxes value types after converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for enum types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="struct_system_1_1_enum.html" title="Provides methods that perform some operations on values of enum type. This is a static type with no i...">Enum</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to unbox. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_system_1_1_enum.html" title="Provides methods that perform some operations on values of enum type. This is a static type with no i...">Enum</a> value. </dd></dl>

</div>
</div>
<a id="a4e7fb742074d0321f488de426b22cbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e7fb742074d0321f488de426b22cbb0">&#9670;&nbsp;</a></span>Unbox() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!std::is_enum&lt;T&gt;::value &amp;&amp; detail::has_operator_equal&lt;T&gt;::value, T&gt;::type System::ObjectExt::Unbox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unboxes value types after converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for non-enum &amp; non-nullable types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to unbox. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unboxed value. </dd></dl>

</div>
</div>
<a id="adc8ecee4a4d4ffdf1cfc0cedd38457b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8ecee4a4d4ffdf1cfc0cedd38457b5">&#9670;&nbsp;</a></span>Unbox() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!std::is_enum&lt;T&gt;::value &amp;&amp; !detail::has_operator_equal&lt;T&gt;::value, T&gt;::type System::ObjectExt::Unbox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unboxes value types after converting to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. Implementation for non-enum &amp; non-nullable types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to unbox. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unboxed value. </dd></dl>

</div>
</div>
<a id="a5a929a80f83df453b3f65a1227d6d6ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a929a80f83df453b3f65a1227d6d6ef">&#9670;&nbsp;</a></span>Unbox() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_enum&lt;E&gt;::value &amp;&amp; std::numeric_limits&lt;T&gt;::is_integer, T&gt;::type System::ObjectExt::Unbox </td>
          <td>(</td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unboxes enum types to integer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Destination integer type. </td></tr>
    <tr><td class="paramname">E</td><td>Source enum type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Value to unbox. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer representation of enum. </dd></dl>

</div>
</div>
<a id="ac3a355ccf651b9c222f754c450c39b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3a355ccf651b9c222f754c450c39b0a">&#9670;&nbsp;</a></span>Unbox() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_enum&lt;E&gt;::value &amp;&amp; std::is_enum&lt;T&gt;::value, T&gt;::type System::ObjectExt::Unbox </td>
          <td>(</td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts enum types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Destination enum type. </td></tr>
    <tr><td class="paramname">E</td><td>Source enum type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>Value to unbox. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Converted enum value. </dd></dl>

</div>
</div>
<a id="a5ea417154034a572b4f76419047dbad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea417154034a572b4f76419047dbad0">&#9670;&nbsp;</a></span>Unbox() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_string.html">String</a> System::ObjectExt::Unbox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unboxes string values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to unbox </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> representation of boxed string, can be null if boxed string was null. </dd></dl>

</div>
</div>
<a id="ab25d74c06b5a5358709f8a686cfb5704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25d74c06b5a5358709f8a686cfb5704">&#9670;&nbsp;</a></span>UnboxStringSafe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static ASPOSECPP_SHARED_API <a class="el" href="class_system_1_1_string.html">String</a> System::ObjectExt::UnboxStringSafe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unboxes string from boxed value. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Nothing.</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Boxed string value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If <code>obj</code> is a boxed string, returns unboxed value, otherwise returns empty string. </dd></dl>

</div>
</div>
<a id="a29cc615475a61710c0f66a75996a826a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29cc615475a61710c0f66a75996a826a">&#9670;&nbsp;</a></span>UnboxToNullable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt;T&gt; System::ObjectExt::UnboxToNullable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>safe</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unboxes object to nullable type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Destination type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to unbox. </td></tr>
    <tr><td class="paramname">safe</td><td>If true, return nullptr on failure, otherwise throw InvalidCastException. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unboxed nullable value (could be null). </dd></dl>

</div>
</div>
<a id="adc4050a2ce3c7c37f252dab5e95971b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4050a2ce3c7c37f252dab5e95971b9">&#9670;&nbsp;</a></span>UnknownIsNull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!std::is_scalar&lt;T&gt;::value, bool&gt;::type System::ObjectExt::UnknownIsNull </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether unknown type object is nullptr. Overload for non-scalar types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if 'obj == nullptr' is true, false otherwise. </dd></dl>

</div>
</div>
<a id="a8bd4bfbe9c9879dde2e5e167eb8a642d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd4bfbe9c9879dde2e5e167eb8a642d">&#9670;&nbsp;</a></span>UnknownIsNull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;std::is_scalar&lt;T&gt;::value, bool&gt;::type System::ObjectExt::UnknownIsNull </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks whether unknown type object is nullptr. Overload for scalar types. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Always returns false. </dd></dl>

</div>
</div>
<a id="a1091aa12d47816759617c01886ba3b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1091aa12d47816759617c01886ba3b3f">&#9670;&nbsp;</a></span>UnknownToObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">Object</a>&gt; &gt;::type System::ObjectExt::UnknownToObject </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts unknown type to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>, handling both smart pointer type and value type situations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> being either converted pointer or boxed value. </dd></dl>

</div>
</div>
<a id="a5fc835218949ce3d15404737c80e08f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fc835218949ce3d15404737c80e08f7">&#9670;&nbsp;</a></span>UnknownToObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">Object</a>&gt; &gt;::type System::ObjectExt::UnknownToObject </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts unknown type to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>, handling both smart pointer type and value type situations. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to convert to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> being either converted pointer or boxed value. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_system.html">System</a></li><li class="navelem"><a class="el" href="class_system_1_1_object_ext.html">ObjectExt</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
