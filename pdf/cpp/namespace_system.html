<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aspose.PDF for C++: System Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Aspose.PDF for C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespace_system.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">System Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_system_1_1_boxed_value_detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_boxed_value_detail.html">BoxedValueDetail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_collections"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_collections.html">Collections</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_component_model"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_component_model.html">ComponentModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_constraints"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_constraints.html">Constraints</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_data"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_data.html">Data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_diagnostics"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_diagnostics.html">Diagnostics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_drawing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_drawing.html">Drawing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_globalization"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_globalization.html">Globalization</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_i_o"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_i_o.html">IO</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_linq"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_linq.html">Linq</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_net"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_net.html">Net</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_reflection"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_reflection.html">Reflection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_resources"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_resources.html">Resources</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_runtime"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_runtime.html">Runtime</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_security"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_security.html">Security</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_string_extra"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_string_extra.html">StringExtra</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_test_predicates"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_test_predicates.html">TestPredicates</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_text"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_text.html">Text</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_threading"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_threading.html">Threading</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_timers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_timers.html">Timers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_type_code_helper"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_type_code_helper.html">TypeCodeHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_uri_details"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_uri_details.html">UriDetails</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_web"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_web.html">Web</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_windows"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_windows.html">Windows</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_with_lambda"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_with_lambda.html">WithLambda</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_system_1_1_xml"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system_1_1_xml.html">Xml</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_any_types_match.html">AnyTypesMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any of argument types match (via std::is_same).  <a href="struct_system_1_1_any_types_match.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_any_types_match_3_01_first_type_00_01_second_type_00_01_other_types_8_8_8_01_4.html">AnyTypesMatch&lt; FirstType, SecondType, OtherTypes... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if any of argument types match (via std::is_same).  <a href="struct_system_1_1_any_types_match_3_01_first_type_00_01_second_type_00_01_other_types_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_any_types_match_3_01_last_type_01_4.html">AnyTypesMatch&lt; LastType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to terminate the recursion.  <a href="struct_system_1_1_any_types_match_3_01_last_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that represents an array data structure. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#a2c2bd56f01b6de1c99ecfdb0aa076190" title="A factory function that constructs a new Array object, fills it with the elements from the specified ...">System::MakeArray()</a> and <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> functions. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_array_segment.html">ArraySegment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a segment of the one-dimensional array. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_array_segment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>AsposeCppLibrary</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents Asposecpplib library and contains library initialization/uninitialization methods. This is a static type with no instance services. You should never create instances of it by any means. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for custom attributes. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_base_pointer_type.html">BasePointerType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides base (without weak smell) pointer type for specific type.  <a href="struct_system_1_1_base_pointer_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_base_pointer_type_3_01_weak_ptr_3_01_t_01_4_01_4.html">BasePointerType&lt; WeakPtr&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides base (without weak smell) pointer type for specific type.  <a href="struct_system_1_1_base_pointer_type_3_01_weak_ptr_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_base_types_info.html">BaseTypesInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_base_types_info_3_01_first_type_00_01_base_types_8_8_8_01_4.html">BaseTypesInfo&lt; FirstType, BaseTypes... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a template static method that determines if the specified object is an instance of the specified type or of a type that is descendant of the specifid type.  <a href="class_system_1_1_base_types_info_3_01_first_type_00_01_base_types_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_base_types_info_3_4.html">BaseTypesInfo&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of an instance of a type that has no parent types.  <a href="class_system_1_1_base_types_info_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_bit_converter.html">BitConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods that perform conversions of sequence of bytes to a value type and vice-versa. This is a static type with no instance services. You should never create instances of it by any means.  <a href="class_system_1_1_bit_converter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boolean.html">Boolean</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that keeps static members of <a class="el" href="class_system_1_1_boolean.html" title="Class that keeps static members of System.Boolean .Net type. ">System.Boolean</a> .<a class="el" href="namespace_system_1_1_net.html">Net</a> type.  <a href="class_system_1_1_boolean.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_enum.html">BoxedEnum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents boxed enumeration value. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_boxed_enum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value.html">BoxedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boxed value. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_boxed_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value_3_01_system_1_1_collections_1_1_generic_1_1_key_value_pair_3_01_t_key_00_01_t_value_01_4_01_4.html">BoxedValue&lt; System::Collections::Generic::KeyValuePair&lt; TKey, TValue &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_boxed_value.html" title="Represents a boxed value. Objects of this class should only be allocated using System::MakeObject() f...">BoxedValue</a> implementation for KeyValueType.  <a href="class_system_1_1_boxed_value_3_01_system_1_1_collections_1_1_generic_1_1_key_value_pair_3_01_t_key_00_01_t_value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_color_01_4.html">BoxedValue&lt; System::Drawing::Color &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boxed value of <a class="el" href="class_system_1_1_drawing_1_1_color.html" title="Represents a color. This type should be allocated on stack and passed to functions by value or by ref...">System::Drawing::Color</a> type.  <a href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_color_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_point_01_4.html">BoxedValue&lt; System::Drawing::Point &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boxed value of <a class="el" href="class_system_1_1_drawing_1_1_point.html" title="Represents a pair of integer X and Y coordinates of a point on a 2-dimensional plane. This type should be allocated on stack and passed to functions by value or by reference. Never use System::SmartPtr class to manage objects of this type. ">System::Drawing::Point</a> type.  <a href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_point_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_point_f_01_4.html">BoxedValue&lt; System::Drawing::PointF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boxed value of <a class="el" href="class_system_1_1_drawing_1_1_point_f.html" title="Represents a pair of single-precision floating point X and Y coordinates of a point on a 2-dimensiona...">System::Drawing::PointF</a> type.  <a href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_point_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_rectangle_01_4.html">BoxedValue&lt; System::Drawing::Rectangle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boxed value of <a class="el" href="class_system_1_1_drawing_1_1_rectangle.html" title="Represents a rectangular area of an image defined as integer X and Y coordinates of its upper left co...">System::Drawing::Rectangle</a> type.  <a href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_rectangle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_rectangle_f_01_4.html">BoxedValue&lt; System::Drawing::RectangleF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boxed value of <a class="el" href="class_system_1_1_drawing_1_1_rectangle_f.html" title="Represents a rectangular area of an image defined as single-precision floating point X and Y coordina...">System::Drawing::RectangleF</a> type.  <a href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_rectangle_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_size_01_4.html">BoxedValue&lt; System::Drawing::Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boxed value of <a class="el" href="class_system_1_1_drawing_1_1_size.html" title="Represents a pair of integer values that represent width and height of an image. This type should be ...">System::Drawing::Size</a> type.  <a href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_size_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_size_f_01_4.html">BoxedValue&lt; System::Drawing::SizeF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a boxed value of <a class="el" href="class_system_1_1_drawing_1_1_size_f.html" title="Represents a pair of single-precision floating point values that represent width and height of an ima...">System::Drawing::SizeF</a> type.  <a href="class_system_1_1_boxed_value_3_01_system_1_1_drawing_1_1_size_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_boxed_value_base.html">BoxedValueBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class that defines an interface and implements some fundamental methods of a descendant class that represents a boxed value. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_boxed_value_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_buffer.html">Buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods that manipulate raw byte arrays. This is a static type with no instance services. You should never create instances of it by any means.  <a href="class_system_1_1_buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_byte.html">Byte</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the unsigned 8-bit integer.  <a href="class_system_1_1_byte.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declatation of <a class="el" href="struct_system_1_1_cast_result.html" title="Forward declatation of CastResult used by System::StaticCast, System::DynamicCast and alike functions...">CastResult</a> used by <a class="el" href="namespace_system.html#aec55c703d291b84ff94ef32ac954ed14" title="Performs static cast on SmartPtr objects. ">System::StaticCast</a>, <a class="el" href="namespace_system.html#a65f75c58083a9f099cf712e70ab2328a" title="Performs dynamic cast on Exception objects. ">System::DynamicCast</a> and alike functions.  <a href="struct_system_1_1_cast_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_cast_result_3_01_array_3_01_t_to_01_4_01_4.html">CastResult&lt; Array&lt; TTo &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes sure that conversion (StaticCast, DynamicCast, etc.) to array pointer return ArrayPtr, not naked <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a>.  <a href="struct_system_1_1_cast_result_3_01_array_3_01_t_to_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_cast_result_3_01_multicast_delegate_3_01_t_01_4_01_4.html">CastResult&lt; MulticastDelegate&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="struct_system_1_1_cast_result.html" title="Forward declatation of CastResult used by System::StaticCast, System::DynamicCast and alike functions...">CastResult</a> structure making sure MulticastResult remains value type instead of wrapping it into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a>.  <a href="struct_system_1_1_cast_result_3_01_multicast_delegate_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_cast_result_3_01_string_01_4.html">CastResult&lt; String &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="struct_system_1_1_cast_result.html" title="Forward declatation of CastResult used by System::StaticCast, System::DynamicCast and alike functions...">CastResult</a> for case of casting to string.  <a href="struct_system_1_1_cast_result_3_01_string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_char.html">Char</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides methods for manipulation of characters represented as UTF-16 code units. This is a static type with no instance services. You should never create instances of it by any means.  <a href="class_system_1_1_char.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_collection_assert_helper.html">CollectionAssertHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Heler API for collection-related operations.  <a href="struct_system_1_1_collection_assert_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_comparison.html">Comparison</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pointer to the method that compares two objects of the same type. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_comparison.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_console.html">Console</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides methods for outputting data to the standard output stream. This is a static type with no instance services. You should never create instances of it by any means.  <a href="class_system_1_1_console.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_console_output.html">ConsoleOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the standard output stream. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_console_output.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_convert.html">Convert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure that contains methods performing conversion of values of one type to the values of another type. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="struct_system_1_1_convert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_date_time.html">DateTime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a specific date and time value on the time continuum. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_date_time.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains the date and time of day relative to Coordinated Universal Time. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_date_time_offset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_d_b_null.html">DBNull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a non-existing value. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_d_b_null.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_decimal.html">Decimal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a decimal number. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_decimal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_default_boxed_value.html">DefaultBoxedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_boxed_value.html" title="Represents a boxed value. Objects of this class should only be allocated using System::MakeObject() f...">BoxedValue</a> class implementation. Allows it BoxingValue specializations to be declared without duplicating common code. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_default_boxed_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_delegate.html">Delegate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_delegate_3_01_return_type_07_argument_types_8_8_8_08_4.html">Delegate&lt; ReturnType(ArgumentTypes...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pointer to a function, method or a function object. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_delegate_3_01_return_type_07_argument_types_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_ApplicationException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_ArgumentException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_ArgumentOutOfRangeException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_ArithmeticException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_BadImageFormatException</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The exception that is thrown when the file image of a dynamic link library (DLL) or an executable program is invalid. Never create instances of this class manually. Use the BadImageFormatException class instead. Never wrap the BadImageFormatException class instances into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_DivideByZeroException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_Exception</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an exception. Never create instances of this class manually. Use the Exception class instead. Never wrap the Exception class instances into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_ExceptionWithErrorCode</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template class for an exception with an error code. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_ExceptionWithFilename</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The template class for an exception with a file name. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_ExecutionEngineException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_FormatException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_IndexOutOfRangeException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_InvalidCastException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_InvalidOperationException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_InvalidProgramException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_InvalidTimeZoneException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_MemberAccessException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_MethodAccessException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_NotImplementedException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_NotSupportedException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_NullReferenceException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_ObjectDisposedException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_OperationCanceledException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_OverflowException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_PlatformNotSupportedException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_RankException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_StackOverflowException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_SystemException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_TimeoutException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_TimeZoneNotFoundException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_UnauthorizedAccessException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>Details_UriFormatException</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_double.html">Double</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the double-precision floating-point number.  <a href="struct_system_1_1_double.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_dynamic_weak_ptr.html">DynamicWeakPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer class which tracks pointer modes of template arguments of stored object and updates them after each assignment. This type is a pointer to manage other object's deletion. It should be allocated on stack and passed to functions either by value or by const reference.  <a href="class_system_1_1_dynamic_weak_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_empty_array_initializer.html">EmptyArrayInitializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_enum.html">Enum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides methods that perform some operations on values of enum type. This is a static type with no instance services. You should never create instances of it by any means.  <a href="struct_system_1_1_enum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_enum_get_name_helper.html">EnumGetNameHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that provides functionality of geting the strting name of enum constant.  <a href="struct_system_1_1_enum_get_name_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>EnumGetNameHelper&lt; E, G, typename EnumMetaInfo&lt; E &gt;::Flags &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <code>Guard</code> = EnumMetaInfo&lt;E&gt;::Flags. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_enum_parse_helper.html">EnumParseHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class that provides functionality of converting a string representation of enum consnant into equivalent enum value.  <a href="struct_system_1_1_enum_parse_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>EnumParseHelper&lt; E, G, typename EnumMetaInfo&lt; E &gt;::Flags &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for <code>Guard</code> = EnumMetaInfo&lt;E&gt;::Flags. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_enum_values.html">EnumValues</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides meta information about enumeration constants of enum type <code>E</code>.  <a href="class_system_1_1_enum_values.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_enum_values_base.html">EnumValuesBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for a class that represents meta information of enumeration type.  <a href="class_system_1_1_enum_values_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_environment.html">Environment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_system_1_1_environment.html" title="Environment services. This is a static type with no instance services. You should never create instan...">Environment</a> services. This is a static type with no instance services. You should never create instances of it by any means.  <a href="struct_system_1_1_environment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_event_args.html">EventArgs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for classes that represent a context that is passed to the event subscribers when an event is triggered. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_event_args.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_event_handler.html">EventHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a method that reacts to and processes an event. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_event_handler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_exception_wrapper.html">ExceptionWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template that represents wrapper of exceptions that are derived from Exception class.  <a href="class_system_1_1_exception_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><b>ExceptionWrapper&lt; Details_Exception &gt;</b></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class specialization for Exception class. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_exception_wrapper_base.html">ExceptionWrapperBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base exception class that implements logic for correct exception handling Contains smart pointer to exception instance.  <a href="class_system_1_1_exception_wrapper_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_exception_wrapper_helper.html">ExceptionWrapperHelper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class to workaround gcc compile time error, that prevents to see private BaseType aslias even when <a class="el" href="class_system_1_1_exception_wrapper.html" title="Template that represents wrapper of exceptions that are derived from Exception class. ">ExceptionWrapper</a> is declared as a friend class of Exception.  <a href="class_system_1_1_exception_wrapper_helper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_exception_wrapper_type.html">ExceptionWrapperType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_func.html">Func</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function delegate. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_func.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_g_c.html">GC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an emulated Garbage Collection which acts more like a stub which effectively does nothing. This is a static type with no instance services. You should never create instances of it by any means.  <a href="class_system_1_1_g_c.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_guid.html">Guid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a Globally Unique IDentifier This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_guid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_async_result.html">IAsyncResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the status of asynchronous operation. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_i_async_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_cloneable.html">ICloneable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defies a method that enables object cloning - creating a copy of an object. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_i_cloneable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_comparable.html">IComparable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a method that compares two objects. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_i_comparable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_convertible.html">IConvertible</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines methods that convert the value of the implementing reference or value type to a common language runtime type that has an equivalent value. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_i_convertible.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_custom_formatter.html">ICustomFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a method that performs custom formatting of a string representation of a value represented by the specified object. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_i_custom_formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_disposable.html">IDisposable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines method that releases resources owned by the current object. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_i_disposable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_enumerable_adapter.html">IEnumerableAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter to use IEnumerable in STL-like iterations. Used by NUnit TestCaseSource attribute translation.  <a href="class_system_1_1_i_enumerable_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_enumerable_default_adapter.html">IEnumerableDefaultAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter to use IEnumerable in STL-like iterations. Used by NUnit TestCaseSource attribute translation.  <a href="class_system_1_1_i_enumerable_default_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_enumerable_tuple_adapter.html">IEnumerableTupleAdapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter to use IEnumerable in STL-like iterations. Used by NUnit TestCaseSource attribute translation.  <a href="class_system_1_1_i_enumerable_tuple_adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_enumerator_iterator.html">IEnumeratorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapter to use IEnumerator in STL-like iterations. Used by NUnit TestCaseSource attribute translation.  <a href="class_system_1_1_i_enumerator_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_equatable.html">IEquatable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a method that determines the equality of two objects. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_i_equatable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_format_provider.html">IFormatProvider</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a method that provides formatting information. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_i_format_provider.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_i_formattable.html">IFormattable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a method that formats the value of the current object using the specified format string and format provider.  <a href="class_system_1_1_i_formattable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_int16.html">Int16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the 16-bit integer.  <a href="class_system_1_1_int16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_int32.html">Int32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the 32-bit integer.  <a href="class_system_1_1_int32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_int64.html">Int64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the 64-bit integer.  <a href="class_system_1_1_int64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable.html">IsBoxable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template predicate that checks if boxing of the specified type is supported.  <a href="struct_system_1_1_is_boxable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_collections_1_1_generic_1_1_key_value_pair_3_01_t_key_00_01_t_value_01_4_01_4.html">IsBoxable&lt; Collections::Generic::KeyValuePair&lt; TKey, TValue &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks KeyValuePair as boxable type.  <a href="struct_system_1_1_is_boxable_3_01_collections_1_1_generic_1_1_key_value_pair_3_01_t_key_00_01_t_value_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_date_time_01_4.html">IsBoxable&lt; DateTime &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsBoxable&lt;T&gt; specialization for <a class="el" href="class_system_1_1_date_time.html" title="Represents a specific date and time value on the time continuum. This type should be allocated on sta...">DateTime</a>.  <a href="struct_system_1_1_is_boxable_3_01_date_time_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_date_time_offset_01_4.html">IsBoxable&lt; DateTimeOffset &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsBoxable&lt;T&gt; specialization for <a class="el" href="class_system_1_1_date_time_offset.html" title="Contains the date and time of day relative to Coordinated Universal Time. Objects of this class shoul...">DateTimeOffset</a>.  <a href="struct_system_1_1_is_boxable_3_01_date_time_offset_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_decimal_01_4.html">IsBoxable&lt; Decimal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsBoxable&lt;T&gt; specialization for <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a>.  <a href="struct_system_1_1_is_boxable_3_01_decimal_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_drawing_1_1_color_01_4.html">IsBoxable&lt; Drawing::Color &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate that determines if <a class="el" href="class_system_1_1_drawing_1_1_color.html" title="Represents a color. This type should be allocated on stack and passed to functions by value or by ref...">System::Drawing::Color</a> class is boxable.  <a href="struct_system_1_1_is_boxable_3_01_drawing_1_1_color_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_drawing_1_1_point_01_4.html">IsBoxable&lt; Drawing::Point &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate that determines if <a class="el" href="class_system_1_1_drawing_1_1_point.html" title="Represents a pair of integer X and Y coordinates of a point on a 2-dimensional plane. This type should be allocated on stack and passed to functions by value or by reference. Never use System::SmartPtr class to manage objects of this type. ">Drawing::Point</a> class is boxable.  <a href="struct_system_1_1_is_boxable_3_01_drawing_1_1_point_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_drawing_1_1_point_f_01_4.html">IsBoxable&lt; Drawing::PointF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate that determines if <a class="el" href="class_system_1_1_drawing_1_1_point_f.html" title="Represents a pair of single-precision floating point X and Y coordinates of a point on a 2-dimensiona...">Drawing::PointF</a> class is boxable.  <a href="struct_system_1_1_is_boxable_3_01_drawing_1_1_point_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_drawing_1_1_rectangle_01_4.html">IsBoxable&lt; Drawing::Rectangle &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate that determines if <a class="el" href="class_system_1_1_drawing_1_1_rectangle.html" title="Represents a rectangular area of an image defined as integer X and Y coordinates of its upper left co...">System::Drawing::Rectangle</a> class is boxable.  <a href="struct_system_1_1_is_boxable_3_01_drawing_1_1_rectangle_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_drawing_1_1_rectangle_f_01_4.html">IsBoxable&lt; Drawing::RectangleF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate that determines if <a class="el" href="class_system_1_1_drawing_1_1_rectangle_f.html" title="Represents a rectangular area of an image defined as single-precision floating point X and Y coordina...">System::Drawing::RectangleF</a> class is boxable.  <a href="struct_system_1_1_is_boxable_3_01_drawing_1_1_rectangle_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_drawing_1_1_size_01_4.html">IsBoxable&lt; Drawing::Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate that determines if <a class="el" href="class_system_1_1_drawing_1_1_size.html" title="Represents a pair of integer values that represent width and height of an image. This type should be ...">Drawing::Size</a> class is boxable.  <a href="struct_system_1_1_is_boxable_3_01_drawing_1_1_size_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_drawing_1_1_size_f_01_4.html">IsBoxable&lt; Drawing::SizeF &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate that determines if <a class="el" href="class_system_1_1_drawing_1_1_size_f.html" title="Represents a pair of single-precision floating point values that represent width and height of an ima...">Drawing::SizeF</a> class is boxable.  <a href="struct_system_1_1_is_boxable_3_01_drawing_1_1_size_f_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_guid_01_4.html">IsBoxable&lt; Guid &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsBoxable&lt;T&gt; specialization for <a class="el" href="class_system_1_1_guid.html" title="Represents a Globally Unique IDentifier This type should be allocated on stack and passed to function...">Guid</a>.  <a href="struct_system_1_1_is_boxable_3_01_guid_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_nullable_3_01_t_01_4_01_4.html">IsBoxable&lt; Nullable&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsBoxable&lt;T&gt; specialization for <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a>.  <a href="struct_system_1_1_is_boxable_3_01_nullable_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_string_01_4.html">IsBoxable&lt; String &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsBoxable&lt;T&gt; specialization for <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a>.  <a href="struct_system_1_1_is_boxable_3_01_string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_system_1_1_security_1_1_cryptography_1_1_hash_algorithm_name_01_4.html">IsBoxable&lt; System::Security::Cryptography::HashAlgorithmName &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsBoxable&lt;T&gt; specialization for HashAlgorithmName.  <a href="struct_system_1_1_is_boxable_3_01_system_1_1_security_1_1_cryptography_1_1_hash_algorithm_name_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_time_span_01_4.html">IsBoxable&lt; TimeSpan &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsBoxable&lt;T&gt; specialization for <a class="el" href="class_system_1_1_time_span.html" title="Represents a time interval. This type should be allocated on stack and passed to functions by value o...">TimeSpan</a>.  <a href="struct_system_1_1_is_boxable_3_01_time_span_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxable_3_01_value_type_01_4.html">IsBoxable&lt; ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">IsBoxable&lt;T&gt; specialization for <a class="el" href="class_system_1_1_value_type.html" title="Baseclass for value types with Object inheritance being truncated for performance reasons...">ValueType</a>.  <a href="struct_system_1_1_is_boxable_3_01_value_type_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxed_value.html">IsBoxedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate the specifed type is <a class="el" href="class_system_1_1_boxed_value.html" title="Represents a boxed value. Objects of this class should only be allocated using System::MakeObject() f...">BoxedValue</a> class.  <a href="struct_system_1_1_is_boxed_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_boxed_value_3_01_boxed_value_3_01_t_01_4_01_4.html">IsBoxedValue&lt; BoxedValue&lt; T &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate the specifed type <code>T</code> is <a class="el" href="class_system_1_1_boxed_value.html" title="Represents a boxed value. Objects of this class should only be allocated using System::MakeObject() f...">BoxedValue</a> class.  <a href="struct_system_1_1_is_boxed_value_3_01_boxed_value_3_01_t_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate that determines if the specified type is a Exception class or its descendant.  <a href="struct_system_1_1_is_exception_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_non_const_string_array.html">IsNonConstStringArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template magic to check if a type is a non-const character array.  <a href="struct_system_1_1_is_non_const_string_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template predicate that determines if its template argument T in <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> or its subclass.  <a href="struct_system_1_1_is_nullable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait class to check if a type is a specialization of <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class.  <a href="struct_system_1_1_is_smart_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_string_byte_sequence.html">IsStringByteSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template magic to check if a type is a sequence of string characters.  <a href="struct_system_1_1_is_string_byte_sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_string_literal.html">IsStringLiteral</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template magic to check if a type is a string literal.  <a href="struct_system_1_1_is_string_literal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_string_pointer.html">IsStringPointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template magic to check if a type is a pointer to character string.  <a href="struct_system_1_1_is_string_pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_is_weak_ptr.html">IsWeakPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits class to check if specific class is a specialization of <a class="el" href="class_system_1_1_weak_ptr.html" title="Subclass of System::SmartPtr which sets itself to weak mode at construction. Please note that this cl...">System::WeakPtr</a>. Doesn't check if instance is actually in weak mode.  <a href="struct_system_1_1_is_weak_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_lock_context.html">LockContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guard object implementing C# lock() statement.  <a href="class_system_1_1_lock_context.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_make_const_ref.html">MakeConstRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait to make generic type "const reference" if it is <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> or a SmartPtr&lt;&gt; type.  <a href="struct_system_1_1_make_const_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_marshal_by_ref_object.html">MarshalByRefObject</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to objects across application domain boundaries in remoting-enabled applications. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_marshal_by_ref_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_math.html">Math</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains math functions. This is a static type with no instance services. You should never create instances of it by any means.  <a href="struct_system_1_1_math.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_method_argument_tuple.html">MethodArgumentTuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines tuple to store method arguments.  <a href="struct_system_1_1_method_argument_tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_method_argument_tuple_3_01_r_07_5_08_07_args_8_8_8_08_4.html">MethodArgumentTuple&lt; R(*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines tuple to store method arguments.  <a href="struct_system_1_1_method_argument_tuple_3_01_r_07_5_08_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_method_argument_tuple_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01_4.html">MethodArgumentTuple&lt; R(C::*)(Args...) const &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines tuple to store method arguments.  <a href="struct_system_1_1_method_argument_tuple_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_01const_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_method_argument_tuple_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_4.html">MethodArgumentTuple&lt; R(C::*)(Args...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines tuple to store method arguments.  <a href="struct_system_1_1_method_argument_tuple_3_01_r_07_c_1_1_5_08_07_args_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_multicast_delegate_3_01_return_type_07_argument_types_8_8_8_08_4.html">MulticastDelegate&lt; ReturnType(ArgumentTypes...)&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a collection of delegates. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_multicast_delegate_3_01_return_type_07_argument_types_8_8_8_08_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_multicast_delegate_type_info.html">MulticastDelegateTypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pointer to <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> object that contains information about <a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a> class.  <a href="struct_system_1_1_multicast_delegate_type_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_nullable.html">Nullable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="class_system_1_1_nullable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_object.html">Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class that enables using methods available for <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">System.Object</a> class in C#. All non-trivial classes used with ported environment should inherit it.  <a href="class_system_1_1_object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_object_ext.html">ObjectExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides static methods that emulate C# <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> methods called for non-Object C++ types (strings, numbers, etc.). This is a static type with no instance services. You should never create instances of it by any means.  <a href="class_system_1_1_object_ext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_operating_system.html">OperatingSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a particular operating system and provides information about it. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_operating_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_random.html">Random</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pseudo-random number generator. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_random.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_remove_shared.html">RemoveShared</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait structs to remove SharedPtr/WeakPtr from argument type.  <a href="struct_system_1_1_remove_shared.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_remove_shared_3_01_system_1_1_shared_ptr_3_01_x_01_4_01_4.html">RemoveShared&lt; System::SharedPtr&lt; X &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_remove_shared_3_01_system_1_1_weak_ptr_3_01_x_01_4_01_4.html">RemoveShared&lt; System::WeakPtr&lt; X &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_s_byte.html">SByte</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the 8-bit integer.  <a href="struct_system_1_1_s_byte.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_scoped_culture.html">ScopedCulture</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a culture used within the scope.  <a href="class_system_1_1_scoped_culture.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_scope_guard.html">ScopeGuard</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The service class that provides services for running a particular function object when an instance of the class goes out of scope.  <a href="struct_system_1_1_scope_guard.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_single.html">Single</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the single-precision floating-point number.  <a href="struct_system_1_1_single.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>. This pointer type follows intrusive pointer semantics. Reference counter is stored either in <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> itself or in counter structure which is tied to <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> instance tightly. In any case, all <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> instances form single ownership group regardless how they were created which is unlike how std::shared_ptr class behaves. Converting raw pointer to <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> is safe given there are other <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> instances holding shared references to the same object. <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class instance can be in one of two states: shared pointer and weak pointer. To keep object alive, one should have count of shared references to it positive. Both weak and shared pointers can be used to access pointed object (to call methods, read or write fields, etc.), but weak pointers do not participate to shared pointer reference counting. <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> is being deleted when the last 'shared' <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointer to it is being destroyed. So, make sure that this doesn't happen when no other shared <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointers to object exist, e. g. during object construction or destruction. Use System::Object::ThisProtector sentry objects (in C++ code) or CppCTORSelfReference or CppSelfReference attribute (in C# code being ported) to fix this issue. Similarily, make sure to break loop references by using <a class="el" href="class_system_1_1_weak_ptr.html" title="Subclass of System::SmartPtr which sets itself to weak mode at construction. Please note that this cl...">System::WeakPtr</a> pointer class or <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45a7324e3727807d95037eb19d304fd91ec" title="Weak mode: pointer does not participate in reference counting. ">System::SmartPtrMode::Weak</a> pointer mode (in C++ code) or CppWeakPtr attribute (in C# code being ported). If two or more objects reference each other using 'shared' pointers, they will never be deleted. If pointer type (weak or shared) should be switched in runtime, use <a class="el" href="class_system_1_1_smart_ptr.html#a385f3f04c1c03af17ba1488e6610756f" title="Sets pointer mode. May alter referenced object&#39;s reference counts. ">System::SmartPtr&lt;T&gt;::set_Mode()</a> method or <a class="el" href="class_system_1_1_dynamic_weak_ptr.html" title="Smart pointer class which tracks pointer modes of template arguments of stored object and updates the...">System::DynamicWeakPtr</a> class. <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> class doesn't contain any virtual methods. You should only inherit it if you're creating a memory management strategy of your own. This type is a pointer to manage other object's deletion. It should be allocated on stack and passed to functions either by value or by const reference.  <a href="class_system_1_1_smart_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_smart_ptr_info.html">SmartPtrInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service class to test and alter <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a>'s contents without knowing final type. Used for garbage collection and loop references detection, etc. Think of it as of 'pointer to pointer'. We can't use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a>'s basetype as it doesn't have any; instead, we use this 'info' class.  <a href="class_system_1_1_smart_ptr_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_string.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> class used across the library. Is a substitute for C# <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">System.String</a> when porting code. For optimization reasons, isn't considered an <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> subclass. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_string_comparer.html">StringComparer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares strings using different comparison modes. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_string_comparer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_string_hash_compiletime.html">StringHashCompiletime</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A helper class that generates a hash value from a c-string.  <a href="class_system_1_1_string_hash_compiletime.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_string_hash_compiletime_3_010_01_4.html">StringHashCompiletime&lt; 0 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for the empty string.  <a href="class_system_1_1_string_hash_compiletime_3_010_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_test_compare.html">TestCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service structure providing interface to compare collections.  <a href="struct_system_1_1_test_compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_test_tools.html">TestTools</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a set of useful methods that check some basic properties of different types and functions.  <a href="struct_system_1_1_test_tools.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_test_tools_ext.html">TestToolsExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common functions to be used by testing translation.  <a href="struct_system_1_1_test_tools_ext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a time interval. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_time_span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_time_zone.html">TimeZone</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a time zone. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_time_zone.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_time_zone_info.html">TimeZoneInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an information destribing a particular time zone. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_time_zone_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_tuple.html">Tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that represents a tuple data structure. Maximum number of items is 8.  <a href="class_system_1_1_tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_tuple_factory.html">TupleFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides static methods for creating tuple objects.  <a href="class_system_1_1_tuple_factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_type_info.html">TypeInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a particular type and provides information about it.  <a href="class_system_1_1_type_info.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_type_info_ptr.html">TypeInfoPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper for a pointer to an instance of <a class="el" href="class_system_1_1_type_info.html" title="Represents a particular type and provides information about it. ">TypeInfo</a> class. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="struct_system_1_1_type_info_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_u_int16.html">UInt16</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the unsigned 16-bit integer.  <a href="struct_system_1_1_u_int16.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_u_int32.html">UInt32</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the unsigned 32-bit integer.  <a href="struct_system_1_1_u_int32.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_u_int64.html">UInt64</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains methods to work with the unsigned 64-bit integer.  <a href="struct_system_1_1_u_int64.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_uri.html">Uri</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unified resource identifier. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_uri.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_uri_builder.html">UriBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides methods to construct and modify universial resource identifiers (URIs). Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_uri_builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_uri_parser.html">UriParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to parse a new URI scheme. Objects of this class should only be allocated using <a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216" title="Creates object on heap and returns shared pointer to it. ">System::MakeObject()</a> function. Never create instance of this type on stack or using operator new, as it will result in runtime errors and/or assertion faults. Always wrap this class into <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> pointer and use this pointer to pass it to functions as argument.  <a href="class_system_1_1_uri_parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_uri_shim.html">UriShim</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Service class.  <a href="class_system_1_1_uri_shim.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_value_type.html">ValueType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Baseclass for value types with <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> inheritance being truncated for performance reasons. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_value_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a version number. This type should be allocated on stack and passed to functions by value or by reference. Never use <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> class to manage objects of this type.  <a href="class_system_1_1_version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclass of <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">System::SmartPtr</a> which sets itself to weak mode at construction. Please note that this class doesn't guarantee that its instance will always remain in weak mode as <a class="el" href="class_system_1_1_smart_ptr.html#a385f3f04c1c03af17ba1488e6610756f" title="Sets pointer mode. May alter referenced object&#39;s reference counts. ">set_Mode()</a> is still accessible. This type is a pointer to manage other object's deletion. It should be allocated on stack and passed to functions either by value or by const reference.  <a href="class_system_1_1_weak_ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_system_1_1_weak_ptr_from_type_parameter.html">WeakPtrFromTypeParameter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trait struct to convert argument type to a weak-pointer, if it is a pointer type.  <a href="struct_system_1_1_weak_ptr_from_type_parameter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_system_1_1_weak_reference.html">WeakReference</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a weak reference, which references an object while still allowing that object to be deleted.  <a href="class_system_1_1_weak_reference.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3f3d657a11c3e78524f9f79ed53b3613"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a3f3d657a11c3e78524f9f79ed53b3613"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a3f3d657a11c3e78524f9f79ed53b3613">Action</a> = <a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a>&lt; void(Args...)&gt;</td></tr>
<tr class="memdesc:a3f3d657a11c3e78524f9f79ed53b3613"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_delegate.html">Delegate</a> type that references methods that have no return value.  <a href="#a3f3d657a11c3e78524f9f79ed53b3613">More...</a><br /></td></tr>
<tr class="separator:a3f3d657a11c3e78524f9f79ed53b3613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3211d2c7d1759df54dfdd31e7864f9e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">System::ArrayPtr</a>&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aa3211d2c7d1759df54dfdd31e7864f9e">ByteArrayPtr</a></td></tr>
<tr class="memdesc:aa3211d2c7d1759df54dfdd31e7864f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a smart pointer object that points to an array of unsigned 8-bit integers.  <a href="#aa3211d2c7d1759df54dfdd31e7864f9e">More...</a><br /></td></tr>
<tr class="separator:aa3211d2c7d1759df54dfdd31e7864f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cf1de8550dc36dade4fe2e6973352f"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(<a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_i_async_result.html">IAsyncResult</a> &gt;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a83cf1de8550dc36dade4fe2e6973352f">AsyncCallback</a></td></tr>
<tr class="memdesc:a83cf1de8550dc36dade4fe2e6973352f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A delegate type that represents a method to be called when asynchronous operation completes.  <a href="#a83cf1de8550dc36dade4fe2e6973352f">More...</a><br /></td></tr>
<tr class="separator:a83cf1de8550dc36dade4fe2e6973352f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9213610fe96fa2de18ddf8fe2e609781"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a9213610fe96fa2de18ddf8fe2e609781">BadImageFormatException</a> = <a class="el" href="class_system_1_1_exception_wrapper.html">System::ExceptionWrapper</a>&lt; Details_BadImageFormatException &gt;</td></tr>
<tr class="separator:a9213610fe96fa2de18ddf8fe2e609781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4ab0c5d3fe818e7743aad10db99e85"><td class="memTemplParams" colspan="2">template&lt;class TInput , class TOutput &gt; </td></tr>
<tr class="memitem:a4a4ab0c5d3fe818e7743aad10db99e85"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a4a4ab0c5d3fe818e7743aad10db99e85">Converter</a> = <a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a>&lt; TOutput(TInput)&gt;</td></tr>
<tr class="memdesc:a4a4ab0c5d3fe818e7743aad10db99e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pointer to the invokable entity that accepts a single argument of the <code>TInput</code> type and returns a value of the <code>TOutput</code> type.  <a href="#a4a4ab0c5d3fe818e7743aad10db99e85">More...</a><br /></td></tr>
<tr class="separator:a4a4ab0c5d3fe818e7743aad10db99e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6857d54ffc0b9e249ee01285ae0d4b1"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:ab6857d54ffc0b9e249ee01285ae0d4b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ab6857d54ffc0b9e249ee01285ae0d4b1">Event</a> = <a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a>&lt; Args... &gt;</td></tr>
<tr class="memdesc:ab6857d54ffc0b9e249ee01285ae0d4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an event - a mechanism through which subscribers are notified about an occurence of interest by means of a delegate invocation.  <a href="#ab6857d54ffc0b9e249ee01285ae0d4b1">More...</a><br /></td></tr>
<tr class="separator:ab6857d54ffc0b9e249ee01285ae0d4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa85b02b5bcc423df7223e8c069f6343"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_event_args.html">EventArgs</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aaa85b02b5bcc423df7223e8c069f6343">EventArgsPtr</a></td></tr>
<tr class="memdesc:aaa85b02b5bcc423df7223e8c069f6343"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to an instance of <a class="el" href="class_system_1_1_event_args.html" title="The base class for classes that represent a context that is passed to the event subscribers when an e...">EventArgs</a> class.  <a href="#aaa85b02b5bcc423df7223e8c069f6343">More...</a><br /></td></tr>
<tr class="separator:aaa85b02b5bcc423df7223e8c069f6343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cae75235e593702e499d067fd574583"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5cae75235e593702e499d067fd574583">ExceptionPtr</a> = <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Details_Exception &gt;</td></tr>
<tr class="memdesc:a5cae75235e593702e499d067fd574583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias used by exception wrappers.  <a href="#a5cae75235e593702e499d067fd574583">More...</a><br /></td></tr>
<tr class="separator:a5cae75235e593702e499d067fd574583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ac70ce5544cf54b67cc546c2dc19aa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#af2ac70ce5544cf54b67cc546c2dc19aa">Exception</a> = <a class="el" href="class_system_1_1_exception_wrapper.html">ExceptionWrapper</a>&lt; Details_Exception &gt;</td></tr>
<tr class="memdesc:af2ac70ce5544cf54b67cc546c2dc19aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias to be used instead of Details::Exception.  <a href="#af2ac70ce5544cf54b67cc546c2dc19aa">More...</a><br /></td></tr>
<tr class="separator:af2ac70ce5544cf54b67cc546c2dc19aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f96fca81fe94f559178a54a644171bb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_i_async_result.html">IAsyncResult</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a6f96fca81fe94f559178a54a644171bb">IAsyncResultPtr</a></td></tr>
<tr class="memdesc:a6f96fca81fe94f559178a54a644171bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to <a class="el" href="class_system_1_1_i_async_result.html" title="Represents the status of asynchronous operation. Objects of this class should only be allocated using...">IAsyncResult</a>.  <a href="#a6f96fca81fe94f559178a54a644171bb">More...</a><br /></td></tr>
<tr class="separator:a6f96fca81fe94f559178a54a644171bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618f1e74006853eaf440c1128a7133d5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a618f1e74006853eaf440c1128a7133d5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a618f1e74006853eaf440c1128a7133d5">Predicate</a> = <a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a>&lt; bool(T)&gt;</td></tr>
<tr class="memdesc:a618f1e74006853eaf440c1128a7133d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a pointer to a predicate - an invokable entity that accepts a single argument and returns a bool value.  <a href="#a618f1e74006853eaf440c1128a7133d5">More...</a><br /></td></tr>
<tr class="separator:a618f1e74006853eaf440c1128a7133d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64e8d7c8f13f967748bdd283b4062425"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a64e8d7c8f13f967748bdd283b4062425"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">ArrayPtr</a> = <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:a64e8d7c8f13f967748bdd283b4062425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for 'pointer to array' type.  <a href="#a64e8d7c8f13f967748bdd283b4062425">More...</a><br /></td></tr>
<tr class="separator:a64e8d7c8f13f967748bdd283b4062425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b77ccd8c49df28c153be0462cdfdf49"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6b77ccd8c49df28c153be0462cdfdf49"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a> = <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a6b77ccd8c49df28c153be0462cdfdf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for smart pointer widely used in the library.  <a href="#a6b77ccd8c49df28c153be0462cdfdf49">More...</a><br /></td></tr>
<tr class="separator:a6b77ccd8c49df28c153be0462cdfdf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a587c830e7b2dc7043be3f751ddd3b47c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_string_comparer.html">StringComparer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a587c830e7b2dc7043be3f751ddd3b47c">StringComparerPtr</a></td></tr>
<tr class="memdesc:a587c830e7b2dc7043be3f751ddd3b47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An alias for a shared pointer to an instance of <a class="el" href="class_system_1_1_string_comparer.html" title="Compares strings using different comparison modes. Objects of this class should only be allocated usi...">StringComparer</a> class.  <a href="#a587c830e7b2dc7043be3f751ddd3b47c">More...</a><br /></td></tr>
<tr class="separator:a587c830e7b2dc7043be3f751ddd3b47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853bbfff9b63ef02809167a7e18a960f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_time_zone.html">TimeZone</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a853bbfff9b63ef02809167a7e18a960f">TimeZonePtr</a></td></tr>
<tr class="memdesc:a853bbfff9b63ef02809167a7e18a960f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shared pointer to an instance of <a class="el" href="class_system_1_1_time_zone.html" title="Represents a time zone. Objects of this class should only be allocated using System::MakeObject() fun...">TimeZone</a> class.  <a href="#a853bbfff9b63ef02809167a7e18a960f">More...</a><br /></td></tr>
<tr class="separator:a853bbfff9b63ef02809167a7e18a960f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe5c3c1c0dfaa917aedf42360a7e8d4d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_time_zone_info.html">TimeZoneInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#abe5c3c1c0dfaa917aedf42360a7e8d4d">TimeZoneInfoPtr</a></td></tr>
<tr class="memdesc:abe5c3c1c0dfaa917aedf42360a7e8d4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for shared pointer to an instance of <a class="el" href="class_system_1_1_time_zone_info.html" title="Represents an information destribing a particular time zone. Objects of this class should only be all...">TimeZoneInfo</a> class.  <a href="#abe5c3c1c0dfaa917aedf42360a7e8d4d">More...</a><br /></td></tr>
<tr class="separator:abe5c3c1c0dfaa917aedf42360a7e8d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a5f571893cc464ceee12eff1139802e49"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5f571893cc464ceee12eff1139802e49">Base64FormattingOptions</a> { <a class="el" href="namespace_system.html#a5f571893cc464ceee12eff1139802e49a6adf97f83acf6453d4a6a4b1070f3754">Base64FormattingOptions::None</a> = 0, 
<a class="el" href="namespace_system.html#a5f571893cc464ceee12eff1139802e49a5bc3970c9f349fd7400f63ed6fe33fd2">Base64FormattingOptions::InsertLineBreaks</a> = 1
 }<tr class="memdesc:a5f571893cc464ceee12eff1139802e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration containing values that represent different formats of base-64 encoded data.  <a href="namespace_system.html#a5f571893cc464ceee12eff1139802e49">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a5f571893cc464ceee12eff1139802e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8ee95b3f7f3b42eb282688dffa6d2e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a2a8ee95b3f7f3b42eb282688dffa6d2e">DateTimeKind</a> { <a class="el" href="namespace_system.html#a2a8ee95b3f7f3b42eb282688dffa6d2ea6fcdc090caeade09d0efd6253932b6f5">DateTimeKind::Unspecified</a>, 
<a class="el" href="namespace_system.html#a2a8ee95b3f7f3b42eb282688dffa6d2ea2211d2dd79ba751bdc41551b05d1f807">DateTimeKind::Utc</a>, 
<a class="el" href="namespace_system.html#a2a8ee95b3f7f3b42eb282688dffa6d2ea509820290d57f333403f490dde7316f4">DateTimeKind::Local</a>
 }<tr class="memdesc:a2a8ee95b3f7f3b42eb282688dffa6d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration values of which represent the kinds of date and time.  <a href="namespace_system.html#a2a8ee95b3f7f3b42eb282688dffa6d2e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a2a8ee95b3f7f3b42eb282688dffa6d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f2b5f31e3f2582c6cfbcc24721a58a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58a">DayOfWeek</a> : int { <br />
&#160;&#160;<a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58aa9d1a0949c39e66a0cd65240bc0ac9177">DayOfWeek::Sunday</a> = 0, 
<a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58aa6f8522e0610541f1ef215a22ffa66ff6">DayOfWeek::Monday</a>, 
<a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58aa5792315f09a5d54fb7e3d066672b507f">DayOfWeek::Tuesday</a>, 
<a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58aa796c163589f295373e171842f37265d5">DayOfWeek::Wednesday</a>, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58aa78ae6f0cd191d25147e252dc54768238">DayOfWeek::Thursday</a>, 
<a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58aac33b138a163847cdb6caeeb7c9a126b4">DayOfWeek::Friday</a>, 
<a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58aa8b7051187b9191cdcdae6ed5a10e5adc">DayOfWeek::Saturday</a>
<br />
 }<tr class="memdesc:ad8f2b5f31e3f2582c6cfbcc24721a58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration that represents a day of week.  <a href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58a">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad8f2b5f31e3f2582c6cfbcc24721a58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aaeca0f6b610199eb45e4225aaf726e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1aaeca0f6b610199eb45e4225aaf726e">EnvironmentVariableTarget</a> { <a class="el" href="namespace_system.html#a1aaeca0f6b610199eb45e4225aaf726ea00430157e2152ce173a65ce6fcda7c44">Process</a> = 0, 
<a class="el" href="namespace_system.html#a1aaeca0f6b610199eb45e4225aaf726eab83533cb42f3e42bbf07740bc6b03e6a">User</a> = 1, 
<a class="el" href="namespace_system.html#a1aaeca0f6b610199eb45e4225aaf726ead9f12bb0041cd9d3c7c46af4f5df96fe">Machine</a> = 2
 }<tr class="memdesc:a1aaeca0f6b610199eb45e4225aaf726e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the environment variable location.  <a href="namespace_system.html#a1aaeca0f6b610199eb45e4225aaf726e">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a1aaeca0f6b610199eb45e4225aaf726e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942f422fde8ecb1591803551f6fbe9b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a942f422fde8ecb1591803551f6fbe9b6">MidpointRounding</a> { <a class="el" href="namespace_system.html#a942f422fde8ecb1591803551f6fbe9b6a0c424e67e4f66bfe87bf561e57f476f4">MidpointRounding::ToEven</a>, 
<a class="el" href="namespace_system.html#a942f422fde8ecb1591803551f6fbe9b6ab0bc5021588a7dbd6cae8ef3c5655e34">MidpointRounding::AwayFromZero</a>
 }<tr class="memdesc:a942f422fde8ecb1591803551f6fbe9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies the behavior of rounding functions.  <a href="namespace_system.html#a942f422fde8ecb1591803551f6fbe9b6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a942f422fde8ecb1591803551f6fbe9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9326d04561ea76c1b9ed2866512bce58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58">PlatformID</a> { <br />
&#160;&#160;<a class="el" href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58afc4a8e0b5dc39c9d2d7da8fd535e1577">PlatformID::Win32S</a> = 0, 
<a class="el" href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58ab54554c4e92d4e0ac2d8fc3e7990db43">PlatformID::Win32Windows</a> = 1, 
<a class="el" href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58a933e15f3f3a407b683b4afbbaf3f739f">PlatformID::Win32NT</a> = 2, 
<a class="el" href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58a2f2ae2d3dcd8c5db65671da871bbb6fa">PlatformID::WinCE</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58a6ec1bd1ea6a5d67a63b20c8f6172bddd">PlatformID::Unix</a> = 4, 
<a class="el" href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58a183709ebe3a1d675014d32b94ad7ed94">PlatformID::Xbox</a> = 5, 
<a class="el" href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58a5dad7f6f2d7af4cc1196128ec251af8a">PlatformID::MacOSX</a> = 6
<br />
 }<tr class="memdesc:a9326d04561ea76c1b9ed2866512bce58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an operating system platform.  <a href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a9326d04561ea76c1b9ed2866512bce58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30773bd5724c6b5016dc1a39a4930d45"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">SmartPtrMode</a> : char { <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca">SmartPtrMode::Shared</a>, 
<a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45a7324e3727807d95037eb19d304fd91ec">SmartPtrMode::Weak</a>
 }<tr class="memdesc:a30773bd5724c6b5016dc1a39a4930d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">SmartPtr pointer type: weak or shared. Defines whether pointer is being counted when it is being decided whether to delete object or not.  <a href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a30773bd5724c6b5016dc1a39a4930d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac018be9308f77dea81689cca46b1fcf2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#ac018be9308f77dea81689cca46b1fcf2">StringSplitOptions</a> { <a class="el" href="namespace_system.html#ac018be9308f77dea81689cca46b1fcf2a6adf97f83acf6453d4a6a4b1070f3754">StringSplitOptions::None</a> = 0, 
<a class="el" href="namespace_system.html#ac018be9308f77dea81689cca46b1fcf2af848693a8ba86ca7d0888ce5a78d3966">StringSplitOptions::RemoveEmptyEntries</a> = 1
 }<tr class="memdesc:ac018be9308f77dea81689cca46b1fcf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines string splitting behavior.  <a href="namespace_system.html#ac018be9308f77dea81689cca46b1fcf2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ac018be9308f77dea81689cca46b1fcf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e11f229dc342b9c5a5cf4880e3df19d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a6e11f229dc342b9c5a5cf4880e3df19d">StringComparison</a> { <br />
&#160;&#160;<a class="el" href="namespace_system.html#a6e11f229dc342b9c5a5cf4880e3df19da470d47ad82f123fdb894af7608993b45">StringComparison::CurrentCulture</a> = 0, 
<a class="el" href="namespace_system.html#a6e11f229dc342b9c5a5cf4880e3df19dad306e48ebb497be8a47a18f3512bb2be">StringComparison::CurrentCultureIgnoreCase</a> = 1, 
<a class="el" href="namespace_system.html#a6e11f229dc342b9c5a5cf4880e3df19da1cafd57afeb525ed0ea44f6e768e6d50">StringComparison::InvariantCulture</a> = 2, 
<a class="el" href="namespace_system.html#a6e11f229dc342b9c5a5cf4880e3df19da49ba78bea2e6420746a32ee1644f498a">StringComparison::InvariantCultureIgnoreCase</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#a6e11f229dc342b9c5a5cf4880e3df19dac9d539922221d77591558b5841d36fd1">StringComparison::Ordinal</a> = 4, 
<a class="el" href="namespace_system.html#a6e11f229dc342b9c5a5cf4880e3df19da8ed060eed16572703403fdbcdbf65e32">StringComparison::OrdinalIgnoreCase</a> = 5
<br />
 }<tr class="memdesc:a6e11f229dc342b9c5a5cf4880e3df19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines string comparison style.  <a href="namespace_system.html#a6e11f229dc342b9c5a5cf4880e3df19d">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6e11f229dc342b9c5a5cf4880e3df19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48979d2322a6e265fc61c924c8e40863"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863">TypeCode</a> { <br />
&#160;&#160;<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863ace2c8aed9c2fa0cfbed56cbda4d8bf07">TypeCode::Empty</a> = 0, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a497031794414a552435f90151ac3b54b">TypeCode::Object</a> = 1, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a87bb9cdb34f638ec3ac651a887f3e747">TypeCode::DBNull</a> = 2, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a27226c864bac7454a8504f8edb15d95b">TypeCode::Boolean</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a8e95e84813830072b7516cfaa7dbc1a9">TypeCode::Char</a> = 4, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a7e76fb67fc7b4cb0004bc45f2bd92723">TypeCode::SByte</a> = 5, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863aa245c3230debe5c956484ecc6fa93877">TypeCode::Byte</a> = 6, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a39bc2ae44b184207f560ff8619823208">TypeCode::Int16</a> = 7, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a8bd950a9d7779b83f5c30046c9aaf1cf">TypeCode::UInt16</a> = 8, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863ac06129f6e6e15c09328365e553f1dc31">TypeCode::Int32</a> = 9, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863ae7956ed7be1c5025a27ed3cb42a396bd">TypeCode::UInt32</a> = 10, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863afbde23b11d7e59af7828e81144c8b487">TypeCode::Int64</a> = 11, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863aaf71234725f0470ccf993e263a8b820a">TypeCode::UInt64</a> = 12, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a66ba162102bbf6ae31b522aec561735e">TypeCode::Single</a> = 13, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863ad909d38d705ce75386dd86e611a82f5b">TypeCode::Double</a> = 14, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a937504f318f04eaf0f1d701df4c4d7f3">TypeCode::Decimal</a> = 15, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a8cf10d2341ed01492506085688270c1e">TypeCode::DateTime</a> = 16, 
<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863a27118326006d3829667a400ad23d5d98">TypeCode::String</a> = 18
<br />
 }<tr class="memdesc:a48979d2322a6e265fc61c924c8e40863"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of an object.  <a href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a48979d2322a6e265fc61c924c8e40863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a548a7575f15cb0b2cebd21081f9b25b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a548a7575f15cb0b2cebd21081f9b25b6">UriKind</a> { <a class="el" href="namespace_system.html#a548a7575f15cb0b2cebd21081f9b25b6ac5e69ef1c75727c4665f4611a3465eab">UriKind::RelativeOrAbsolute</a> = 0, 
<a class="el" href="namespace_system.html#a548a7575f15cb0b2cebd21081f9b25b6ab51ca26c6c89cfc9bec338f7a0d3e0c8">UriKind::Absolute</a> = 1, 
<a class="el" href="namespace_system.html#a548a7575f15cb0b2cebd21081f9b25b6a2ca9469819fb0fb61ff98e914a7ccca0">UriKind::Relative</a> = 2
 }<tr class="memdesc:a548a7575f15cb0b2cebd21081f9b25b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the kinds of URIs.  <a href="namespace_system.html#a548a7575f15cb0b2cebd21081f9b25b6">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a548a7575f15cb0b2cebd21081f9b25b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9931ba346cf7e3bdcdfdba5c5cf4e13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13">UriComponents</a> { <br />
&#160;&#160;<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13a827452688eed02a12178e96f924ac529">UriComponents::Scheme</a> = 0x1, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13a21d23644baa10e1eba75fdd29e179288">UriComponents::UserInfo</a> = 0x2, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13ac2ca16d048ec66e04bca283eab048ec2">UriComponents::Host</a> = 0x4, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13a60aaf44d4b562252c04db7f98497e9aa">UriComponents::Port</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13abaafc686ded2377660b91aa4833943f6">UriComponents::SchemeAndServer</a> = Scheme | Host | Port, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13aac70412e939d72a9234cdebb1af5867b">UriComponents::Path</a> = 0x10, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13a66c1b4c7f3dc385b68a9fa903ccd016d">UriComponents::Query</a> = 0x20, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13ac1f15304a1e513e2feb761f690f77b26">UriComponents::PathAndQuery</a> = Path | Query, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13a21a8e46f676e60bb73c1c34a8071b48a">UriComponents::HttpRequestUrl</a> = Scheme | Host | Port | Path | Query, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13a37d01b98065725fe3a1d30acf3a0064a">UriComponents::Fragment</a> = 0x40, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13a77ac1c528ff49cd0bc9be07c1185aaee">UriComponents::AbsoluteUri</a> = Scheme | UserInfo | Host | Port | Path | Query | Fragment, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13adedb207fd8a720b080f08c2116d2c4d9">UriComponents::StrongPort</a> = 0x80, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13a5518dcdf898b72b153f016e7393d462d">UriComponents::HostAndPort</a> = Host | StrongPort, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13ad024b548ee6d8d9067874f413f85c6b8">UriComponents::StrongAuthority</a> = UserInfo | Host | StrongPort, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13a7bdf45907e3cecba3cc9eab322267abf">UriComponents::NormalizedHost</a> = 0x100, 
<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13ad7199979e3d58410669da77a1d76599e">UriComponents::KeepDelimiter</a> = 0x40000000, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13afa646410dc281a96883e4ce1612f3062">UriComponents::SerializationInfoString</a> = static_cast&lt;int32_t&gt;(0x80000000)
<br />
 }<tr class="memdesc:af9931ba346cf7e3bdcdfdba5c5cf4e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents URI components.  <a href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af9931ba346cf7e3bdcdfdba5c5cf4e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefcae6e2818e910545a2713fd1c2fac"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#adefcae6e2818e910545a2713fd1c2fac">UriFormat</a> { <a class="el" href="namespace_system.html#adefcae6e2818e910545a2713fd1c2faca6580a27ae5e36f23c67a8f9727e7f653">UriFormat::UriEscaped</a> = 1, 
<a class="el" href="namespace_system.html#adefcae6e2818e910545a2713fd1c2facab048227579bc97486100c4ab806d33b9">UriFormat::Unescaped</a> = 2, 
<a class="el" href="namespace_system.html#adefcae6e2818e910545a2713fd1c2facaecdddc4dd0fc27bfb60fe28833f1b500">UriFormat::SafeUnescaped</a> = 3
 }<tr class="memdesc:adefcae6e2818e910545a2713fd1c2fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how the URI is escaped.  <a href="namespace_system.html#adefcae6e2818e910545a2713fd1c2fac">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:adefcae6e2818e910545a2713fd1c2fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca29ba7cb1b9f1dbd4147235c04e5178"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aca29ba7cb1b9f1dbd4147235c04e5178">UriHostNameType</a> { <br />
&#160;&#160;<a class="el" href="namespace_system.html#aca29ba7cb1b9f1dbd4147235c04e5178a88183b946cc5f0e8c96b2e66e1c74a7e">UriHostNameType::Unknown</a> = 0, 
<a class="el" href="namespace_system.html#aca29ba7cb1b9f1dbd4147235c04e5178a972e73b7a882d0802a4e3a16946a2f94">UriHostNameType::Basic</a> = 1, 
<a class="el" href="namespace_system.html#aca29ba7cb1b9f1dbd4147235c04e5178a4d3cc87f77cb704db96a7dc499206433">UriHostNameType::Dns</a> = 2, 
<a class="el" href="namespace_system.html#aca29ba7cb1b9f1dbd4147235c04e5178a42a9137a05a60eb752dcdf982e717626">UriHostNameType::IPv4</a> = 3, 
<br />
&#160;&#160;<a class="el" href="namespace_system.html#aca29ba7cb1b9f1dbd4147235c04e5178afdb7cb8f657426e7c409bfd6d1a36ce4">UriHostNameType::IPv6</a> = 4
<br />
 }<tr class="memdesc:aca29ba7cb1b9f1dbd4147235c04e5178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the type of host name.  <a href="namespace_system.html#aca29ba7cb1b9f1dbd4147235c04e5178">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aca29ba7cb1b9f1dbd4147235c04e5178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad24c40188222f4a76da525fce7f607d1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad24c40188222f4a76da525fce7f607d1">UriPartial</a> { <a class="el" href="namespace_system.html#ad24c40188222f4a76da525fce7f607d1a827452688eed02a12178e96f924ac529">UriPartial::Scheme</a> = 0, 
<a class="el" href="namespace_system.html#ad24c40188222f4a76da525fce7f607d1a60f1a22c0e577712dfd7ff055183e4ad">UriPartial::Authority</a> = 1, 
<a class="el" href="namespace_system.html#ad24c40188222f4a76da525fce7f607d1aac70412e939d72a9234cdebb1af5867b">UriPartial::Path</a> = 2, 
<a class="el" href="namespace_system.html#ad24c40188222f4a76da525fce7f607d1a66c1b4c7f3dc385b68a9fa903ccd016d">UriPartial::Query</a> = 3
 }<tr class="memdesc:ad24c40188222f4a76da525fce7f607d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents the parts of a URI for the Uri.GetLeftPart method.  <a href="namespace_system.html#ad24c40188222f4a76da525fce7f607d1">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad24c40188222f4a76da525fce7f607d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2c2bd56f01b6de1c99ecfdb0aa076190"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c2bd56f01b6de1c99ecfdb0aa076190"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">ArrayPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a2c2bd56f01b6de1c99ecfdb0aa076190">MakeArray</a> (std::initializer_list&lt; T &gt; init)</td></tr>
<tr class="memdesc:a2c2bd56f01b6de1c99ecfdb0aa076190"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function that constructs a new <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object, fills it with the elements from the specified initialization list and returns a smart pointer pointing to the <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object.  <a href="#a2c2bd56f01b6de1c99ecfdb0aa076190">More...</a><br /></td></tr>
<tr class="separator:a2c2bd56f01b6de1c99ecfdb0aa076190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef38b36d2b0a91df3d5b4326fc75340d"><td class="memTemplParams" colspan="2">template&lt;class T , class... Args&gt; </td></tr>
<tr class="memitem:aef38b36d2b0a91df3d5b4326fc75340d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">ArrayPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aef38b36d2b0a91df3d5b4326fc75340d">MakeArray</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aef38b36d2b0a91df3d5b4326fc75340d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function that constructs a new <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object passing the specified arguments to its constructor.  <a href="#aef38b36d2b0a91df3d5b4326fc75340d">More...</a><br /></td></tr>
<tr class="separator:aef38b36d2b0a91df3d5b4326fc75340d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37d34b60f1cc3cff03e0a0f3bfbf3a0"><td class="memTemplParams" colspan="2">template&lt;class T , class Integral , class... Args&gt; </td></tr>
<tr class="memitem:aa37d34b60f1cc3cff03e0a0f3bfbf3a0"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_integral&lt; Integral &gt;::value, <a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">ArrayPtr</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aa37d34b60f1cc3cff03e0a0f3bfbf3a0">MakeArray</a> (Integral size, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:aa37d34b60f1cc3cff03e0a0f3bfbf3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function that constructs a new <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object passing the specified arguments to its constructor.  <a href="#aa37d34b60f1cc3cff03e0a0f3bfbf3a0">More...</a><br /></td></tr>
<tr class="separator:aa37d34b60f1cc3cff03e0a0f3bfbf3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3b275a80034605a0034ba4e53ac85b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afd3b275a80034605a0034ba4e53ac85b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#afd3b275a80034605a0034ba4e53ac85b">operator==</a> (<a class="el" href="class_system_1_1_array_segment.html">ArraySegment</a>&lt; T &gt; a, <a class="el" href="class_system_1_1_array_segment.html">ArraySegment</a>&lt; T &gt; b)</td></tr>
<tr class="separator:afd3b275a80034605a0034ba4e53ac85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d20631216c584b44d430a4b99ae6bd8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d20631216c584b44d430a4b99ae6bd8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1d20631216c584b44d430a4b99ae6bd8">operator!=</a> (<a class="el" href="class_system_1_1_array_segment.html">ArraySegment</a>&lt; T &gt; a, <a class="el" href="class_system_1_1_array_segment.html">ArraySegment</a>&lt; T &gt; b)</td></tr>
<tr class="separator:a1d20631216c584b44d430a4b99ae6bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061e3d6cb50f1a228a3577ae21c994f7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a061e3d6cb50f1a228a3577ae21c994f7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a061e3d6cb50f1a228a3577ae21c994f7">IsEnumMetaInfoDefined</a> (T value)</td></tr>
<tr class="separator:a061e3d6cb50f1a228a3577ae21c994f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a53a4b39ee98df4e9dc1babdd12078"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a92a53a4b39ee98df4e9dc1babdd12078"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_system_1_1_string.html">System::String</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a92a53a4b39ee98df4e9dc1babdd12078">EnumGetName</a> (T value)</td></tr>
<tr class="separator:a92a53a4b39ee98df4e9dc1babdd12078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6619a906a7dceefbb2afd4306c6d2d14"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a6619a906a7dceefbb2afd4306c6d2d14">operator==</a> (std::nullptr_t, <a class="el" href="class_system_1_1_date_time.html">DateTime</a>)</td></tr>
<tr class="separator:a6619a906a7dceefbb2afd4306c6d2d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c6a55eec0f68556192042960c4974a5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a9c6a55eec0f68556192042960c4974a5">operator!=</a> (std::nullptr_t, <a class="el" href="class_system_1_1_date_time.html">DateTime</a>)</td></tr>
<tr class="separator:a9c6a55eec0f68556192042960c4974a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed9988f7fe49db96f7d7b601ceb247d9"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aed9988f7fe49db96f7d7b601ceb247d9">operator&lt;</a> (std::nullptr_t, <a class="el" href="class_system_1_1_date_time.html">DateTime</a>)</td></tr>
<tr class="separator:aed9988f7fe49db96f7d7b601ceb247d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03910ceff1e2bc8ed68d88b6024b629"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#af03910ceff1e2bc8ed68d88b6024b629">operator&lt;=</a> (std::nullptr_t, <a class="el" href="class_system_1_1_date_time.html">DateTime</a>)</td></tr>
<tr class="separator:af03910ceff1e2bc8ed68d88b6024b629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970cf4b21e945ee63aecc37362673e94"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a970cf4b21e945ee63aecc37362673e94">operator&gt;</a> (std::nullptr_t, <a class="el" href="class_system_1_1_date_time.html">DateTime</a>)</td></tr>
<tr class="separator:a970cf4b21e945ee63aecc37362673e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f0d62782434e0f9ff2b626c18d454f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#af3f0d62782434e0f9ff2b626c18d454f">operator&gt;=</a> (std::nullptr_t, <a class="el" href="class_system_1_1_date_time.html">DateTime</a>)</td></tr>
<tr class="separator:af3f0d62782434e0f9ff2b626c18d454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0896582818b18d4f140204d944d56ad8"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a0896582818b18d4f140204d944d56ad8">PrintTo</a> (<a class="el" href="class_system_1_1_date_time.html">DateTime</a> value, std::ostream *stream)</td></tr>
<tr class="memdesc:a0896582818b18d4f140204d944d56ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#a0896582818b18d4f140204d944d56ad8">More...</a><br /></td></tr>
<tr class="separator:a0896582818b18d4f140204d944d56ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af984d30faf96cdc931ea85ce4ee164c9"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#af984d30faf96cdc931ea85ce4ee164c9">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="class_system_1_1_date_time.html">DateTime</a> date_time)</td></tr>
<tr class="memdesc:af984d30faf96cdc931ea85ce4ee164c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#af984d30faf96cdc931ea85ce4ee164c9">More...</a><br /></td></tr>
<tr class="separator:af984d30faf96cdc931ea85ce4ee164c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc57fa0c68f8beb8fa64d139bf396ce"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aedc57fa0c68f8beb8fa64d139bf396ce">operator&lt;&lt;</a> (std::wostream &amp;stream, <a class="el" href="class_system_1_1_date_time.html">DateTime</a> date_time)</td></tr>
<tr class="memdesc:aedc57fa0c68f8beb8fa64d139bf396ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#aedc57fa0c68f8beb8fa64d139bf396ce">More...</a><br /></td></tr>
<tr class="separator:aedc57fa0c68f8beb8fa64d139bf396ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfee24836c1a18a537a758465e07573"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a3cfee24836c1a18a537a758465e07573">operator==</a> (std::nullptr_t, const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;)</td></tr>
<tr class="separator:a3cfee24836c1a18a537a758465e07573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2725bddced23204368544f0493ded4"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#adf2725bddced23204368544f0493ded4">operator!=</a> (std::nullptr_t, const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;)</td></tr>
<tr class="separator:adf2725bddced23204368544f0493ded4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7589a21fb562ffda17bc088dc54b1b"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1e7589a21fb562ffda17bc088dc54b1b">operator&lt;</a> (std::nullptr_t, const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;)</td></tr>
<tr class="separator:a1e7589a21fb562ffda17bc088dc54b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b56849915f206f0e91a05273b9af5fa"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a7b56849915f206f0e91a05273b9af5fa">operator&lt;=</a> (std::nullptr_t, const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;)</td></tr>
<tr class="separator:a7b56849915f206f0e91a05273b9af5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e40d265d5c7d0079448e1ae0c46513"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a60e40d265d5c7d0079448e1ae0c46513">operator&gt;</a> (std::nullptr_t, const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;)</td></tr>
<tr class="separator:a60e40d265d5c7d0079448e1ae0c46513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1e2117453263abf9df3fded9992090"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a9e1e2117453263abf9df3fded9992090">operator&gt;=</a> (std::nullptr_t, const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;)</td></tr>
<tr class="separator:a9e1e2117453263abf9df3fded9992090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008e02e26c0f9eefe6c4fde5afbd54ae"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a008e02e26c0f9eefe6c4fde5afbd54ae">PrintTo</a> (<a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> value, std::ostream *stream)</td></tr>
<tr class="memdesc:a008e02e26c0f9eefe6c4fde5afbd54ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#a008e02e26c0f9eefe6c4fde5afbd54ae">More...</a><br /></td></tr>
<tr class="separator:a008e02e26c0f9eefe6c4fde5afbd54ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60c4e89a51cab6665f52e98de7ce386"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#ae60c4e89a51cab6665f52e98de7ce386">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> value)</td></tr>
<tr class="memdesc:ae60c4e89a51cab6665f52e98de7ce386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#ae60c4e89a51cab6665f52e98de7ce386">More...</a><br /></td></tr>
<tr class="separator:ae60c4e89a51cab6665f52e98de7ce386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0e562f774803962af4619366e76e5a"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5d0e562f774803962af4619366e76e5a">operator&lt;&lt;</a> (std::wostream &amp;stream, <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> value)</td></tr>
<tr class="memdesc:a5d0e562f774803962af4619366e76e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#a5d0e562f774803962af4619366e76e5a">More...</a><br /></td></tr>
<tr class="separator:a5d0e562f774803962af4619366e76e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff7d92a82cab10d1a0d7b51ac0c6f06"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#abff7d92a82cab10d1a0d7b51ac0c6f06">operator-</a> (<a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58a">DayOfWeek</a> a, <a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58a">DayOfWeek</a> b)</td></tr>
<tr class="memdesc:abff7d92a82cab10d1a0d7b51ac0c6f06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the number of days between two days of week.  <a href="#abff7d92a82cab10d1a0d7b51ac0c6f06">More...</a><br /></td></tr>
<tr class="separator:abff7d92a82cab10d1a0d7b51ac0c6f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29657c7a3a1c7dd772de02adc9db5975"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a29657c7a3a1c7dd772de02adc9db5975">DECLARE_ENUM_OPERATORS</a> (<a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58a">System::DayOfWeek</a>)</td></tr>
<tr class="memdesc:a29657c7a3a1c7dd772de02adc9db5975"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of template arithmetic operators for values of the DayOfWeek enum type.  <a href="#a29657c7a3a1c7dd772de02adc9db5975">More...</a><br /></td></tr>
<tr class="separator:a29657c7a3a1c7dd772de02adc9db5975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2d242f5df66bdac582e2fdc0950261"><td class="memTemplParams" colspan="2">template&lt;typename T , typename _  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a2b2d242f5df66bdac582e2fdc0950261"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_decimal.html">Decimal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a2b2d242f5df66bdac582e2fdc0950261">operator+</a> (const T &amp;x, const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;d)</td></tr>
<tr class="memdesc:a2b2d242f5df66bdac582e2fdc0950261"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is a sum of the specified value and the value represented by the specified <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object.  <a href="#a2b2d242f5df66bdac582e2fdc0950261">More...</a><br /></td></tr>
<tr class="separator:a2b2d242f5df66bdac582e2fdc0950261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48af9f748c0c294991f6d2c546ab578a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename _  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a48af9f748c0c294991f6d2c546ab578a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_decimal.html">Decimal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a48af9f748c0c294991f6d2c546ab578a">operator-</a> (const T &amp;x, const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;d)</td></tr>
<tr class="memdesc:a48af9f748c0c294991f6d2c546ab578a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is the result of subtraction of the value represented by the specified <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object from the specified value.  <a href="#a48af9f748c0c294991f6d2c546ab578a">More...</a><br /></td></tr>
<tr class="separator:a48af9f748c0c294991f6d2c546ab578a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42212883ca01482c5e735522aa0b158"><td class="memTemplParams" colspan="2">template&lt;typename T , typename _  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ab42212883ca01482c5e735522aa0b158"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_decimal.html">Decimal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ab42212883ca01482c5e735522aa0b158">operator*</a> (const T &amp;x, const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;d)</td></tr>
<tr class="memdesc:ab42212883ca01482c5e735522aa0b158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is a result of multiplication of the specified value and the value represented by the specified <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object.  <a href="#ab42212883ca01482c5e735522aa0b158">More...</a><br /></td></tr>
<tr class="separator:ab42212883ca01482c5e735522aa0b158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f85e5e3fa771ce8078ca5aeffe97f94"><td class="memTemplParams" colspan="2">template&lt;typename T , typename _  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a3f85e5e3fa771ce8078ca5aeffe97f94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_decimal.html">Decimal</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a3f85e5e3fa771ce8078ca5aeffe97f94">operator/</a> (const T &amp;x, const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;d)</td></tr>
<tr class="memdesc:a3f85e5e3fa771ce8078ca5aeffe97f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is a result of division of the specified value and the value represented by the specified <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object.  <a href="#a3f85e5e3fa771ce8078ca5aeffe97f94">More...</a><br /></td></tr>
<tr class="separator:a3f85e5e3fa771ce8078ca5aeffe97f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef73dcfe21643d817a8431d20723bc69"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aef73dcfe21643d817a8431d20723bc69">PrintTo</a> (const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;d, ::std::ostream *os)</td></tr>
<tr class="memdesc:aef73dcfe21643d817a8431d20723bc69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the value represented by the specified object to the specified output stream.  <a href="#aef73dcfe21643d817a8431d20723bc69">More...</a><br /></td></tr>
<tr class="separator:aef73dcfe21643d817a8431d20723bc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316db243891f53cb92ef95efda695265"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a316db243891f53cb92ef95efda695265">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;decimal)</td></tr>
<tr class="memdesc:a316db243891f53cb92ef95efda695265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#a316db243891f53cb92ef95efda695265">More...</a><br /></td></tr>
<tr class="separator:a316db243891f53cb92ef95efda695265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e7671eb528e2967591bfe53cd5a04d"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad5e7671eb528e2967591bfe53cd5a04d">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;decimal)</td></tr>
<tr class="memdesc:ad5e7671eb528e2967591bfe53cd5a04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#ad5e7671eb528e2967591bfe53cd5a04d">More...</a><br /></td></tr>
<tr class="separator:ad5e7671eb528e2967591bfe53cd5a04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463a73466d9d7e1d18048ea49e89f08a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a463a73466d9d7e1d18048ea49e89f08a"><td class="memTemplItemLeft" align="right" valign="top">const std::enable_if&lt; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value, T &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a463a73466d9d7e1d18048ea49e89f08a">Default</a> ()</td></tr>
<tr class="memdesc:a463a73466d9d7e1d18048ea49e89f08a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default-constructed instance of the specified type.  <a href="#a463a73466d9d7e1d18048ea49e89f08a">More...</a><br /></td></tr>
<tr class="separator:a463a73466d9d7e1d18048ea49e89f08a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a245feaf217b8be306d77381a0b9f809d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a245feaf217b8be306d77381a0b9f809d"><td class="memTemplItemLeft" align="right" valign="top">const std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; T &gt;::value, T &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a245feaf217b8be306d77381a0b9f809d">Default</a> ()</td></tr>
<tr class="memdesc:a245feaf217b8be306d77381a0b9f809d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the default-constructed instance of the specified type.  <a href="#a245feaf217b8be306d77381a0b9f809d">More...</a><br /></td></tr>
<tr class="separator:a245feaf217b8be306d77381a0b9f809d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e949f5f9fa7dffbbd28dea430f21993"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a3e949f5f9fa7dffbbd28dea430f21993"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Details::is_lambda_void_void&lt; T &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a3e949f5f9fa7dffbbd28dea430f21993">DoTryFinally</a> (T &amp;&amp;tryBlock, F &amp;&amp;finallyBlock)</td></tr>
<tr class="memdesc:a3e949f5f9fa7dffbbd28dea430f21993"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sigle function that emulates behavior of C#'s try[-catch]-finally statement. During Porting of C#'s try[-catch]-finally statement with Porter's option finally_statement_as_lambda set to true, the statement is translated into the invocation of this method.  <a href="#a3e949f5f9fa7dffbbd28dea430f21993">More...</a><br /></td></tr>
<tr class="separator:a3e949f5f9fa7dffbbd28dea430f21993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3768c9651bfcdf2484f5bccbee320e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:afd3768c9651bfcdf2484f5bccbee320e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Details::is_lambda_void_boolref&lt; T &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#afd3768c9651bfcdf2484f5bccbee320e">DoTryFinally</a> (T &amp;&amp;tryBlock, F &amp;&amp;finallyBlock)</td></tr>
<tr class="memdesc:afd3768c9651bfcdf2484f5bccbee320e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sigle function that emulates behavior of C#'s try[-catch]-finally statement. During Porting of C#'s try[-catch]-finally statement with Porter's option finally_statement_as_lambda set to true, the statement is translated into the invocation of this method. This overload handles the case in which the return value of the function object that implements the try[-catch] part of the try[-catch]-finally statement is bool.  <a href="#afd3768c9651bfcdf2484f5bccbee320e">More...</a><br /></td></tr>
<tr class="separator:afd3768c9651bfcdf2484f5bccbee320e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fe04830ee0cb8b19e26d72e3d27aa6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a57fe04830ee0cb8b19e26d72e3d27aa6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Details::is_lambda_nonovoid_boolref&lt; T &gt;::value, std::optional&lt; std::result_of_t&lt; T(bool &amp;)&gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a57fe04830ee0cb8b19e26d72e3d27aa6">DoTryFinally</a> (T &amp;&amp;tryBlock, F &amp;&amp;finallyBlock)</td></tr>
<tr class="memdesc:a57fe04830ee0cb8b19e26d72e3d27aa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sigle function that emulates behavior of C#'s try[-catch]-finally statement. During Porting of C#'s try[-catch]-finally statement with Porter's option finally_statement_as_lambda set to true, the statement is translated into the invocation of this method. This overload handles the case in which the return value of the function object that implements the try[-catch] part of the try[-catch]-finally statement is bool&amp;.  <a href="#a57fe04830ee0cb8b19e26d72e3d27aa6">More...</a><br /></td></tr>
<tr class="separator:a57fe04830ee0cb8b19e26d72e3d27aa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1590938710c1d50a4c15c619cdb9c262"><td class="memTemplParams" colspan="2">template&lt;typename T , SmartPtrMode trunkMode, unsigned int ... weakLeafs&gt; </td></tr>
<tr class="memitem:a1590938710c1d50a4c15c619cdb9c262"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_dynamic_weak_ptr.html">DynamicWeakPtr</a>&lt; T, trunkMode, weakLeafs... &gt;::Reference&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1590938710c1d50a4c15c619cdb9c262">Ref</a> (<a class="el" href="class_system_1_1_dynamic_weak_ptr.html">DynamicWeakPtr</a>&lt; T, trunkMode, weakLeafs... &gt; &amp;ptr)</td></tr>
<tr class="memdesc:a1590938710c1d50a4c15c619cdb9c262"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates reference to <a class="el" href="class_system_1_1_dynamic_weak_ptr.html" title="Smart pointer class which tracks pointer modes of template arguments of stored object and updates the...">DynamicWeakPtr</a> object. Used by porter when passing function arguments by reference.  <a href="#a1590938710c1d50a4c15c619cdb9c262">More...</a><br /></td></tr>
<tr class="separator:a1590938710c1d50a4c15c619cdb9c262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061e3d6cb50f1a228a3577ae21c994f7"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a061e3d6cb50f1a228a3577ae21c994f7"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a061e3d6cb50f1a228a3577ae21c994f7">IsEnumMetaInfoDefined</a> (T value)</td></tr>
<tr class="separator:a061e3d6cb50f1a228a3577ae21c994f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a53a4b39ee98df4e9dc1babdd12078"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a92a53a4b39ee98df4e9dc1babdd12078"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="class_system_1_1_string.html">System::String</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a92a53a4b39ee98df4e9dc1babdd12078">EnumGetName</a> (T value)</td></tr>
<tr class="separator:a92a53a4b39ee98df4e9dc1babdd12078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd4bc20c5efd68e2f6c33530cbc61ac"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enumerable &gt; </td></tr>
<tr class="memitem:a5dd4bc20c5efd68e2f6c33530cbc61ac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!Details::IsIterable&lt; Enumerable &gt;::value, Details::EnumeratorAdapter&lt; Enumerable, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5dd4bc20c5efd68e2f6c33530cbc61ac">IterateOver</a> (<a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt; enumerable)</td></tr>
<tr class="memdesc:a5dd4bc20c5efd68e2f6c33530cbc61ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable without begin(), end() methods with target type argument for (auto&amp; value : IterateOver&lt;SomeType&gt;(enumerable))  <a href="#a5dd4bc20c5efd68e2f6c33530cbc61ac">More...</a><br /></td></tr>
<tr class="separator:a5dd4bc20c5efd68e2f6c33530cbc61ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfdbcfaab47bbc3b7403d256baef924"><td class="memTemplParams" colspan="2">template&lt;typename Enumerable &gt; </td></tr>
<tr class="memitem:aadfdbcfaab47bbc3b7403d256baef924"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!Details::IsIterable&lt; Enumerable &gt;::value, Details::EnumeratorAdapter&lt; Enumerable &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aadfdbcfaab47bbc3b7403d256baef924">IterateOver</a> (<a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt; enumerable)</td></tr>
<tr class="memdesc:aadfdbcfaab47bbc3b7403d256baef924"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable without begin(), end() methods with default target type argument for (auto&amp; value : IterateOver(enumerable)) analog to the following C# code foreach (var value in enumerable)  <a href="#aadfdbcfaab47bbc3b7403d256baef924">More...</a><br /></td></tr>
<tr class="separator:aadfdbcfaab47bbc3b7403d256baef924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c12febbfd09cd4dd738d81547f594bb"><td class="memTemplParams" colspan="2">template&lt;typename Enumerable &gt; </td></tr>
<tr class="memitem:a1c12febbfd09cd4dd738d81547f594bb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Details::IsIterable&lt; Enumerable &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1c12febbfd09cd4dd738d81547f594bb">IterateOver</a> (<a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt; enumerable)</td></tr>
<tr class="memdesc:a1c12febbfd09cd4dd738d81547f594bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable with begin(), end() methods with default target type argument for (auto&amp; value : IterateOver(enumerable))  <a href="#a1c12febbfd09cd4dd738d81547f594bb">More...</a><br /></td></tr>
<tr class="separator:a1c12febbfd09cd4dd738d81547f594bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace39ba1577eea8766768f08cb9bf127e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enumerable &gt; </td></tr>
<tr class="memitem:ace39ba1577eea8766768f08cb9bf127e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Details::IsIterable&lt; Enumerable &gt;::value &amp;&amp;std::is_same&lt; typename Details::ReturnTypeTrait&lt; T &gt;::ReturnType, Details::IterableValueType&lt; Enumerable &gt; &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ace39ba1577eea8766768f08cb9bf127e">IterateOver</a> (<a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt; enumerable)</td></tr>
<tr class="memdesc:ace39ba1577eea8766768f08cb9bf127e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable with begin(), end() methods with target type same as original value_type of iterator.  <a href="#ace39ba1577eea8766768f08cb9bf127e">More...</a><br /></td></tr>
<tr class="separator:ace39ba1577eea8766768f08cb9bf127e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9452d9492d6c87c1d04ebec7e50f5d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enumerable &gt; </td></tr>
<tr class="memitem:a8c9452d9492d6c87c1d04ebec7e50f5d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; Details::IsIterable&lt; Enumerable &gt;::value &amp;&amp;!std::is_same&lt; typename Details::ReturnTypeTrait&lt; T &gt;::ReturnType, Details::IterableValueType&lt; Enumerable &gt; &gt;::value, Details::CppIteratorAdapter&lt; Enumerable, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a8c9452d9492d6c87c1d04ebec7e50f5d">IterateOver</a> (<a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt; enumerable)</td></tr>
<tr class="memdesc:a8c9452d9492d6c87c1d04ebec7e50f5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable with begin(), end() methods with different target type and original value_type of iterator.  <a href="#a8c9452d9492d6c87c1d04ebec7e50f5d">More...</a><br /></td></tr>
<tr class="separator:a8c9452d9492d6c87c1d04ebec7e50f5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74f674decd734b10d3f03a5e9f3f61b"><td class="memTemplParams" colspan="2">template&lt;typename Enumerable &gt; </td></tr>
<tr class="memitem:ae74f674decd734b10d3f03a5e9f3f61b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; Enumerable &gt;::value, Details::EnumeratorAdapter&lt; Enumerable, Details::ValueTypeOfEnumerable&lt; Enumerable &gt;, Enumerable * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ae74f674decd734b10d3f03a5e9f3f61b">IterateOver</a> (const Enumerable *enumerable)</td></tr>
<tr class="memdesc:ae74f674decd734b10d3f03a5e9f3f61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable this with default target type.  <a href="#ae74f674decd734b10d3f03a5e9f3f61b">More...</a><br /></td></tr>
<tr class="separator:ae74f674decd734b10d3f03a5e9f3f61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba66404f9a8f50c753ecc9f41b9c22"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enumerable &gt; </td></tr>
<tr class="memitem:af0ba66404f9a8f50c753ecc9f41b9c22"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; Enumerable &gt;::value, Details::EnumeratorAdapter&lt; Enumerable, T, Enumerable * &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#af0ba66404f9a8f50c753ecc9f41b9c22">IterateOver</a> (const Enumerable *enumerable)</td></tr>
<tr class="memdesc:af0ba66404f9a8f50c753ecc9f41b9c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable without begin(), end() methods with target type argument for (auto&amp; value : IterateOver&lt;SomeType&gt;(enumerable))  <a href="#af0ba66404f9a8f50c753ecc9f41b9c22">More...</a><br /></td></tr>
<tr class="separator:af0ba66404f9a8f50c753ecc9f41b9c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a04801e60c2bd7d465da0fe4b75d17"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a89a04801e60c2bd7d465da0fe4b75d17">PrintTo</a> (const Details_Exception &amp;exception, std::ostream *stream)</td></tr>
<tr class="memdesc:a89a04801e60c2bd7d465da0fe4b75d17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#a89a04801e60c2bd7d465da0fe4b75d17">More...</a><br /></td></tr>
<tr class="separator:a89a04801e60c2bd7d465da0fe4b75d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38333e5c02e050f0bbd4db2ab73794c2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a38333e5c02e050f0bbd4db2ab73794c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a38333e5c02e050f0bbd4db2ab73794c2">PrintTo</a> (const <a class="el" href="class_system_1_1_exception_wrapper.html">ExceptionWrapper</a>&lt; T &gt; &amp;exception_wrapper, std::ostream *stream)</td></tr>
<tr class="memdesc:a38333e5c02e050f0bbd4db2ab73794c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#a38333e5c02e050f0bbd4db2ab73794c2">More...</a><br /></td></tr>
<tr class="separator:a38333e5c02e050f0bbd4db2ab73794c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec7ba86b09d07d230b5de3869f4947a"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aaec7ba86b09d07d230b5de3869f4947a">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_system.html#af2ac70ce5544cf54b67cc546c2dc19aa">Exception</a> &amp;exception)</td></tr>
<tr class="memdesc:aaec7ba86b09d07d230b5de3869f4947a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#aaec7ba86b09d07d230b5de3869f4947a">More...</a><br /></td></tr>
<tr class="separator:aaec7ba86b09d07d230b5de3869f4947a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e963a7e1144c1f4720f260bd5da0c0"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#ac9e963a7e1144c1f4720f260bd5da0c0">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="namespace_system.html#af2ac70ce5544cf54b67cc546c2dc19aa">Exception</a> &amp;exception)</td></tr>
<tr class="memdesc:ac9e963a7e1144c1f4720f260bd5da0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#ac9e963a7e1144c1f4720f260bd5da0c0">More...</a><br /></td></tr>
<tr class="separator:ac9e963a7e1144c1f4720f260bd5da0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55b792854ecac1a5000a91a93b60105"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab55b792854ecac1a5000a91a93b60105"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_scalar&lt; T &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ab55b792854ecac1a5000a91a93b60105">GetHashCode</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:ab55b792854ecac1a5000a91a93b60105"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash code for the specified scalar value.  <a href="#ab55b792854ecac1a5000a91a93b60105">More...</a><br /></td></tr>
<tr class="separator:ab55b792854ecac1a5000a91a93b60105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4245b30730d5469f008a24449f68c3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aae4245b30730d5469f008a24449f68c3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_scalar&lt; T &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; T &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aae4245b30730d5469f008a24449f68c3">GetHashCode</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:aae4245b30730d5469f008a24449f68c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash code for the specified object.  <a href="#aae4245b30730d5469f008a24449f68c3">More...</a><br /></td></tr>
<tr class="separator:aae4245b30730d5469f008a24449f68c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e74118b53b9143b52751f87cba97782"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5e74118b53b9143b52751f87cba97782"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">System::IsExceptionWrapper</a>&lt; T &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5e74118b53b9143b52751f87cba97782">GetHashCode</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a5e74118b53b9143b52751f87cba97782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash code for the specified object which is exception.  <a href="#a5e74118b53b9143b52751f87cba97782">More...</a><br /></td></tr>
<tr class="separator:a5e74118b53b9143b52751f87cba97782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49714d3d76ec84aeee1afd6084f766af"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a49714d3d76ec84aeee1afd6084f766af"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_scalar&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; T &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">System::IsExceptionWrapper</a>&lt; T &gt;::value, int &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a49714d3d76ec84aeee1afd6084f766af">GetHashCode</a> (const T &amp;obj)</td></tr>
<tr class="memdesc:a49714d3d76ec84aeee1afd6084f766af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a hash code for the specified object which is not a smart pointer nor exception.  <a href="#a49714d3d76ec84aeee1afd6084f766af">More...</a><br /></td></tr>
<tr class="separator:a49714d3d76ec84aeee1afd6084f766af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865f4c1988ea93d218c43d799c00709c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a865f4c1988ea93d218c43d799c00709c"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a865f4c1988ea93d218c43d799c00709c">GetHashCode</a> (const std::thread::id &amp;id)</td></tr>
<tr class="memdesc:a865f4c1988ea93d218c43d799c00709c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for std::thread::id; Returns the hash code for the specified thread object.  <a href="#a865f4c1988ea93d218c43d799c00709c">More...</a><br /></td></tr>
<tr class="separator:a865f4c1988ea93d218c43d799c00709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df6e5667bbf2bafbbef12e90d27d5d8"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a0df6e5667bbf2bafbbef12e90d27d5d8">PrintTo</a> (const <a class="el" href="class_system_1_1_guid.html">Guid</a> &amp;value, std::ostream *stream)</td></tr>
<tr class="memdesc:a0df6e5667bbf2bafbbef12e90d27d5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#a0df6e5667bbf2bafbbef12e90d27d5d8">More...</a><br /></td></tr>
<tr class="separator:a0df6e5667bbf2bafbbef12e90d27d5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8749d77f4db04d6c8c8623b69e04c1ef"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a8749d77f4db04d6c8c8623b69e04c1ef">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_system_1_1_guid.html">Guid</a> &amp;guid)</td></tr>
<tr class="memdesc:a8749d77f4db04d6c8c8623b69e04c1ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#a8749d77f4db04d6c8c8623b69e04c1ef">More...</a><br /></td></tr>
<tr class="separator:a8749d77f4db04d6c8c8623b69e04c1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38555a08991939399070fea9de9d1fe5"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a38555a08991939399070fea9de9d1fe5">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="class_system_1_1_guid.html">Guid</a> &amp;guid)</td></tr>
<tr class="memdesc:a38555a08991939399070fea9de9d1fe5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#a38555a08991939399070fea9de9d1fe5">More...</a><br /></td></tr>
<tr class="separator:a38555a08991939399070fea9de9d1fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095def4a93da5452005616e8bff17d9c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a095def4a93da5452005616e8bff17d9c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a095def4a93da5452005616e8bff17d9c">operator!=</a> (std::nullptr_t, const T &amp;other)</td></tr>
<tr class="memdesc:a095def4a93da5452005616e8bff17d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object represents a value that is not equal to null.  <a href="#a095def4a93da5452005616e8bff17d9c">More...</a><br /></td></tr>
<tr class="separator:a095def4a93da5452005616e8bff17d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a981b208009ae96e5f0ca5348ce939ee2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a981b208009ae96e5f0ca5348ce939ee2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a981b208009ae96e5f0ca5348ce939ee2">operator&gt;</a> (std::nullptr_t, const T &amp;)</td></tr>
<tr class="memdesc:a981b208009ae96e5f0ca5348ce939ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns false.  <a href="#a981b208009ae96e5f0ca5348ce939ee2">More...</a><br /></td></tr>
<tr class="separator:a981b208009ae96e5f0ca5348ce939ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76286d7dc936ba63040b6e1daf3653a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af76286d7dc936ba63040b6e1daf3653a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#af76286d7dc936ba63040b6e1daf3653a">operator&lt;</a> (std::nullptr_t, const T &amp;)</td></tr>
<tr class="memdesc:af76286d7dc936ba63040b6e1daf3653a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns false.  <a href="#af76286d7dc936ba63040b6e1daf3653a">More...</a><br /></td></tr>
<tr class="separator:af76286d7dc936ba63040b6e1daf3653a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5044c939308984b2f47f780966b80d06"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5044c939308984b2f47f780966b80d06"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5044c939308984b2f47f780966b80d06">operator&gt;=</a> (std::nullptr_t, const T &amp;)</td></tr>
<tr class="memdesc:a5044c939308984b2f47f780966b80d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns false.  <a href="#a5044c939308984b2f47f780966b80d06">More...</a><br /></td></tr>
<tr class="separator:a5044c939308984b2f47f780966b80d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7ad08a8f262408ecf4d0ddd7d4ea34"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec7ad08a8f262408ecf4d0ddd7d4ea34"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aec7ad08a8f262408ecf4d0ddd7d4ea34">operator&lt;=</a> (std::nullptr_t, const T &amp;)</td></tr>
<tr class="memdesc:aec7ad08a8f262408ecf4d0ddd7d4ea34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns false.  <a href="#aec7ad08a8f262408ecf4d0ddd7d4ea34">More...</a><br /></td></tr>
<tr class="separator:aec7ad08a8f262408ecf4d0ddd7d4ea34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af996a81841a1a6d18530f6b06439b1bf"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af996a81841a1a6d18530f6b06439b1bf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T1 &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T2 &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#af996a81841a1a6d18530f6b06439b1bf">operator==</a> (const T1 &amp;some, const T2 &amp;other)</td></tr>
<tr class="memdesc:af996a81841a1a6d18530f6b06439b1bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value is equal to the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#afd3b275a80034605a0034ba4e53ac85b">operator==()</a> to these values.  <a href="#af996a81841a1a6d18530f6b06439b1bf">More...</a><br /></td></tr>
<tr class="separator:af996a81841a1a6d18530f6b06439b1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af588a8117ab8f22bada9b639eb7cfbea"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af588a8117ab8f22bada9b639eb7cfbea"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T1 &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T2 &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#af588a8117ab8f22bada9b639eb7cfbea">operator!=</a> (const T1 &amp;some, const T2 &amp;other)</td></tr>
<tr class="memdesc:af588a8117ab8f22bada9b639eb7cfbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value is not equal to the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#a1d20631216c584b44d430a4b99ae6bd8">operator!=()</a> to these values.  <a href="#af588a8117ab8f22bada9b639eb7cfbea">More...</a><br /></td></tr>
<tr class="separator:af588a8117ab8f22bada9b639eb7cfbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ef10e6e075a236b8d8c5cfc7febdac"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa4ef10e6e075a236b8d8c5cfc7febdac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T1 &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T2 &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aa4ef10e6e075a236b8d8c5cfc7febdac">operator&gt;</a> (const T1 &amp;some, const T2 &amp;other)</td></tr>
<tr class="memdesc:aa4ef10e6e075a236b8d8c5cfc7febdac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value is greater than the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#a970cf4b21e945ee63aecc37362673e94">operator&gt;()</a> to these values.  <a href="#aa4ef10e6e075a236b8d8c5cfc7febdac">More...</a><br /></td></tr>
<tr class="separator:aa4ef10e6e075a236b8d8c5cfc7febdac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428139c8ef33c75cb1b930c6f5bd8b0c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a428139c8ef33c75cb1b930c6f5bd8b0c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T1 &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T2 &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a428139c8ef33c75cb1b930c6f5bd8b0c">operator&lt;</a> (const T1 &amp;some, const T2 &amp;other)</td></tr>
<tr class="memdesc:a428139c8ef33c75cb1b930c6f5bd8b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value is less than the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#aed9988f7fe49db96f7d7b601ceb247d9">operator&lt;()</a> to these values.  <a href="#a428139c8ef33c75cb1b930c6f5bd8b0c">More...</a><br /></td></tr>
<tr class="separator:a428139c8ef33c75cb1b930c6f5bd8b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5290947dac08645b8d2b0ebf5888bab"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad5290947dac08645b8d2b0ebf5888bab"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T1 &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T2 &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad5290947dac08645b8d2b0ebf5888bab">operator&gt;=</a> (const T1 &amp;some, const T2 &amp;other)</td></tr>
<tr class="memdesc:ad5290947dac08645b8d2b0ebf5888bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value is greater or equal to the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#af3f0d62782434e0f9ff2b626c18d454f">operator&gt;=()</a> to these values.  <a href="#ad5290947dac08645b8d2b0ebf5888bab">More...</a><br /></td></tr>
<tr class="separator:ad5290947dac08645b8d2b0ebf5888bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acecc05b02ac3dd0b3aac883b68714186"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:acecc05b02ac3dd0b3aac883b68714186"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T1 &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T2 &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#acecc05b02ac3dd0b3aac883b68714186">operator&lt;=</a> (const T1 &amp;some, const T2 &amp;other)</td></tr>
<tr class="memdesc:acecc05b02ac3dd0b3aac883b68714186"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value is less or equal to the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#af03910ceff1e2bc8ed68d88b6024b629">operator&lt;=()</a> to these values.  <a href="#acecc05b02ac3dd0b3aac883b68714186">More...</a><br /></td></tr>
<tr class="separator:acecc05b02ac3dd0b3aac883b68714186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce2bc5a752f738c594143556304ad00"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ce2bc5a752f738c594143556304ad00"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value &amp;&amp;std::is_class&lt; T &gt;::value, <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a2ce2bc5a752f738c594143556304ad00">operator+</a> (std::nullptr_t, const T &amp;)</td></tr>
<tr class="memdesc:a2ce2bc5a752f738c594143556304ad00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns a default-constructed instance of the Nullable&lt;T&gt; class representing the null value.  <a href="#a2ce2bc5a752f738c594143556304ad00">More...</a><br /></td></tr>
<tr class="separator:a2ce2bc5a752f738c594143556304ad00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec0b6d75181d27997407f54844cd315"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acec0b6d75181d27997407f54844cd315"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#acec0b6d75181d27997407f54844cd315">operator+</a> (std::nullptr_t, const T &amp;)</td></tr>
<tr class="memdesc:acec0b6d75181d27997407f54844cd315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns a default-constructed instance of the Nullable&lt;T&gt; class representing the null value.  <a href="#acec0b6d75181d27997407f54844cd315">More...</a><br /></td></tr>
<tr class="separator:acec0b6d75181d27997407f54844cd315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8480c036b2207d516a783094a8546f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aad8480c036b2207d516a783094a8546f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value &amp;&amp;std::is_class&lt; T &gt;::value, <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aad8480c036b2207d516a783094a8546f">operator+</a> (const T &amp;, std::nullptr_t)</td></tr>
<tr class="memdesc:aad8480c036b2207d516a783094a8546f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns a default-constructed instance of the Nullable&lt;T&gt; class representing the null value.  <a href="#aad8480c036b2207d516a783094a8546f">More...</a><br /></td></tr>
<tr class="separator:aad8480c036b2207d516a783094a8546f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9fa06871065a5c7555cea2e61691c3f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad9fa06871065a5c7555cea2e61691c3f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad9fa06871065a5c7555cea2e61691c3f">operator+</a> (const T &amp;, std::nullptr_t)</td></tr>
<tr class="memdesc:ad9fa06871065a5c7555cea2e61691c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Always returns a default-constructed instance of the Nullable&lt;T&gt; class representing the null value.  <a href="#ad9fa06871065a5c7555cea2e61691c3f">More...</a><br /></td></tr>
<tr class="separator:ad9fa06871065a5c7555cea2e61691c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc204f0b20f4133bc919ea7cae0737c0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt;!IsNullable&lt;T1&gt;::value &amp;&amp; !IsNullable&lt;T2&gt;::value &amp;&amp; !std::is_same&lt;T1, System::String&gt;::value, int&gt;::type&gt; </td></tr>
<tr class="memitem:abc204f0b20f4133bc919ea7cae0737c0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#abc204f0b20f4133bc919ea7cae0737c0">operator+</a> (const T1 &amp;some, const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T2 &gt; &amp;other) -&gt; <a class="el" href="class_system_1_1_nullable.html">System::Nullable</a>&lt; decltype(some+other.get_Value())&gt;</td></tr>
<tr class="memdesc:abc204f0b20f4133bc919ea7cae0737c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums non-nullable and nullable values.  <a href="#abc204f0b20f4133bc919ea7cae0737c0">More...</a><br /></td></tr>
<tr class="separator:abc204f0b20f4133bc919ea7cae0737c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2de841d8615daa21a10859260bf89ec"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt;!IsNullable&lt;T1&gt;::value &amp;&amp; !IsNullable&lt;T2&gt;::value &amp;&amp; !std::is_same&lt;T1, System::String&gt;::value, int&gt;::type&gt; </td></tr>
<tr class="memitem:ab2de841d8615daa21a10859260bf89ec"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ab2de841d8615daa21a10859260bf89ec">operator-</a> (const T1 &amp;some, const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T2 &gt; &amp;other) -&gt; <a class="el" href="class_system_1_1_nullable.html">System::Nullable</a>&lt; decltype(some - other.get_Value())&gt;</td></tr>
<tr class="memdesc:ab2de841d8615daa21a10859260bf89ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts non-nullable and nullable values.  <a href="#ab2de841d8615daa21a10859260bf89ec">More...</a><br /></td></tr>
<tr class="separator:ab2de841d8615daa21a10859260bf89ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a54af53bea429541e870b5ecc470e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46a54af53bea429541e870b5ecc470e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a46a54af53bea429541e870b5ecc470e7">PrintTo</a> (const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &amp;value, std::ostream *stream)</td></tr>
<tr class="memdesc:a46a54af53bea429541e870b5ecc470e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#a46a54af53bea429541e870b5ecc470e7">More...</a><br /></td></tr>
<tr class="separator:a46a54af53bea429541e870b5ecc470e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51d32a20ac8cf7204dde11548d18fc9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae51d32a20ac8cf7204dde11548d18fc9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ae51d32a20ac8cf7204dde11548d18fc9">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:ae51d32a20ac8cf7204dde11548d18fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#ae51d32a20ac8cf7204dde11548d18fc9">More...</a><br /></td></tr>
<tr class="separator:ae51d32a20ac8cf7204dde11548d18fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f50fd8093fff4532229c6ecbd8f487"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a18f50fd8093fff4532229c6ecbd8f487"><td class="memTemplItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a18f50fd8093fff4532229c6ecbd8f487">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &amp;value)</td></tr>
<tr class="memdesc:a18f50fd8093fff4532229c6ecbd8f487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#a18f50fd8093fff4532229c6ecbd8f487">More...</a><br /></td></tr>
<tr class="separator:a18f50fd8093fff4532229c6ecbd8f487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee59b45d6a8565484e343936c5b249e"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:aaee59b45d6a8565484e343936c5b249e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aaee59b45d6a8565484e343936c5b249e">Cast_noexcept</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;obj)</td></tr>
<tr class="memdesc:aaee59b45d6a8565484e343936c5b249e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects.  <a href="#aaee59b45d6a8565484e343936c5b249e">More...</a><br /></td></tr>
<tr class="separator:aaee59b45d6a8565484e343936c5b249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3b7b6bd472f4c218ddf6bcc28b6462"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a2a3b7b6bd472f4c218ddf6bcc28b6462"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a2a3b7b6bd472f4c218ddf6bcc28b6462">Cast</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;obj)</td></tr>
<tr class="memdesc:a2a3b7b6bd472f4c218ddf6bcc28b6462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects.  <a href="#a2a3b7b6bd472f4c218ddf6bcc28b6462">More...</a><br /></td></tr>
<tr class="separator:a2a3b7b6bd472f4c218ddf6bcc28b6462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78958162ebbe8cbc0debbe905cb37c13"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a78958162ebbe8cbc0debbe905cb37c13"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TFrom &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value &amp;&amp;(std::is_convertible&lt; TTo, TFrom &gt;::value||std::is_base_of&lt; TTo, TFrom &gt;::value), TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a78958162ebbe8cbc0debbe905cb37c13">DynamicCast_noexcept</a> (const TFrom &amp;obj) noexcept</td></tr>
<tr class="memdesc:a78958162ebbe8cbc0debbe905cb37c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast on Exception objects.  <a href="#a78958162ebbe8cbc0debbe905cb37c13">More...</a><br /></td></tr>
<tr class="separator:a78958162ebbe8cbc0debbe905cb37c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f75c58083a9f099cf712e70ab2328a"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a65f75c58083a9f099cf712e70ab2328a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TFrom &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value &amp;&amp;(std::is_convertible&lt; TTo, TFrom &gt;::value||std::is_base_of&lt; TTo, TFrom &gt;::value), TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a65f75c58083a9f099cf712e70ab2328a">DynamicCast</a> (const TFrom &amp;obj)</td></tr>
<tr class="memdesc:a65f75c58083a9f099cf712e70ab2328a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast on Exception objects.  <a href="#a65f75c58083a9f099cf712e70ab2328a">More...</a><br /></td></tr>
<tr class="separator:a65f75c58083a9f099cf712e70ab2328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c63c8b88ca46577ccd74f712ab1767"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a44c63c8b88ca46577ccd74f712ab1767"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a44c63c8b88ca46577ccd74f712ab1767">StaticCast_noexcept</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;obj)</td></tr>
<tr class="memdesc:a44c63c8b88ca46577ccd74f712ab1767"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects.  <a href="#a44c63c8b88ca46577ccd74f712ab1767">More...</a><br /></td></tr>
<tr class="separator:a44c63c8b88ca46577ccd74f712ab1767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec55c703d291b84ff94ef32ac954ed14"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:aec55c703d291b84ff94ef32ac954ed14"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aec55c703d291b84ff94ef32ac954ed14">StaticCast</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;obj)</td></tr>
<tr class="memdesc:aec55c703d291b84ff94ef32ac954ed14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects.  <a href="#aec55c703d291b84ff94ef32ac954ed14">More...</a><br /></td></tr>
<tr class="separator:aec55c703d291b84ff94ef32ac954ed14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6b0c5f1b7879f547e50485f78e3935"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a5e6b0c5f1b7879f547e50485f78e3935"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5e6b0c5f1b7879f547e50485f78e3935">StaticCast_noexcept</a> (<a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; TFrom &gt; const &amp;obj)</td></tr>
<tr class="memdesc:a5e6b0c5f1b7879f547e50485f78e3935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast on <a class="el" href="class_system_1_1_weak_ptr.html" title="Subclass of System::SmartPtr which sets itself to weak mode at construction. Please note that this cl...">WeakPtr</a> objects.  <a href="#a5e6b0c5f1b7879f547e50485f78e3935">More...</a><br /></td></tr>
<tr class="separator:a5e6b0c5f1b7879f547e50485f78e3935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefcaf34229820d8e970fb3ffa1861fa"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:abefcaf34229820d8e970fb3ffa1861fa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#abefcaf34229820d8e970fb3ffa1861fa">StaticCast</a> (<a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; TFrom &gt; const &amp;obj)</td></tr>
<tr class="memdesc:abefcaf34229820d8e970fb3ffa1861fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast on <a class="el" href="class_system_1_1_weak_ptr.html" title="Subclass of System::SmartPtr which sets itself to weak mode at construction. Please note that this cl...">WeakPtr</a> objects.  <a href="#abefcaf34229820d8e970fb3ffa1861fa">More...</a><br /></td></tr>
<tr class="separator:abefcaf34229820d8e970fb3ffa1861fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589ebb1ed606af7df2d9f9f0c95b53c5"><td class="memTemplParams" colspan="2">template&lt;typename TTo &gt; </td></tr>
<tr class="memitem:a589ebb1ed606af7df2d9f9f0c95b53c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a589ebb1ed606af7df2d9f9f0c95b53c5">StaticCast</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:a589ebb1ed606af7df2d9f9f0c95b53c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast of null objects.  <a href="#a589ebb1ed606af7df2d9f9f0c95b53c5">More...</a><br /></td></tr>
<tr class="separator:a589ebb1ed606af7df2d9f9f0c95b53c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7a977959b1205723c820c210eff2ed"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:abe7a977959b1205723c820c210eff2ed"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; TFrom &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#abe7a977959b1205723c820c210eff2ed">StaticCast</a> (TFrom value)</td></tr>
<tr class="memdesc:abe7a977959b1205723c820c210eff2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for arithmetic types.  <a href="#abe7a977959b1205723c820c210eff2ed">More...</a><br /></td></tr>
<tr class="separator:abe7a977959b1205723c820c210eff2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3041159c5f29dfe490e239c06ae8d09c"><td class="memTemplParams" colspan="2">template&lt;typename TTo &gt; </td></tr>
<tr class="memitem:a3041159c5f29dfe490e239c06ae8d09c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; TTo, <a class="el" href="class_system_1_1_string.html">System::String</a> &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a3041159c5f29dfe490e239c06ae8d09c">StaticCast</a> (TTo value)</td></tr>
<tr class="memdesc:a3041159c5f29dfe490e239c06ae8d09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process cast from <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a>.  <a href="#a3041159c5f29dfe490e239c06ae8d09c">More...</a><br /></td></tr>
<tr class="separator:a3041159c5f29dfe490e239c06ae8d09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4945f68826fff476a7fb5c167b46974f"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a4945f68826fff476a7fb5c167b46974f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_arithmetic&lt; TFrom &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a4945f68826fff476a7fb5c167b46974f">StaticCast</a> (const TFrom *value)</td></tr>
<tr class="memdesc:a4945f68826fff476a7fb5c167b46974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for arithmetic types.  <a href="#a4945f68826fff476a7fb5c167b46974f">More...</a><br /></td></tr>
<tr class="separator:a4945f68826fff476a7fb5c167b46974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d7f4cb9071e7a0e39e5250bd9dc3ac"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a79d7f4cb9071e7a0e39e5250bd9dc3ac"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_same&lt; TFrom, <a class="el" href="class_system_1_1_string.html">System::String</a> &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TFrom &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; TFrom &gt;::value &amp;&amp;!std::is_arithmetic&lt; TFrom &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a79d7f4cb9071e7a0e39e5250bd9dc3ac">StaticCast</a> (TFrom &amp;obj)</td></tr>
<tr class="memdesc:a79d7f4cb9071e7a0e39e5250bd9dc3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast on non-pointer objects.  <a href="#a79d7f4cb9071e7a0e39e5250bd9dc3ac">More...</a><br /></td></tr>
<tr class="separator:a79d7f4cb9071e7a0e39e5250bd9dc3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc6991e5a0db8641b4abc40454697ff"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:addc6991e5a0db8641b4abc40454697ff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#addc6991e5a0db8641b4abc40454697ff">DynamicCast_noexcept</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;obj) noexcept</td></tr>
<tr class="memdesc:addc6991e5a0db8641b4abc40454697ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects.  <a href="#addc6991e5a0db8641b4abc40454697ff">More...</a><br /></td></tr>
<tr class="separator:addc6991e5a0db8641b4abc40454697ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5255975378a13bafcd607c37b1569162"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a5255975378a13bafcd607c37b1569162"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TFrom &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value &amp;&amp;(std::is_convertible&lt; TTo, TFrom &gt;::value||std::is_base_of&lt; TTo, TFrom &gt;::value), TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5255975378a13bafcd607c37b1569162">StaticCast_noexcept</a> (const TFrom &amp;obj)</td></tr>
<tr class="memdesc:a5255975378a13bafcd607c37b1569162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast on Exception objects.  <a href="#a5255975378a13bafcd607c37b1569162">More...</a><br /></td></tr>
<tr class="separator:a5255975378a13bafcd607c37b1569162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd54b2151d6b479accb2707e7c1c32"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:af9fd54b2151d6b479accb2707e7c1c32"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TFrom &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value &amp;&amp;(std::is_convertible&lt; TTo, TFrom &gt;::value||std::is_base_of&lt; TTo, TFrom &gt;::value), TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#af9fd54b2151d6b479accb2707e7c1c32">StaticCast</a> (const TFrom &amp;obj)</td></tr>
<tr class="memdesc:af9fd54b2151d6b479accb2707e7c1c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast on Exception objects.  <a href="#af9fd54b2151d6b479accb2707e7c1c32">More...</a><br /></td></tr>
<tr class="separator:af9fd54b2151d6b479accb2707e7c1c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be32cc2000153c8e2bc4b181a52df64"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a0be32cc2000153c8e2bc4b181a52df64"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_enum&lt; TTo &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a0be32cc2000153c8e2bc4b181a52df64">DynamicCast</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;obj)</td></tr>
<tr class="memdesc:a0be32cc2000153c8e2bc4b181a52df64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects.  <a href="#a0be32cc2000153c8e2bc4b181a52df64">More...</a><br /></td></tr>
<tr class="separator:a0be32cc2000153c8e2bc4b181a52df64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b78ffbf79c9b5ec9ecfd6dd2a23977"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:ad3b78ffbf79c9b5ec9ecfd6dd2a23977"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_enum&lt; TTo &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad3b78ffbf79c9b5ec9ecfd6dd2a23977">DynamicCast</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; obj)</td></tr>
<tr class="memdesc:ad3b78ffbf79c9b5ec9ecfd6dd2a23977"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unboxes boxed enum via cast.  <a href="#ad3b78ffbf79c9b5ec9ecfd6dd2a23977">More...</a><br /></td></tr>
<tr class="separator:ad3b78ffbf79c9b5ec9ecfd6dd2a23977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1933f4f06c4e203b5785fe32c6f8fcf"><td class="memTemplParams" colspan="2">template&lt;typename TTo &gt; </td></tr>
<tr class="memitem:ae1933f4f06c4e203b5785fe32c6f8fcf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ae1933f4f06c4e203b5785fe32c6f8fcf">DynamicCast</a> (std::nullptr_t) noexcept</td></tr>
<tr class="memdesc:ae1933f4f06c4e203b5785fe32c6f8fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast of null objects.  <a href="#ae1933f4f06c4e203b5785fe32c6f8fcf">More...</a><br /></td></tr>
<tr class="separator:ae1933f4f06c4e203b5785fe32c6f8fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35bb077928360ee2d4a866d94d5fdf9"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:ab35bb077928360ee2d4a866d94d5fdf9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TFrom &gt;::value &amp;&amp;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; TFrom &gt;::value &amp;&amp;std::is_convertible&lt; TTo, TFrom &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ab35bb077928360ee2d4a866d94d5fdf9">DynamicCast</a> (TFrom &amp;obj)</td></tr>
<tr class="memdesc:ab35bb077928360ee2d4a866d94d5fdf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast on non-pointer objects.  <a href="#ab35bb077928360ee2d4a866d94d5fdf9">More...</a><br /></td></tr>
<tr class="separator:ab35bb077928360ee2d4a866d94d5fdf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c0694261e19a770349a5c430f84762"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a50c0694261e19a770349a5c430f84762"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; <a class="el" href="class_system_1_1_object.html">System::Object</a>, TFrom &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a50c0694261e19a770349a5c430f84762">StaticCast_noexcept</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; obj) noexcept</td></tr>
<tr class="memdesc:a50c0694261e19a770349a5c430f84762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast on Objects to Exception objects.  <a href="#a50c0694261e19a770349a5c430f84762">More...</a><br /></td></tr>
<tr class="separator:a50c0694261e19a770349a5c430f84762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a839f0309200ae1d6a75c098a05938495"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a839f0309200ae1d6a75c098a05938495"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; <a class="el" href="class_system_1_1_object.html">System::Object</a>, TFrom &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a839f0309200ae1d6a75c098a05938495">StaticCast</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; obj) noexcept</td></tr>
<tr class="memdesc:a839f0309200ae1d6a75c098a05938495"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs static cast on Objects to Exception objects.  <a href="#a839f0309200ae1d6a75c098a05938495">More...</a><br /></td></tr>
<tr class="separator:a839f0309200ae1d6a75c098a05938495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013a9d78d740f2a82c7967cdaf9f625b"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a013a9d78d740f2a82c7967cdaf9f625b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; <a class="el" href="class_system_1_1_object.html">System::Object</a>, TFrom &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a013a9d78d740f2a82c7967cdaf9f625b">DynamicCast_noexcept</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; obj) noexcept</td></tr>
<tr class="memdesc:a013a9d78d740f2a82c7967cdaf9f625b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast on Objects to Exception objects.  <a href="#a013a9d78d740f2a82c7967cdaf9f625b">More...</a><br /></td></tr>
<tr class="separator:a013a9d78d740f2a82c7967cdaf9f625b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa049b684335a5c4eb02b66f795887d8f"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:aa049b684335a5c4eb02b66f795887d8f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; <a class="el" href="class_system_1_1_object.html">System::Object</a>, TFrom &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt; TTo &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aa049b684335a5c4eb02b66f795887d8f">DynamicCast</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; obj)</td></tr>
<tr class="memdesc:aa049b684335a5c4eb02b66f795887d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast on Objects to Exception objects.  <a href="#aa049b684335a5c4eb02b66f795887d8f">More...</a><br /></td></tr>
<tr class="separator:aa049b684335a5c4eb02b66f795887d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67461a4a908d3976678e3028e0b7b9e7"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a67461a4a908d3976678e3028e0b7b9e7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_pointer&lt; TTo &gt;::value &amp;&amp;std::is_same&lt; IntPtr, TFrom &gt;::value, TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a67461a4a908d3976678e3028e0b7b9e7">DynamicCast</a> (TFrom value) noexcept</td></tr>
<tr class="memdesc:a67461a4a908d3976678e3028e0b7b9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs dynamic cast from IntPtr to pointer.  <a href="#a67461a4a908d3976678e3028e0b7b9e7">More...</a><br /></td></tr>
<tr class="separator:a67461a4a908d3976678e3028e0b7b9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1786be517f2529f586b668174cb46232"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a1786be517f2529f586b668174cb46232"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt; TTo &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1786be517f2529f586b668174cb46232">ConstCast</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; &amp;obj)</td></tr>
<tr class="memdesc:a1786be517f2529f586b668174cb46232"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs const cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects.  <a href="#a1786be517f2529f586b668174cb46232">More...</a><br /></td></tr>
<tr class="separator:a1786be517f2529f586b668174cb46232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c26a170da5d1558025b3f07238e5d29"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c26a170da5d1558025b3f07238e5d29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1c26a170da5d1558025b3f07238e5d29">MemberwiseClone</a> (T *ptr)</td></tr>
<tr class="memdesc:a1c26a170da5d1558025b3f07238e5d29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs memberwise cloning using copy constructor.  <a href="#a1c26a170da5d1558025b3f07238e5d29">More...</a><br /></td></tr>
<tr class="separator:a1c26a170da5d1558025b3f07238e5d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad956930000f648fb745a10baa84813a7"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad956930000f648fb745a10baa84813a7">PrintTo</a> (const <a class="el" href="class_system_1_1_object.html">System::Object</a> &amp;value, std::ostream *stream)</td></tr>
<tr class="memdesc:ad956930000f648fb745a10baa84813a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#ad956930000f648fb745a10baa84813a7">More...</a><br /></td></tr>
<tr class="separator:ad956930000f648fb745a10baa84813a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957bc825d4a178d3adfc19a5e18d10a0"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a957bc825d4a178d3adfc19a5e18d10a0">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_system_1_1_object.html">System::Object</a> &amp;<a class="el" href="class_system_1_1_object.html">object</a>)</td></tr>
<tr class="memdesc:a957bc825d4a178d3adfc19a5e18d10a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#a957bc825d4a178d3adfc19a5e18d10a0">More...</a><br /></td></tr>
<tr class="separator:a957bc825d4a178d3adfc19a5e18d10a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1057a7c46c249783d63afab4562a4b9a"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1057a7c46c249783d63afab4562a4b9a">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="class_system_1_1_object.html">System::Object</a> &amp;<a class="el" href="class_system_1_1_object.html">object</a>)</td></tr>
<tr class="memdesc:a1057a7c46c249783d63afab4562a4b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#a1057a7c46c249783d63afab4562a4b9a">More...</a><br /></td></tr>
<tr class="separator:a1057a7c46c249783d63afab4562a4b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74362b737830718d30ab15c20f9413b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab74362b737830718d30ab15c20f9413b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ab74362b737830718d30ab15c20f9413b">ObjectExt::GetType&lt; System::String &gt;</a> ()</td></tr>
<tr class="memdesc:ab74362b737830718d30ab15c20f9413b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a>.  <a href="#ab74362b737830718d30ab15c20f9413b">More...</a><br /></td></tr>
<tr class="separator:ab74362b737830718d30ab15c20f9413b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f7bf974593425621e8e393989dde8"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a1e3f7bf974593425621e8e393989dde8"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1e3f7bf974593425621e8e393989dde8">ObjectExt::GetType&lt; System::DateTime &gt;</a> ()</td></tr>
<tr class="memdesc:a1e3f7bf974593425621e8e393989dde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements typeof() translation. Overload for <a class="el" href="class_system_1_1_date_time.html" title="Represents a specific date and time value on the time continuum. This type should be allocated on sta...">DateTime</a>.  <a href="#a1e3f7bf974593425621e8e393989dde8">More...</a><br /></td></tr>
<tr class="separator:a1e3f7bf974593425621e8e393989dde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464fe6b406e6f01ff59cbb754ed3fd4d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a464fe6b406e6f01ff59cbb754ed3fd4d">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_system_1_1_operating_system.html">OperatingSystem</a> &amp;os)</td></tr>
<tr class="memdesc:a464fe6b406e6f01ff59cbb754ed3fd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#a464fe6b406e6f01ff59cbb754ed3fd4d">More...</a><br /></td></tr>
<tr class="separator:a464fe6b406e6f01ff59cbb754ed3fd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebfc84f6c2d760d582c4684c0b08fad"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aeebfc84f6c2d760d582c4684c0b08fad">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="class_system_1_1_operating_system.html">OperatingSystem</a> &amp;os)</td></tr>
<tr class="memdesc:aeebfc84f6c2d760d582c4684c0b08fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#aeebfc84f6c2d760d582c4684c0b08fad">More...</a><br /></td></tr>
<tr class="separator:aeebfc84f6c2d760d582c4684c0b08fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387e3a056a0f577be4c928489353dc70"><td class="memTemplParams" colspan="2">template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a387e3a056a0f577be4c928489353dc70"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a387e3a056a0f577be4c928489353dc70">Equals</a> (const TA &amp;a, const TB &amp;b)</td></tr>
<tr class="memdesc:a387e3a056a0f577be4c928489353dc70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the equality of two values applying <a class="el" href="namespace_system.html#afd3b275a80034605a0034ba4e53ac85b">operator==()</a> to them.  <a href="#a387e3a056a0f577be4c928489353dc70">More...</a><br /></td></tr>
<tr class="separator:a387e3a056a0f577be4c928489353dc70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8350101d28b86bf072fdcd19577180f3"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a8350101d28b86bf072fdcd19577180f3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a8350101d28b86bf072fdcd19577180f3">Equals&lt; float, float &gt;</a> (const float &amp;a, const float &amp;b)</td></tr>
<tr class="memdesc:a8350101d28b86bf072fdcd19577180f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for single-precision floating point values. Although two floating point NaNs are defined by IEC 60559:1989 to always compare as unequal, the contract for <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">System.Object.Equals</a>, requires that overrides must satisfy the requirements for an equivalence operator. Therefore, System.Double.Equals and System.Single.Equals return True when comparing two NaNs, while the equality operator returns False in that case, as required by the standard.  <a href="#a8350101d28b86bf072fdcd19577180f3">More...</a><br /></td></tr>
<tr class="separator:a8350101d28b86bf072fdcd19577180f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8629817d6eca8c8446d5deef6d8026"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:aad8629817d6eca8c8446d5deef6d8026"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aad8629817d6eca8c8446d5deef6d8026">Equals&lt; double, double &gt;</a> (const double &amp;a, const double &amp;b)</td></tr>
<tr class="memdesc:aad8629817d6eca8c8446d5deef6d8026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization for double-precision floating point values.  <a href="#aad8629817d6eca8c8446d5deef6d8026">More...</a><br /></td></tr>
<tr class="separator:aad8629817d6eca8c8446d5deef6d8026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28059507def8470e7000bdd82634ee05"><td class="memTemplParams" colspan="2">template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a28059507def8470e7000bdd82634ee05"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!std::is_floating_point&lt; TA &gt;::value &amp;&amp;!std::is_floating_point&lt; TB &gt;::value, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a28059507def8470e7000bdd82634ee05">Compare</a> (const TA &amp;a, const TB &amp;b)</td></tr>
<tr class="memdesc:a28059507def8470e7000bdd82634ee05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two values.  <a href="#a28059507def8470e7000bdd82634ee05">More...</a><br /></td></tr>
<tr class="separator:a28059507def8470e7000bdd82634ee05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e024123b882559b0a97cbd6e9b66d8c"><td class="memTemplParams" colspan="2">template&lt;typename TA , typename TB &gt; </td></tr>
<tr class="memitem:a9e024123b882559b0a97cbd6e9b66d8c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_floating_point&lt; TA &gt;::value &amp;&amp;std::is_floating_point&lt; TB &gt;::value, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a9e024123b882559b0a97cbd6e9b66d8c">Compare</a> (const TA &amp;a, const TB &amp;b)</td></tr>
<tr class="memdesc:a9e024123b882559b0a97cbd6e9b66d8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two floating point values.  <a href="#a9e024123b882559b0a97cbd6e9b66d8c">More...</a><br /></td></tr>
<tr class="separator:a9e024123b882559b0a97cbd6e9b66d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead17c6b07691d6b73033d3ec43d2590"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aead17c6b07691d6b73033d3ec43d2590"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aead17c6b07691d6b73033d3ec43d2590">IsNaN</a> (const T &amp;value)</td></tr>
<tr class="memdesc:aead17c6b07691d6b73033d3ec43d2590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value is Not-A-Number value.  <a href="#aead17c6b07691d6b73033d3ec43d2590">More...</a><br /></td></tr>
<tr class="separator:aead17c6b07691d6b73033d3ec43d2590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1f688ba5469b309505fac4e64735ca6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad1f688ba5469b309505fac4e64735ca6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad1f688ba5469b309505fac4e64735ca6">IsInfinity</a> (const T &amp;value)</td></tr>
<tr class="memdesc:ad1f688ba5469b309505fac4e64735ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value represents infinity.  <a href="#ad1f688ba5469b309505fac4e64735ca6">More...</a><br /></td></tr>
<tr class="separator:ad1f688ba5469b309505fac4e64735ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd173aa9033edce7ad7ccf196b389f02"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd173aa9033edce7ad7ccf196b389f02"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#acd173aa9033edce7ad7ccf196b389f02">IsPositiveInfinity</a> (const T &amp;value)</td></tr>
<tr class="memdesc:acd173aa9033edce7ad7ccf196b389f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value represents positive infinity.  <a href="#acd173aa9033edce7ad7ccf196b389f02">More...</a><br /></td></tr>
<tr class="separator:acd173aa9033edce7ad7ccf196b389f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4334b4226f3eebddf8dd446fd25584eb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4334b4226f3eebddf8dd446fd25584eb"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a4334b4226f3eebddf8dd446fd25584eb">IsNegativeInfinity</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a4334b4226f3eebddf8dd446fd25584eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value represents negative infinity.  <a href="#a4334b4226f3eebddf8dd446fd25584eb">More...</a><br /></td></tr>
<tr class="separator:a4334b4226f3eebddf8dd446fd25584eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b744966a1f5dee04392904a8886b3fc"><td class="memTemplParams" colspan="2">template&lt;typename TTo , typename TFrom &gt; </td></tr>
<tr class="memitem:a7b744966a1f5dee04392904a8886b3fc"><td class="memTemplItemLeft" align="right" valign="top">TTo&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a7b744966a1f5dee04392904a8886b3fc">CheckedCast</a> (TFrom value)</td></tr>
<tr class="memdesc:a7b744966a1f5dee04392904a8886b3fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the specified value falls into the range of values of type <code>TTo</code> and if it does casts it to the type <code>TTo</code>.  <a href="#a7b744966a1f5dee04392904a8886b3fc">More...</a><br /></td></tr>
<tr class="separator:a7b744966a1f5dee04392904a8886b3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18d1f9ebb008487e571a171489df598"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae18d1f9ebb008487e571a171489df598"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ae18d1f9ebb008487e571a171489df598">static_holder</a> ()</td></tr>
<tr class="memdesc:ae18d1f9ebb008487e571a171489df598"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton accessor function.  <a href="#ae18d1f9ebb008487e571a171489df598">More...</a><br /></td></tr>
<tr class="separator:ae18d1f9ebb008487e571a171489df598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151fa5ea871885b82ea03ea1b1fc0ea4"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a151fa5ea871885b82ea03ea1b1fc0ea4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_system_1_1_scope_guard.html">ScopeGuard</a>&lt; F &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a151fa5ea871885b82ea03ea1b1fc0ea4">MakeScopeGuard</a> (F f)</td></tr>
<tr class="memdesc:a151fa5ea871885b82ea03ea1b1fc0ea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A factory function that creates instances of ScopedGuard class.  <a href="#a151fa5ea871885b82ea03ea1b1fc0ea4">More...</a><br /></td></tr>
<tr class="separator:a151fa5ea871885b82ea03ea1b1fc0ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01a209cda2bf0448f60b05f5430b489"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:ae01a209cda2bf0448f60b05f5430b489"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ae01a209cda2bf0448f60b05f5430b489">setter_wrap</a> (void(*pSetter)(T2), T value)</td></tr>
<tr class="memdesc:ae01a209cda2bf0448f60b05f5430b489"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for static setter functions with type conversion.  <a href="#ae01a209cda2bf0448f60b05f5430b489">More...</a><br /></td></tr>
<tr class="separator:ae01a209cda2bf0448f60b05f5430b489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aaef5031be74f44d35fba5420def3d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , typename Host , typename HostSet &gt; </td></tr>
<tr class="memitem:a90aaef5031be74f44d35fba5420def3d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; HostSet, Host &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a90aaef5031be74f44d35fba5420def3d">setter_wrap</a> (Host *const host, void(HostSet::*pSetter)(T2), T value)</td></tr>
<tr class="memdesc:a90aaef5031be74f44d35fba5420def3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for instance setter functions with type conversion.  <a href="#a90aaef5031be74f44d35fba5420def3d">More...</a><br /></td></tr>
<tr class="separator:a90aaef5031be74f44d35fba5420def3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa831bd44fb54318e784fcc8700c6bf93"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa831bd44fb54318e784fcc8700c6bf93"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aa831bd44fb54318e784fcc8700c6bf93">setter_increment_wrap</a> (T(*pGetter)(), void(*pSetter)(T))</td></tr>
<tr class="memdesc:aa831bd44fb54318e784fcc8700c6bf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s increment expressions targeting class' property that has setter and getter defined, into invocation of this function.  <a href="#aa831bd44fb54318e784fcc8700c6bf93">More...</a><br /></td></tr>
<tr class="separator:aa831bd44fb54318e784fcc8700c6bf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add748986ad4492919ed9429588ace08f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Host , typename HostGet , typename HostSet &gt; </td></tr>
<tr class="memitem:add748986ad4492919ed9429588ace08f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; HostGet, Host &gt;::value &amp;&amp;std::is_base_of&lt; HostSet, Host &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#add748986ad4492919ed9429588ace08f">setter_increment_wrap</a> (Host *const host, T(HostGet::*pGetter)(), void(HostSet::*pSetter)(T))</td></tr>
<tr class="memdesc:add748986ad4492919ed9429588ace08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s increment expressions targeting class' property that has setter and getter defined, into invocation of this function.  <a href="#add748986ad4492919ed9429588ace08f">More...</a><br /></td></tr>
<tr class="separator:add748986ad4492919ed9429588ace08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e340207f6853878e1555ea02f6f3be"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a46e340207f6853878e1555ea02f6f3be"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a46e340207f6853878e1555ea02f6f3be">setter_post_increment_wrap</a> (T(*pGetter)(), void(*pSetter)(T))</td></tr>
<tr class="memdesc:a46e340207f6853878e1555ea02f6f3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s post-increment expressions targeting class' property that has setter and getter defined, into invocation of this function.  <a href="#a46e340207f6853878e1555ea02f6f3be">More...</a><br /></td></tr>
<tr class="separator:a46e340207f6853878e1555ea02f6f3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de6b22fbee5ee9e78e805f0f8566ff8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Host , typename HostGet , typename HostSet &gt; </td></tr>
<tr class="memitem:a1de6b22fbee5ee9e78e805f0f8566ff8"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; HostGet, Host &gt;::value &amp;&amp;std::is_base_of&lt; HostSet, Host &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1de6b22fbee5ee9e78e805f0f8566ff8">setter_post_increment_wrap</a> (Host *const host, T(HostGet::*pGetter)(), void(HostSet::*pSetter)(T))</td></tr>
<tr class="memdesc:a1de6b22fbee5ee9e78e805f0f8566ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s post-increment expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for non-const getter).  <a href="#a1de6b22fbee5ee9e78e805f0f8566ff8">More...</a><br /></td></tr>
<tr class="separator:a1de6b22fbee5ee9e78e805f0f8566ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1893f3ad5cded8e7d64c564f8423bcca"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Host , typename HostConstGet , typename HostSet &gt; </td></tr>
<tr class="memitem:a1893f3ad5cded8e7d64c564f8423bcca"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; HostConstGet, Host &gt;::value &amp;&amp;std::is_base_of&lt; HostSet, Host &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1893f3ad5cded8e7d64c564f8423bcca">setter_post_increment_wrap</a> (Host *const host, T(HostConstGet::*pGetter)() const, void(HostSet::*pSetter)(T))</td></tr>
<tr class="memdesc:a1893f3ad5cded8e7d64c564f8423bcca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s post-increment expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for const getter).  <a href="#a1893f3ad5cded8e7d64c564f8423bcca">More...</a><br /></td></tr>
<tr class="separator:a1893f3ad5cded8e7d64c564f8423bcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7e6b3d01541b653201905fd0ccb24b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb7e6b3d01541b653201905fd0ccb24b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#afb7e6b3d01541b653201905fd0ccb24b">setter_decrement_wrap</a> (T(*pGetter)(), void(*pSetter)(T))</td></tr>
<tr class="memdesc:afb7e6b3d01541b653201905fd0ccb24b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s pre-decrement expressions targeting class' property that has setter and getter defined, into invocation of this function.  <a href="#afb7e6b3d01541b653201905fd0ccb24b">More...</a><br /></td></tr>
<tr class="separator:afb7e6b3d01541b653201905fd0ccb24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a0796f4d307292d67463ffd7ff50d3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Host , typename HostGet , typename HostSet &gt; </td></tr>
<tr class="memitem:a31a0796f4d307292d67463ffd7ff50d3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; HostGet, Host &gt;::value &amp;&amp;std::is_base_of&lt; HostSet, Host &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a31a0796f4d307292d67463ffd7ff50d3">setter_decrement_wrap</a> (Host *const host, T(HostGet::*pGetter)(), void(HostSet::*pSetter)(T))</td></tr>
<tr class="memdesc:a31a0796f4d307292d67463ffd7ff50d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s pre-decrement expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for non-const getter).  <a href="#a31a0796f4d307292d67463ffd7ff50d3">More...</a><br /></td></tr>
<tr class="separator:a31a0796f4d307292d67463ffd7ff50d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4f22987eee2f3d63ad16e9ffd0fb1d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Host , typename HostConstGet , typename HostSet &gt; </td></tr>
<tr class="memitem:a1e4f22987eee2f3d63ad16e9ffd0fb1d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; HostConstGet, Host &gt;::value &amp;&amp;std::is_base_of&lt; HostSet, Host &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1e4f22987eee2f3d63ad16e9ffd0fb1d">setter_decrement_wrap</a> (Host *const host, T(HostConstGet::*pGetter)() const, void(HostSet::*pSetter)(T))</td></tr>
<tr class="memdesc:a1e4f22987eee2f3d63ad16e9ffd0fb1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s pre-decrement expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for const getter).  <a href="#a1e4f22987eee2f3d63ad16e9ffd0fb1d">More...</a><br /></td></tr>
<tr class="separator:a1e4f22987eee2f3d63ad16e9ffd0fb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad549475f4530f5927b98805bf84fa43e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad549475f4530f5927b98805bf84fa43e"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad549475f4530f5927b98805bf84fa43e">setter_post_decrement_wrap</a> (T(*pGetter)(), void(*pSetter)(T))</td></tr>
<tr class="memdesc:ad549475f4530f5927b98805bf84fa43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s post-decrement expressions targeting class' property that has setter and getter defined, into invocation of this function.  <a href="#ad549475f4530f5927b98805bf84fa43e">More...</a><br /></td></tr>
<tr class="separator:ad549475f4530f5927b98805bf84fa43e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7208b97f8a19c9adda23f440ef03d1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Host , typename HostGet , typename HostSet &gt; </td></tr>
<tr class="memitem:aad7208b97f8a19c9adda23f440ef03d1"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; HostGet, Host &gt;::value &amp;&amp;std::is_base_of&lt; HostSet, Host &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aad7208b97f8a19c9adda23f440ef03d1">setter_post_decrement_wrap</a> (Host *const host, T(HostGet::*pGetter)(), void(HostSet::*pSetter)(T))</td></tr>
<tr class="memdesc:aad7208b97f8a19c9adda23f440ef03d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s post-decrement expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for non-const getter).  <a href="#aad7208b97f8a19c9adda23f440ef03d1">More...</a><br /></td></tr>
<tr class="separator:aad7208b97f8a19c9adda23f440ef03d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dbedddc50a44853137fc3692bd9bf3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Host , typename HostConstGet , typename HostSet &gt; </td></tr>
<tr class="memitem:a41dbedddc50a44853137fc3692bd9bf3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_base_of&lt; HostConstGet, Host &gt;::value &amp;&amp;std::is_base_of&lt; HostSet, Host &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a41dbedddc50a44853137fc3692bd9bf3">setter_post_decrement_wrap</a> (Host *const host, T(HostConstGet::*pGetter)() const, void(HostSet::*pSetter)(T))</td></tr>
<tr class="memdesc:a41dbedddc50a44853137fc3692bd9bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Porter translates C#'s post-decrement expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for const getter).  <a href="#a41dbedddc50a44853137fc3692bd9bf3">More...</a><br /></td></tr>
<tr class="separator:a41dbedddc50a44853137fc3692bd9bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f67c6cefb488176e545cb5644dc216"><td class="memTemplParams" colspan="2">template&lt;class T , class ... Args&gt; </td></tr>
<tr class="memitem:af8f67c6cefb488176e545cb5644dc216"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; T &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#af8f67c6cefb488176e545cb5644dc216">MakeObject</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:af8f67c6cefb488176e545cb5644dc216"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates object on heap and returns shared pointer to it.  <a href="#af8f67c6cefb488176e545cb5644dc216">More...</a><br /></td></tr>
<tr class="separator:af8f67c6cefb488176e545cb5644dc216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a941a2e15bfcf1d22edcd4b83d54eff"><td class="memTemplParams" colspan="2">template&lt;class T , class ... Args&gt; </td></tr>
<tr class="memitem:a3a941a2e15bfcf1d22edcd4b83d54eff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt; T &gt;::value, T &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a3a941a2e15bfcf1d22edcd4b83d54eff">MakeObject</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a3a941a2e15bfcf1d22edcd4b83d54eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates object on heap and returns shared pointer to it.  <a href="#a3a941a2e15bfcf1d22edcd4b83d54eff">More...</a><br /></td></tr>
<tr class="separator:a3a941a2e15bfcf1d22edcd4b83d54eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d32c7b0dffb0727222fc5d786328fba"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a9d32c7b0dffb0727222fc5d786328fba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a9d32c7b0dffb0727222fc5d786328fba">operator==</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; &amp;x, const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt; &amp;y)</td></tr>
<tr class="memdesc:a9d32c7b0dffb0727222fc5d786328fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equal-compares two smart pointers.  <a href="#a9d32c7b0dffb0727222fc5d786328fba">More...</a><br /></td></tr>
<tr class="separator:a9d32c7b0dffb0727222fc5d786328fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e91fb0cd7a3668b8b429e8e693794f7"><td class="memTemplParams" colspan="2">template&lt;class X , class Y &gt; </td></tr>
<tr class="memitem:a1e91fb0cd7a3668b8b429e8e693794f7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1e91fb0cd7a3668b8b429e8e693794f7">operator!=</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; &amp;x, const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt; &amp;y)</td></tr>
<tr class="memdesc:a1e91fb0cd7a3668b8b429e8e693794f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-equal-compares two smart pointers.  <a href="#a1e91fb0cd7a3668b8b429e8e693794f7">More...</a><br /></td></tr>
<tr class="separator:a1e91fb0cd7a3668b8b429e8e693794f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2776c071edcbc9b58f99a48b4eb20ae3"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a2776c071edcbc9b58f99a48b4eb20ae3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a2776c071edcbc9b58f99a48b4eb20ae3">operator==</a> (std::nullptr_t, <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;x)</td></tr>
<tr class="memdesc:a2776c071edcbc9b58f99a48b4eb20ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if smart pointer is null.  <a href="#a2776c071edcbc9b58f99a48b4eb20ae3">More...</a><br /></td></tr>
<tr class="separator:a2776c071edcbc9b58f99a48b4eb20ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac084f2a184ca17d817431d853ac3d518"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:ac084f2a184ca17d817431d853ac3d518"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ac084f2a184ca17d817431d853ac3d518">operator!=</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;x, std::nullptr_t)</td></tr>
<tr class="memdesc:ac084f2a184ca17d817431d853ac3d518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if smart pointer is not null.  <a href="#ac084f2a184ca17d817431d853ac3d518">More...</a><br /></td></tr>
<tr class="separator:ac084f2a184ca17d817431d853ac3d518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b856aab2e28c274676f19667898a2d9"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:a3b856aab2e28c274676f19667898a2d9"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a3b856aab2e28c274676f19667898a2d9">operator!=</a> (std::nullptr_t, <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;x)</td></tr>
<tr class="memdesc:a3b856aab2e28c274676f19667898a2d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if smart pointer is not null.  <a href="#a3b856aab2e28c274676f19667898a2d9">More...</a><br /></td></tr>
<tr class="separator:a3b856aab2e28c274676f19667898a2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd2be66d96eb500af3f3b05715a4f23"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:accd2be66d96eb500af3f3b05715a4f23"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_scalar&lt; T &gt;::value &amp;&amp;!std::is_pointer&lt; T &gt;::value &amp;&amp;!std::is_array&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#accd2be66d96eb500af3f3b05715a4f23">operator==</a> (T const &amp;x, std::nullptr_t)</td></tr>
<tr class="memdesc:accd2be66d96eb500af3f3b05715a4f23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if value type object (ported C# structure, etc.) is null.  <a href="#accd2be66d96eb500af3f3b05715a4f23">More...</a><br /></td></tr>
<tr class="separator:accd2be66d96eb500af3f3b05715a4f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ba2986f68f4c7580170e44a6a2bcba"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af4ba2986f68f4c7580170e44a6a2bcba"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!std::is_scalar&lt; T &gt;::value &amp;&amp;!std::is_pointer&lt; T &gt;::value &amp;&amp;!std::is_array&lt; T &gt;::value, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#af4ba2986f68f4c7580170e44a6a2bcba">operator==</a> (std::nullptr_t, T const &amp;x)</td></tr>
<tr class="memdesc:af4ba2986f68f4c7580170e44a6a2bcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if value type object (ported C# structure, etc.) is null.  <a href="#af4ba2986f68f4c7580170e44a6a2bcba">More...</a><br /></td></tr>
<tr class="separator:af4ba2986f68f4c7580170e44a6a2bcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3a656299355b7c04338499b03e0b13a"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:af3a656299355b7c04338499b03e0b13a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#af3a656299355b7c04338499b03e0b13a">MakeSharedPtr</a> (X *p)</td></tr>
<tr class="memdesc:af3a656299355b7c04338499b03e0b13a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts raw pointer to smart pointer.  <a href="#af3a656299355b7c04338499b03e0b13a">More...</a><br /></td></tr>
<tr class="separator:af3a656299355b7c04338499b03e0b13a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade3f21a99628f60b40cabe2e3dd5f72"><td class="memTemplParams" colspan="2">template&lt;class X &gt; </td></tr>
<tr class="memitem:aade3f21a99628f60b40cabe2e3dd5f72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aade3f21a99628f60b40cabe2e3dd5f72">MakeSharedPtr</a> (const X *p)</td></tr>
<tr class="memdesc:aade3f21a99628f60b40cabe2e3dd5f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts raw pointer to smart pointer. Overload for const pointers. Useful e. g. when using 'this' variable in C# methods ported as const.  <a href="#aade3f21a99628f60b40cabe2e3dd5f72">More...</a><br /></td></tr>
<tr class="separator:aade3f21a99628f60b40cabe2e3dd5f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f09a7006b50f64ee0ce133b803d3cd"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a72f09a7006b50f64ee0ce133b803d3cd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a72f09a7006b50f64ee0ce133b803d3cd">static_pointer_cast</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;x)</td></tr>
<tr class="memdesc:a72f09a7006b50f64ee0ce133b803d3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts smart pointers using static_cast.  <a href="#a72f09a7006b50f64ee0ce133b803d3cd">More...</a><br /></td></tr>
<tr class="separator:a72f09a7006b50f64ee0ce133b803d3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a5c3b28998540578e44b91741497d0"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a81a5c3b28998540578e44b91741497d0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a81a5c3b28998540578e44b91741497d0">dynamic_pointer_cast</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;x)</td></tr>
<tr class="memdesc:a81a5c3b28998540578e44b91741497d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts smart pointers using dynamic_cast.  <a href="#a81a5c3b28998540578e44b91741497d0">More...</a><br /></td></tr>
<tr class="separator:a81a5c3b28998540578e44b91741497d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27873458de9389f7d347332663d1d4b9"><td class="memTemplParams" colspan="2">template&lt;class Y , class X &gt; </td></tr>
<tr class="memitem:a27873458de9389f7d347332663d1d4b9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a27873458de9389f7d347332663d1d4b9">const_pointer_cast</a> (<a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;x)</td></tr>
<tr class="memdesc:a27873458de9389f7d347332663d1d4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts smart pointers using const_cast.  <a href="#a27873458de9389f7d347332663d1d4b9">More...</a><br /></td></tr>
<tr class="separator:a27873458de9389f7d347332663d1d4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de1055f4a1e9b079afdd82d3159437a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a1de1055f4a1e9b079afdd82d3159437a"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a1de1055f4a1e9b079afdd82d3159437a">get_pointer</a> (<a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt; const &amp;x)</td></tr>
<tr class="memdesc:a1de1055f4a1e9b079afdd82d3159437a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets referenced object of smart pointer.  <a href="#a1de1055f4a1e9b079afdd82d3159437a">More...</a><br /></td></tr>
<tr class="separator:a1de1055f4a1e9b079afdd82d3159437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab95c00865efdd393135521535846fc81"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab95c00865efdd393135521535846fc81"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ab95c00865efdd393135521535846fc81">Ref</a> (T &amp;value)</td></tr>
<tr class="memdesc:ab95c00865efdd393135521535846fc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to acquire references to objects. Used to guarantee that <a class="el" href="class_system_1_1_dynamic_weak_ptr.html" title="Smart pointer class which tracks pointer modes of template arguments of stored object and updates the...">System::DynamicWeakPtr</a> updates referenced object after assignments.  <a href="#ab95c00865efdd393135521535846fc81">More...</a><br /></td></tr>
<tr class="separator:ab95c00865efdd393135521535846fc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb3acae8eccc54f13094fe930734eb3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aebb3acae8eccc54f13094fe930734eb3"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; detail::has_print_to_function&lt; T &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aebb3acae8eccc54f13094fe930734eb3">PrintTo</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; T &gt; &amp;object_ptr, std::ostream *stream)</td></tr>
<tr class="memdesc:aebb3acae8eccc54f13094fe930734eb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#aebb3acae8eccc54f13094fe930734eb3">More...</a><br /></td></tr>
<tr class="separator:aebb3acae8eccc54f13094fe930734eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acced940a0e9f18e6e92757a45f20a569"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acced940a0e9f18e6e92757a45f20a569"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!detail::has_print_to_function&lt; T &gt;::value, void &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#acced940a0e9f18e6e92757a45f20a569">PrintTo</a> (const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; T &gt; &amp;object_ptr, std::ostream *stream)</td></tr>
<tr class="memdesc:acced940a0e9f18e6e92757a45f20a569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#acced940a0e9f18e6e92757a45f20a569">More...</a><br /></td></tr>
<tr class="separator:acced940a0e9f18e6e92757a45f20a569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ad11ced7b3b84f4a9e1a5ac0b9b5da"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab0ad11ced7b3b84f4a9e1a5ac0b9b5da"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ab0ad11ced7b3b84f4a9e1a5ac0b9b5da">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; T &gt; &amp;object_ptr)</td></tr>
<tr class="memdesc:ab0ad11ced7b3b84f4a9e1a5ac0b9b5da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#ab0ad11ced7b3b84f4a9e1a5ac0b9b5da">More...</a><br /></td></tr>
<tr class="separator:ab0ad11ced7b3b84f4a9e1a5ac0b9b5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdf5edb3468e674247e125ad9e55e26"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:adbdf5edb3468e674247e125ad9e55e26"><td class="memTemplItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#adbdf5edb3468e674247e125ad9e55e26">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; T &gt; &amp;object_ptr)</td></tr>
<tr class="memdesc:adbdf5edb3468e674247e125ad9e55e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#adbdf5edb3468e674247e125ad9e55e26">More...</a><br /></td></tr>
<tr class="separator:adbdf5edb3468e674247e125ad9e55e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5abc1dba14d79109dfef912624eec8fb"><td class="memTemplParams" colspan="2">template&lt;class To , class From &gt; </td></tr>
<tr class="memitem:a5abc1dba14d79109dfef912624eec8fb"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!System::detail::has_method_get_Count&lt; From &gt;::value, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt; To &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5abc1dba14d79109dfef912624eec8fb">CastEnumerableTo</a> (const From &amp;enumerable)</td></tr>
<tr class="memdesc:a5abc1dba14d79109dfef912624eec8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the static casting of elements of the specified enumerable object to different type.  <a href="#a5abc1dba14d79109dfef912624eec8fb">More...</a><br /></td></tr>
<tr class="separator:a5abc1dba14d79109dfef912624eec8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf1302c7f611663668d258bf960dcf6"><td class="memTemplParams" colspan="2">template&lt;class To , class From &gt; </td></tr>
<tr class="memitem:abbf1302c7f611663668d258bf960dcf6"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; System::detail::has_method_get_Count&lt; From &gt;::value, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt; To &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#abbf1302c7f611663668d258bf960dcf6">CastEnumerableTo</a> (const From &amp;enumerable)</td></tr>
<tr class="memdesc:abbf1302c7f611663668d258bf960dcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the static casting of elements of the specified enumerable object to different type.  <a href="#abbf1302c7f611663668d258bf960dcf6">More...</a><br /></td></tr>
<tr class="separator:abbf1302c7f611663668d258bf960dcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c329bb6582deabe1bcd92af6e40ec5"><td class="memTemplParams" colspan="2">template&lt;class To , class From &gt; </td></tr>
<tr class="memitem:a85c329bb6582deabe1bcd92af6e40ec5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; To &gt;::value &amp;&amp;System::detail::has_method_get_Count&lt; From &gt;::value, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt; To &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a85c329bb6582deabe1bcd92af6e40ec5">DynamicCastEnumerableTo</a> (const From &amp;enumerable)</td></tr>
<tr class="memdesc:a85c329bb6582deabe1bcd92af6e40ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dynamic casting of elements of the specified enumerable object to different type.  <a href="#a85c329bb6582deabe1bcd92af6e40ec5">More...</a><br /></td></tr>
<tr class="separator:a85c329bb6582deabe1bcd92af6e40ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fdbf145376ef25a44ef81419e6563b"><td class="memTemplParams" colspan="2">template&lt;class To , class From &gt; </td></tr>
<tr class="memitem:a28fdbf145376ef25a44ef81419e6563b"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; To &gt;::value &amp;&amp;!System::detail::has_method_get_Count&lt; From &gt;::value, <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt; To &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a28fdbf145376ef25a44ef81419e6563b">DynamicCastEnumerableTo</a> (const From &amp;enumerable)</td></tr>
<tr class="memdesc:a28fdbf145376ef25a44ef81419e6563b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dynamic casting of elements of the specified enumerable object to different type.  <a href="#a28fdbf145376ef25a44ef81419e6563b">More...</a><br /></td></tr>
<tr class="separator:a28fdbf145376ef25a44ef81419e6563b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad409fc80a6f52315112afc7f471fdfa7"><td class="memTemplParams" colspan="2">template&lt;class To , class From &gt; </td></tr>
<tr class="memitem:ad409fc80a6f52315112afc7f471fdfa7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;(!<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; To &gt;::value), <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt; To &gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ad409fc80a6f52315112afc7f471fdfa7">DynamicCastEnumerableTo</a> (const From &amp;enumerable)</td></tr>
<tr class="memdesc:ad409fc80a6f52315112afc7f471fdfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dynamic casting of elements of the specified enumerable object to different type.  <a href="#ad409fc80a6f52315112afc7f471fdfa7">More...</a><br /></td></tr>
<tr class="separator:ad409fc80a6f52315112afc7f471fdfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389d03ff2cccd6c3ff6ee36d81a34bdf"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a389d03ff2cccd6c3ff6ee36d81a34bdf"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; From &gt;::value, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">System::Array</a>&lt; To &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a389d03ff2cccd6c3ff6ee36d81a34bdf">StaticCastArray</a> (const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">System::Array</a>&lt; From &gt;&gt; &amp;from)</td></tr>
<tr class="memdesc:a389d03ff2cccd6c3ff6ee36d81a34bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the static casting of elements of the specified array to different type. Override for cases then From is <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> obj.  <a href="#a389d03ff2cccd6c3ff6ee36d81a34bdf">More...</a><br /></td></tr>
<tr class="separator:a389d03ff2cccd6c3ff6ee36d81a34bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c59a25554d0129ba9c9d5111f9b6ff"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:aa2c59a25554d0129ba9c9d5111f9b6ff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt; From &gt;::value &amp;&amp;<a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt; From &gt;::value &amp;&amp;std::is_same&lt; To, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &gt;::value, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">System::Array</a>&lt; To &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aa2c59a25554d0129ba9c9d5111f9b6ff">StaticCastArray</a> (const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">System::Array</a>&lt; From &gt;&gt; &amp;from)</td></tr>
<tr class="memdesc:aa2c59a25554d0129ba9c9d5111f9b6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the static casting of elements of the specified array to different type. Override for cases then From is Boxable and To is <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>[].  <a href="#aa2c59a25554d0129ba9c9d5111f9b6ff">More...</a><br /></td></tr>
<tr class="separator:aa2c59a25554d0129ba9c9d5111f9b6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a179f06c894f7018a6865756961c49"><td class="memTemplParams" colspan="2">template&lt;class To , class From &gt; </td></tr>
<tr class="memitem:a95a179f06c894f7018a6865756961c49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; To &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a95a179f06c894f7018a6865756961c49">DynamicCastArray</a> (const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; From &gt;&gt; &amp;from)</td></tr>
<tr class="memdesc:a95a179f06c894f7018a6865756961c49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the dynamic casting of elements of the specified array to different type.  <a href="#a95a179f06c894f7018a6865756961c49">More...</a><br /></td></tr>
<tr class="separator:a95a179f06c894f7018a6865756961c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e80d47735b18814640a8a6ceb64aca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86e80d47735b18814640a8a6ceb64aca"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_string_literal.html">IsStringLiteral</a>&lt; T, char_t &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a86e80d47735b18814640a8a6ceb64aca">operator+</a> (T &amp;left, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;right)</td></tr>
<tr class="memdesc:a86e80d47735b18814640a8a6ceb64aca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> concatenation.  <a href="#a86e80d47735b18814640a8a6ceb64aca">More...</a><br /></td></tr>
<tr class="separator:a86e80d47735b18814640a8a6ceb64aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae353982f79c36410c671c17024ad6c5a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae353982f79c36410c671c17024ad6c5a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="struct_system_1_1_is_string_pointer.html">IsStringPointer</a>&lt; T, char_t &gt;::value, <a class="el" href="class_system_1_1_string.html">String</a> &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ae353982f79c36410c671c17024ad6c5a">operator+</a> (T &amp;left, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;right)</td></tr>
<tr class="memdesc:ae353982f79c36410c671c17024ad6c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> concatenation.  <a href="#ae353982f79c36410c671c17024ad6c5a">More...</a><br /></td></tr>
<tr class="separator:ae353982f79c36410c671c17024ad6c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23375f1805cf045f7f6bc7b77b0b57d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_system_1_1_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a23375f1805cf045f7f6bc7b77b0b57d4">operator+</a> (const char_t left, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;right)</td></tr>
<tr class="memdesc:a23375f1805cf045f7f6bc7b77b0b57d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> concatenation.  <a href="#a23375f1805cf045f7f6bc7b77b0b57d4">More...</a><br /></td></tr>
<tr class="separator:a23375f1805cf045f7f6bc7b77b0b57d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedb16cc9e68db7063a5143ce6748f32"><td class="memTemplParams" colspan="2">template&lt;class Chars , typename std::enable_if&lt; IsStringLiteral&lt; Chars, char_t &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:afedb16cc9e68db7063a5143ce6748f32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#afedb16cc9e68db7063a5143ce6748f32">operator==</a> (Chars &amp;left, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;right)</td></tr>
<tr class="memdesc:afedb16cc9e68db7063a5143ce6748f32"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> comparison.  <a href="#afedb16cc9e68db7063a5143ce6748f32">More...</a><br /></td></tr>
<tr class="separator:afedb16cc9e68db7063a5143ce6748f32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0719e67675788f6bebe51b66cd74a97f"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; IsStringPointer&lt; T, char_t &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0719e67675788f6bebe51b66cd74a97f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a0719e67675788f6bebe51b66cd74a97f">operator==</a> (T &amp;left, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;right)</td></tr>
<tr class="memdesc:a0719e67675788f6bebe51b66cd74a97f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> comparison.  <a href="#a0719e67675788f6bebe51b66cd74a97f">More...</a><br /></td></tr>
<tr class="separator:a0719e67675788f6bebe51b66cd74a97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925d936835430179503cbd69d4cf735f"><td class="memTemplParams" colspan="2">template&lt;class Chars , typename std::enable_if&lt; IsStringLiteral&lt; Chars, char_t &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a925d936835430179503cbd69d4cf735f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a925d936835430179503cbd69d4cf735f">operator!=</a> (Chars &amp;left, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;right)</td></tr>
<tr class="memdesc:a925d936835430179503cbd69d4cf735f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> comparison.  <a href="#a925d936835430179503cbd69d4cf735f">More...</a><br /></td></tr>
<tr class="separator:a925d936835430179503cbd69d4cf735f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c04fc57a97ccc76742bd4e09a40788"><td class="memTemplParams" colspan="2">template&lt;class T , typename std::enable_if&lt; IsStringPointer&lt; T, char_t &gt;::value &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a99c04fc57a97ccc76742bd4e09a40788"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a99c04fc57a97ccc76742bd4e09a40788">operator!=</a> (T &amp;left, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;right)</td></tr>
<tr class="memdesc:a99c04fc57a97ccc76742bd4e09a40788"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> comparison.  <a href="#a99c04fc57a97ccc76742bd4e09a40788">More...</a><br /></td></tr>
<tr class="separator:a99c04fc57a97ccc76742bd4e09a40788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096d02c9f312d137d94c8cedc4dce203"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a096d02c9f312d137d94c8cedc4dce203">operator==</a> (const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;left, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;right)</td></tr>
<tr class="memdesc:a096d02c9f312d137d94c8cedc4dce203"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> and string comparison.  <a href="#a096d02c9f312d137d94c8cedc4dce203">More...</a><br /></td></tr>
<tr class="separator:a096d02c9f312d137d94c8cedc4dce203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8309adc9dd024fd1607cf3301ba00917"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a8309adc9dd024fd1607cf3301ba00917">operator!=</a> (const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;left, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;right)</td></tr>
<tr class="memdesc:a8309adc9dd024fd1607cf3301ba00917"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> and string comparison.  <a href="#a8309adc9dd024fd1607cf3301ba00917">More...</a><br /></td></tr>
<tr class="separator:a8309adc9dd024fd1607cf3301ba00917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6246aaba76b34dc6c62d3dbba08e9b"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a7d6246aaba76b34dc6c62d3dbba08e9b">operator==</a> (std::nullptr_t, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a7d6246aaba76b34dc6c62d3dbba08e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if string is null.  <a href="#a7d6246aaba76b34dc6c62d3dbba08e9b">More...</a><br /></td></tr>
<tr class="separator:a7d6246aaba76b34dc6c62d3dbba08e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a389533d1d0ef57fc79242695f6f13"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#ae5a389533d1d0ef57fc79242695f6f13">operator!=</a> (std::nullptr_t, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:ae5a389533d1d0ef57fc79242695f6f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if string is null.  <a href="#ae5a389533d1d0ef57fc79242695f6f13">More...</a><br /></td></tr>
<tr class="separator:ae5a389533d1d0ef57fc79242695f6f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad14660adab7a0d4bedf71ee8b2c17f"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a0ad14660adab7a0d4bedf71ee8b2c17f">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a0ad14660adab7a0d4bedf71ee8b2c17f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a string to the output stream using UTF-8 encoding.  <a href="#a0ad14660adab7a0d4bedf71ee8b2c17f">More...</a><br /></td></tr>
<tr class="separator:a0ad14660adab7a0d4bedf71ee8b2c17f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1bdaee84413d4f69d56c211e62fedc"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a2a1bdaee84413d4f69d56c211e62fedc">operator&lt;&lt;</a> (std::wostream &amp;os, const <a class="el" href="class_system_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a2a1bdaee84413d4f69d56c211e62fedc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a string to the output stream.  <a href="#a2a1bdaee84413d4f69d56c211e62fedc">More...</a><br /></td></tr>
<tr class="separator:a2a1bdaee84413d4f69d56c211e62fedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef7599970c5d491c14238e60e00bf12"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a4ef7599970c5d491c14238e60e00bf12">operator&gt;&gt;</a> (std::istream &amp;in, <a class="el" href="class_system_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a4ef7599970c5d491c14238e60e00bf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string from the input streamusing UTF-8 encoding.  <a href="#a4ef7599970c5d491c14238e60e00bf12">More...</a><br /></td></tr>
<tr class="separator:a4ef7599970c5d491c14238e60e00bf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc19a4c97b934575d3edf13bc0a00df"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::wistream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#affc19a4c97b934575d3edf13bc0a00df">operator&gt;&gt;</a> (std::wistream &amp;in, <a class="el" href="class_system_1_1_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:affc19a4c97b934575d3edf13bc0a00df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets a string from the input stream.  <a href="#affc19a4c97b934575d3edf13bc0a00df">More...</a><br /></td></tr>
<tr class="separator:affc19a4c97b934575d3edf13bc0a00df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a93b53e5ec828a454b812900cfe8d9"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a28a93b53e5ec828a454b812900cfe8d9">PrintTo</a> (const <a class="el" href="class_system_1_1_string.html">System::String</a> &amp;value, std::ostream *os)</td></tr>
<tr class="memdesc:a28a93b53e5ec828a454b812900cfe8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints string to ostream. Mostly used for debug.  <a href="#a28a93b53e5ec828a454b812900cfe8d9">More...</a><br /></td></tr>
<tr class="separator:a28a93b53e5ec828a454b812900cfe8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b3f8d3161133d8c5c24610af4759a6"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a64b3f8d3161133d8c5c24610af4759a6">operator==</a> (std::nullptr_t, <a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>)</td></tr>
<tr class="separator:a64b3f8d3161133d8c5c24610af4759a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7979c3468cc86d56a3ead052c17ea5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a9f7979c3468cc86d56a3ead052c17ea5">operator!=</a> (std::nullptr_t, <a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>)</td></tr>
<tr class="separator:a9f7979c3468cc86d56a3ead052c17ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8aa93aea168ced06257d856bf6298f"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a2b8aa93aea168ced06257d856bf6298f">operator&lt;</a> (std::nullptr_t, <a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>)</td></tr>
<tr class="separator:a2b8aa93aea168ced06257d856bf6298f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bec47abb0fce1c591ea6f563a739854"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a7bec47abb0fce1c591ea6f563a739854">operator&lt;=</a> (std::nullptr_t, <a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>)</td></tr>
<tr class="separator:a7bec47abb0fce1c591ea6f563a739854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa638f787595c8beab6ddbf3dc96573fd"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aa638f787595c8beab6ddbf3dc96573fd">operator&gt;</a> (std::nullptr_t, <a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>)</td></tr>
<tr class="separator:aa638f787595c8beab6ddbf3dc96573fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677055ddf9f7b5c6c74dff7cdfde7ee5"><td class="memItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a677055ddf9f7b5c6c74dff7cdfde7ee5">operator&gt;=</a> (std::nullptr_t, <a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>)</td></tr>
<tr class="separator:a677055ddf9f7b5c6c74dff7cdfde7ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7ccc8e0ae73f2304c7ea8886287c8e"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#aea7ccc8e0ae73f2304c7ea8886287c8e">PrintTo</a> (<a class="el" href="class_system_1_1_time_span.html">TimeSpan</a> value, std::ostream *stream)</td></tr>
<tr class="memdesc:aea7ccc8e0ae73f2304c7ea8886287c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#aea7ccc8e0ae73f2304c7ea8886287c8e">More...</a><br /></td></tr>
<tr class="separator:aea7ccc8e0ae73f2304c7ea8886287c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e621b9612acac13e51af217c397bb8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a24e621b9612acac13e51af217c397bb8">operator&lt;&lt;</a> (std::ostream &amp;stream, <a class="el" href="class_system_1_1_time_span.html">TimeSpan</a> time_span)</td></tr>
<tr class="memdesc:a24e621b9612acac13e51af217c397bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#a24e621b9612acac13e51af217c397bb8">More...</a><br /></td></tr>
<tr class="separator:a24e621b9612acac13e51af217c397bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c6392004249a17ea4debc4ba58552c"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a75c6392004249a17ea4debc4ba58552c">operator&lt;&lt;</a> (std::wostream &amp;stream, <a class="el" href="class_system_1_1_time_span.html">TimeSpan</a> time_span)</td></tr>
<tr class="memdesc:a75c6392004249a17ea4debc4ba58552c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#a75c6392004249a17ea4debc4ba58552c">More...</a><br /></td></tr>
<tr class="separator:a75c6392004249a17ea4debc4ba58552c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bb970fa26f4717890ab607ad57f67b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#af5bb970fa26f4717890ab607ad57f67b">DECLARE_ENUM_OPERATORS</a> (<a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863">System::TypeCode</a>)</td></tr>
<tr class="memdesc:af5bb970fa26f4717890ab607ad57f67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Declaration of template arithmetic operators for values of the TypeCode enum type.  <a href="#af5bb970fa26f4717890ab607ad57f67b">More...</a><br /></td></tr>
<tr class="separator:af5bb970fa26f4717890ab607ad57f67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2f97111feb45ca9758090ca8b25824"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5d2f97111feb45ca9758090ca8b25824">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_system_1_1_type_info.html">TypeInfo</a> &amp;type_info)</td></tr>
<tr class="memdesc:a5d2f97111feb45ca9758090ca8b25824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#a5d2f97111feb45ca9758090ca8b25824">More...</a><br /></td></tr>
<tr class="separator:a5d2f97111feb45ca9758090ca8b25824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5480220f420e611ccc039aaf933cf671"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a5480220f420e611ccc039aaf933cf671">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="class_system_1_1_type_info.html">TypeInfo</a> &amp;type_info)</td></tr>
<tr class="memdesc:a5480220f420e611ccc039aaf933cf671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#a5480220f420e611ccc039aaf933cf671">More...</a><br /></td></tr>
<tr class="separator:a5480220f420e611ccc039aaf933cf671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22be25bce29021f7ba8ec02753a72a83"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a22be25bce29021f7ba8ec02753a72a83">operator==</a> (const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_uri.html">Uri</a> &gt; &amp;uri1, const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_uri.html">Uri</a> &gt; &amp;uri2)</td></tr>
<tr class="memdesc:a22be25bce29021f7ba8ec02753a72a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the URIs represented by the current and specified objects are equal.  <a href="#a22be25bce29021f7ba8ec02753a72a83">More...</a><br /></td></tr>
<tr class="separator:a22be25bce29021f7ba8ec02753a72a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe0c3395a022f0635cb72ec1c1d68da"><td class="memItemLeft" align="right" valign="top">ASPOSECPP_SHARED_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#acbe0c3395a022f0635cb72ec1c1d68da">operator!=</a> (const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_uri.html">Uri</a> &gt; &amp;uri1, const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_uri.html">Uri</a> &gt; &amp;uri2)</td></tr>
<tr class="memdesc:acbe0c3395a022f0635cb72ec1c1d68da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines if the URIs represented by the current and specified objects are not equal.  <a href="#acbe0c3395a022f0635cb72ec1c1d68da">More...</a><br /></td></tr>
<tr class="separator:acbe0c3395a022f0635cb72ec1c1d68da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd3bf20ee407a89e84edf5dbce5ece4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#adbd3bf20ee407a89e84edf5dbce5ece4">DECLARE_ENUM_OPERATORS</a> (<a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13">System::UriComponents</a>)</td></tr>
<tr class="separator:adbd3bf20ee407a89e84edf5dbce5ece4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad0d992017f89643c76af49818066e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a4ad0d992017f89643c76af49818066e0">DECLARE_ENUM_OPERATORS</a> (<a class="el" href="namespace_system.html#adefcae6e2818e910545a2713fd1c2fac">System::UriFormat</a>)</td></tr>
<tr class="separator:a4ad0d992017f89643c76af49818066e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a70f33760d771a807f9ebc9244be45"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a60a70f33760d771a807f9ebc9244be45">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_system_1_1_version.html">Version</a> &amp;version)</td></tr>
<tr class="memdesc:a60a70f33760d771a807f9ebc9244be45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#a60a70f33760d771a807f9ebc9244be45">More...</a><br /></td></tr>
<tr class="separator:a60a70f33760d771a807f9ebc9244be45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3ac9ae4b3c628fb59fc97e26afe46f1"><td class="memItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#ac3ac9ae4b3c628fb59fc97e26afe46f1">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="class_system_1_1_version.html">Version</a> &amp;version)</td></tr>
<tr class="memdesc:ac3ac9ae4b3c628fb59fc97e26afe46f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#ac3ac9ae4b3c628fb59fc97e26afe46f1">More...</a><br /></td></tr>
<tr class="separator:ac3ac9ae4b3c628fb59fc97e26afe46f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199679e3b4ba5f4e36c68d35a7769284"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a199679e3b4ba5f4e36c68d35a7769284"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a199679e3b4ba5f4e36c68d35a7769284">PrintTo</a> (const <a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; T &gt; &amp;object_ptr, std::ostream *stream)</td></tr>
<tr class="memdesc:a199679e3b4ba5f4e36c68d35a7769284"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints value to ostream. Mostly used for debug.  <a href="#a199679e3b4ba5f4e36c68d35a7769284">More...</a><br /></td></tr>
<tr class="separator:a199679e3b4ba5f4e36c68d35a7769284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab98466e5f0eaa5ae195721260cd4ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeab98466e5f0eaa5ae195721260cd4ab"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#aeab98466e5f0eaa5ae195721260cd4ab">operator&lt;&lt;</a> (std::ostream &amp;stream, const <a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; T &gt; &amp;object_ptr)</td></tr>
<tr class="memdesc:aeab98466e5f0eaa5ae195721260cd4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream using UTF-8 encoding.  <a href="#aeab98466e5f0eaa5ae195721260cd4ab">More...</a><br /></td></tr>
<tr class="separator:aeab98466e5f0eaa5ae195721260cd4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea314e116a10b2ef7b4bbc707ad580a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afea314e116a10b2ef7b4bbc707ad580a"><td class="memTemplItemLeft" align="right" valign="top">std::wostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#afea314e116a10b2ef7b4bbc707ad580a">operator&lt;&lt;</a> (std::wostream &amp;stream, const <a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; T &gt; &amp;object_ptr)</td></tr>
<tr class="memdesc:afea314e116a10b2ef7b4bbc707ad580a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert data into the stream.  <a href="#afea314e116a10b2ef7b4bbc707ad580a">More...</a><br /></td></tr>
<tr class="separator:afea314e116a10b2ef7b4bbc707ad580a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606cbef198aa57391c774ac104ce08d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a606cbef198aa57391c774ac104ce08d3">is_vp_test</a> (const ::testing::TestInfo *test_info)</td></tr>
<tr class="separator:a606cbef198aa57391c774ac104ce08d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55480df9d4eb2223c679a3e1522b1ced"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_system.html#a55480df9d4eb2223c679a3e1522b1ced">ForEachMemberGVName</a> ()</td></tr>
<tr class="separator:a55480df9d4eb2223c679a3e1522b1ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a9a14faf88f23e48915859360609eb1a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9a14faf88f23e48915859360609eb1a3"><td class="memTemplItemLeft" align="right" valign="top">decltype(Ref(std::declval&lt; T &amp; &gt;()))&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#a9a14faf88f23e48915859360609eb1a3">Ref</a> (const std::reference_wrapper&lt; T &gt; &amp;wrapper)</td></tr>
<tr class="memdesc:a9a14faf88f23e48915859360609eb1a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper to make sure Ref(std::ref(DynamicWeakPtr)) works.  <a href="#a9a14faf88f23e48915859360609eb1a3">More...</a><br /></td></tr>
<tr class="separator:a9a14faf88f23e48915859360609eb1a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6edd195298e0176863c4f759c970698"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab6edd195298e0176863c4f759c970698"><td class="memTemplItemLeft" align="right" valign="top">class ASPOSECPP_SHARED_CLASS&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_system.html#ab6edd195298e0176863c4f759c970698">Array</a></td></tr>
<tr class="separator:ab6edd195298e0176863c4f759c970698"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3f3d657a11c3e78524f9f79ed53b3613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3d657a11c3e78524f9f79ed53b3613">&#9670;&nbsp;</a></span>Action</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_system.html#a3f3d657a11c3e78524f9f79ed53b3613">System::Action</a> = typedef <a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a>&lt;void(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_delegate.html">Delegate</a> type that references methods that have no return value. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;system/action.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_system.html">System</a>;</div><div class="line"></div><div class="line"><span class="comment">// The function that prints the passed string.</span></div><div class="line"><span class="keywordtype">void</span> PrintString(<span class="keyword">const</span> <a class="code" href="class_system_1_1_string.html">String</a> &amp;<span class="keywordtype">string</span>)</div><div class="line">{</div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div><div class="line">  cout &lt;&lt; <span class="keywordtype">string</span> &lt;&lt; endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Create an instance of Action.</span></div><div class="line">  <span class="keyword">auto</span> action = <a class="code" href="class_system_1_1_multicast_delegate.html">Action&lt;String&gt;</a>(std::bind(&amp;PrintString, std::placeholders::_1));</div><div class="line"></div><div class="line">  <span class="comment">// Call the action.</span></div><div class="line">  action(u<span class="stringliteral">&quot;Hello, world!&quot;</span>);</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">This code example produces the following output:</span></div><div class="line"><span class="comment">Hello, world!</span></div><div class="line"><span class="comment">*/</span></div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>Argument list of the methods the delegate references. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64e8d7c8f13f967748bdd283b4062425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e8d7c8f13f967748bdd283b4062425">&#9670;&nbsp;</a></span>ArrayPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">System::ArrayPtr</a> = typedef <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="class_system_1_1_array.html">Array</a>&lt;T&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for 'pointer to array' type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> element type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a83cf1de8550dc36dade4fe2e6973352f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cf1de8550dc36dade4fe2e6973352f">&#9670;&nbsp;</a></span>AsyncCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::function&lt;void(<a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt;<a class="el" href="class_system_1_1_i_async_result.html">IAsyncResult</a>&gt;)&gt; <a class="el" href="namespace_system.html#a83cf1de8550dc36dade4fe2e6973352f">System::AsyncCallback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A delegate type that represents a method to be called when asynchronous operation completes. </p>

</div>
</div>
<a id="a9213610fe96fa2de18ddf8fe2e609781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9213610fe96fa2de18ddf8fe2e609781">&#9670;&nbsp;</a></span>BadImageFormatException</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_system.html#a9213610fe96fa2de18ddf8fe2e609781">System::BadImageFormatException</a> = typedef <a class="el" href="class_system_1_1_exception_wrapper.html">System::ExceptionWrapper</a>&lt;Details_BadImageFormatException&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa3211d2c7d1759df54dfdd31e7864f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3211d2c7d1759df54dfdd31e7864f9e">&#9670;&nbsp;</a></span>ByteArrayPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">System::ArrayPtr</a>&lt;uint8_t&gt; <a class="el" href="namespace_system.html#aa3211d2c7d1759df54dfdd31e7864f9e">System::ByteArrayPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for a smart pointer object that points to an array of unsigned 8-bit integers. </p>

</div>
</div>
<a id="a4a4ab0c5d3fe818e7743aad10db99e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a4ab0c5d3fe818e7743aad10db99e85">&#9670;&nbsp;</a></span>Converter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TInput , class TOutput &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_system.html#a4a4ab0c5d3fe818e7743aad10db99e85">System::Converter</a> = typedef <a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a>&lt;TOutput(TInput)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a pointer to the invokable entity that accepts a single argument of the <code>TInput</code> type and returns a value of the <code>TOutput</code> type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TInput</td><td>The type of the argument accepted by the invokable entity pointed to by the delegate </td></tr>
    <tr><td class="paramname">TOutput</td><td>The type of the value returned by the invokable entity pointed to by the delegate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6857d54ffc0b9e249ee01285ae0d4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6857d54ffc0b9e249ee01285ae0d4b1">&#9670;&nbsp;</a></span>Event</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_system.html#ab6857d54ffc0b9e249ee01285ae0d4b1">System::Event</a> = typedef <a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a>&lt;Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents an event - a mechanism through which subscribers are notified about an occurence of interest by means of a delegate invocation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Args</td><td>The types of arguments passed to the delegate when event is triggerreds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa85b02b5bcc423df7223e8c069f6343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa85b02b5bcc423df7223e8c069f6343">&#9670;&nbsp;</a></span>EventArgsPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt;<a class="el" href="class_system_1_1_event_args.html">EventArgs</a>&gt; <a class="el" href="namespace_system.html#aaa85b02b5bcc423df7223e8c069f6343">System::EventArgsPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to an instance of <a class="el" href="class_system_1_1_event_args.html" title="The base class for classes that represent a context that is passed to the event subscribers when an e...">EventArgs</a> class. </p>

</div>
</div>
<a id="af2ac70ce5544cf54b67cc546c2dc19aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ac70ce5544cf54b67cc546c2dc19aa">&#9670;&nbsp;</a></span>Exception</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_system.html#af2ac70ce5544cf54b67cc546c2dc19aa">System::Exception</a> = typedef <a class="el" href="class_system_1_1_exception_wrapper.html">ExceptionWrapper</a>&lt;Details_Exception&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias to be used instead of Details::Exception. </p>

</div>
</div>
<a id="a5cae75235e593702e499d067fd574583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cae75235e593702e499d067fd574583">&#9670;&nbsp;</a></span>ExceptionPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_system.html#a5cae75235e593702e499d067fd574583">System::ExceptionPtr</a> = typedef <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;Details_Exception&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type alias used by exception wrappers. </p>

</div>
</div>
<a id="a6f96fca81fe94f559178a54a644171bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f96fca81fe94f559178a54a644171bb">&#9670;&nbsp;</a></span>IAsyncResultPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt;<a class="el" href="class_system_1_1_i_async_result.html">IAsyncResult</a>&gt; <a class="el" href="namespace_system.html#a6f96fca81fe94f559178a54a644171bb">System::IAsyncResultPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to <a class="el" href="class_system_1_1_i_async_result.html" title="Represents the status of asynchronous operation. Objects of this class should only be allocated using...">IAsyncResult</a>. </p>

</div>
</div>
<a id="a618f1e74006853eaf440c1128a7133d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618f1e74006853eaf440c1128a7133d5">&#9670;&nbsp;</a></span>Predicate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_system.html#a618f1e74006853eaf440c1128a7133d5">System::Predicate</a> = typedef <a class="el" href="class_system_1_1_multicast_delegate.html">MulticastDelegate</a>&lt;bool(T)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents a pointer to a predicate - an invokable entity that accepts a single argument and returns a bool value. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;system/array.h&quot;</span></div><div class="line"><span class="preprocessor">#include &quot;system/predicate.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Fill the array.</span></div><div class="line">  <span class="keyword">auto</span> arr = System::MakeArray&lt;int&gt;({-1, -123, 5, 3, 7});</div><div class="line"></div><div class="line">  <span class="comment">// Create the predicate that returns an array element that is greater than 3.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> predicate = <span class="keyword">static_cast&lt;</span><a class="code" href="class_system_1_1_multicast_delegate.html">System::Predicate&lt;int&gt;</a><span class="keyword">&gt;</span>([](<span class="keywordtype">int</span> a) -&gt; <span class="keywordtype">bool</span></div><div class="line">  {</div><div class="line">      <span class="keywordflow">return</span> a &gt; 3;</div><div class="line">  });</div><div class="line"></div><div class="line">  <span class="comment">// Find the first element of the array using the created predicate and print it.</span></div><div class="line">  <span class="keywordtype">int</span> firstItem = <a class="code" href="class_system_1_1_array.html#a1ddaadf351435cafca7edf8e8f006919">System::Array&lt;int&gt;::Find</a>(arr, predicate);</div><div class="line">  std::cout &lt;&lt; firstItem &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">This code example produces the following output:</span></div><div class="line"><span class="comment">5</span></div><div class="line"><span class="comment">*/</span></div></div><!-- fragment --> <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the argument accepted by the invokable entity pointed to by the Predicate delegate type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b77ccd8c49df28c153be0462cdfdf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b77ccd8c49df28c153be0462cdfdf49">&#9670;&nbsp;</a></span>SharedPtr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a> = typedef <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for smart pointer widely used in the library. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointee type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a587c830e7b2dc7043be3f751ddd3b47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a587c830e7b2dc7043be3f751ddd3b47c">&#9670;&nbsp;</a></span>StringComparerPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt;<a class="el" href="class_system_1_1_string_comparer.html">StringComparer</a>&gt; <a class="el" href="namespace_system.html#a587c830e7b2dc7043be3f751ddd3b47c">System::StringComparerPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An alias for a shared pointer to an instance of <a class="el" href="class_system_1_1_string_comparer.html" title="Compares strings using different comparison modes. Objects of this class should only be allocated usi...">StringComparer</a> class. </p>

</div>
</div>
<a id="abe5c3c1c0dfaa917aedf42360a7e8d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5c3c1c0dfaa917aedf42360a7e8d4d">&#9670;&nbsp;</a></span>TimeZoneInfoPtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt;<a class="el" href="class_system_1_1_time_zone_info.html">TimeZoneInfo</a>&gt; <a class="el" href="namespace_system.html#abe5c3c1c0dfaa917aedf42360a7e8d4d">System::TimeZoneInfoPtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for shared pointer to an instance of <a class="el" href="class_system_1_1_time_zone_info.html" title="Represents an information destribing a particular time zone. Objects of this class should only be all...">TimeZoneInfo</a> class. </p>

</div>
</div>
<a id="a853bbfff9b63ef02809167a7e18a960f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853bbfff9b63ef02809167a7e18a960f">&#9670;&nbsp;</a></span>TimeZonePtr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt;<a class="el" href="class_system_1_1_time_zone.html">TimeZone</a>&gt; <a class="el" href="namespace_system.html#a853bbfff9b63ef02809167a7e18a960f">System::TimeZonePtr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shared pointer to an instance of <a class="el" href="class_system_1_1_time_zone.html" title="Represents a time zone. Objects of this class should only be allocated using System::MakeObject() fun...">TimeZone</a> class. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5f571893cc464ceee12eff1139802e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f571893cc464ceee12eff1139802e49">&#9670;&nbsp;</a></span>Base64FormattingOptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#a5f571893cc464ceee12eff1139802e49">System::Base64FormattingOptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration containing values that represent different formats of base-64 encoded data. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5f571893cc464ceee12eff1139802e49a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>No formatting. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5f571893cc464ceee12eff1139802e49a5bc3970c9f349fd7400f63ed6fe33fd2"></a>InsertLineBreaks&#160;</td><td class="fielddoc"><p>Insert line breaks after every 76th character. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2a8ee95b3f7f3b42eb282688dffa6d2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8ee95b3f7f3b42eb282688dffa6d2e">&#9670;&nbsp;</a></span>DateTimeKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#a2a8ee95b3f7f3b42eb282688dffa6d2e">System::DateTimeKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration values of which represent the kinds of date and time. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2a8ee95b3f7f3b42eb282688dffa6d2ea6fcdc090caeade09d0efd6253932b6f5"></a>Unspecified&#160;</td><td class="fielddoc"><p>Unspecified kind. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a8ee95b3f7f3b42eb282688dffa6d2ea2211d2dd79ba751bdc41551b05d1f807"></a>Utc&#160;</td><td class="fielddoc"><p>UTC time. </p>
</td></tr>
<tr><td class="fieldname"><a id="a2a8ee95b3f7f3b42eb282688dffa6d2ea509820290d57f333403f490dde7316f4"></a>Local&#160;</td><td class="fielddoc"><p>Local time. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad8f2b5f31e3f2582c6cfbcc24721a58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f2b5f31e3f2582c6cfbcc24721a58a">&#9670;&nbsp;</a></span>DayOfWeek</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58a">System::DayOfWeek</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enumeration that represents a day of week. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad8f2b5f31e3f2582c6cfbcc24721a58aa9d1a0949c39e66a0cd65240bc0ac9177"></a>Sunday&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8f2b5f31e3f2582c6cfbcc24721a58aa6f8522e0610541f1ef215a22ffa66ff6"></a>Monday&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8f2b5f31e3f2582c6cfbcc24721a58aa5792315f09a5d54fb7e3d066672b507f"></a>Tuesday&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8f2b5f31e3f2582c6cfbcc24721a58aa796c163589f295373e171842f37265d5"></a>Wednesday&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8f2b5f31e3f2582c6cfbcc24721a58aa78ae6f0cd191d25147e252dc54768238"></a>Thursday&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8f2b5f31e3f2582c6cfbcc24721a58aac33b138a163847cdb6caeeb7c9a126b4"></a>Friday&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad8f2b5f31e3f2582c6cfbcc24721a58aa8b7051187b9191cdcdae6ed5a10e5adc"></a>Saturday&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1aaeca0f6b610199eb45e4225aaf726e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aaeca0f6b610199eb45e4225aaf726e">&#9670;&nbsp;</a></span>EnvironmentVariableTarget</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#a1aaeca0f6b610199eb45e4225aaf726e">System::EnvironmentVariableTarget</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies the environment variable location. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1aaeca0f6b610199eb45e4225aaf726ea00430157e2152ce173a65ce6fcda7c44"></a>Process&#160;</td><td class="fielddoc"><p><a class="el" href="struct_system_1_1_environment.html" title="Environment services. This is a static type with no instance services. You should never create instan...">Environment</a> block associated with the current process. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1aaeca0f6b610199eb45e4225aaf726eab83533cb42f3e42bbf07740bc6b03e6a"></a>User&#160;</td><td class="fielddoc"><p>Registry key HKEY_CURRENT_USER\<a class="el" href="struct_system_1_1_environment.html" title="Environment services. This is a static type with no instance services. You should never create instan...">Environment</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1aaeca0f6b610199eb45e4225aaf726ead9f12bb0041cd9d3c7c46af4f5df96fe"></a>Machine&#160;</td><td class="fielddoc"><p>Registry key HKEY_LOCAL_MACHINE\<a class="el" href="namespace_system.html">System</a>\CurrentControlSet\Control\Session Manager\<a class="el" href="struct_system_1_1_environment.html" title="Environment services. This is a static type with no instance services. You should never create instan...">Environment</a>. </p>
</td></tr>
</table>

</div>
</div>
<a id="a942f422fde8ecb1591803551f6fbe9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942f422fde8ecb1591803551f6fbe9b6">&#9670;&nbsp;</a></span>MidpointRounding</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#a942f422fde8ecb1591803551f6fbe9b6">System::MidpointRounding</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies the behavior of rounding functions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a942f422fde8ecb1591803551f6fbe9b6a0c424e67e4f66bfe87bf561e57f476f4"></a>ToEven&#160;</td><td class="fielddoc"><p>Round to the nearest even number. </p>
</td></tr>
<tr><td class="fieldname"><a id="a942f422fde8ecb1591803551f6fbe9b6ab0bc5021588a7dbd6cae8ef3c5655e34"></a>AwayFromZero&#160;</td><td class="fielddoc"><p>Round to the nearest number that is away from zero. </p>
</td></tr>
</table>

</div>
</div>
<a id="a9326d04561ea76c1b9ed2866512bce58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9326d04561ea76c1b9ed2866512bce58">&#9670;&nbsp;</a></span>PlatformID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#a9326d04561ea76c1b9ed2866512bce58">System::PlatformID</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents an operating system platform. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9326d04561ea76c1b9ed2866512bce58afc4a8e0b5dc39c9d2d7da8fd535e1577"></a>Win32S&#160;</td><td class="fielddoc"><p>Win32S layer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9326d04561ea76c1b9ed2866512bce58ab54554c4e92d4e0ac2d8fc3e7990db43"></a>Win32Windows&#160;</td><td class="fielddoc"><p><a class="el" href="namespace_system_1_1_windows.html">Windows</a> 95 or <a class="el" href="namespace_system_1_1_windows.html">Windows</a> 98. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9326d04561ea76c1b9ed2866512bce58a933e15f3f3a407b683b4afbbaf3f739f"></a>Win32NT&#160;</td><td class="fielddoc"><p><a class="el" href="namespace_system_1_1_windows.html">Windows</a> NT or later. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9326d04561ea76c1b9ed2866512bce58a2f2ae2d3dcd8c5db65671da871bbb6fa"></a>WinCE&#160;</td><td class="fielddoc"><p><a class="el" href="namespace_system_1_1_windows.html">Windows</a> CE. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9326d04561ea76c1b9ed2866512bce58a6ec1bd1ea6a5d67a63b20c8f6172bddd"></a>Unix&#160;</td><td class="fielddoc"><p>Unix. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9326d04561ea76c1b9ed2866512bce58a183709ebe3a1d675014d32b94ad7ed94"></a>Xbox&#160;</td><td class="fielddoc"><p>Xbox. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9326d04561ea76c1b9ed2866512bce58a5dad7f6f2d7af4cc1196128ec251af8a"></a>MacOSX&#160;</td><td class="fielddoc"><p>Macintosh. </p>
</td></tr>
</table>

</div>
</div>
<a id="a30773bd5724c6b5016dc1a39a4930d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30773bd5724c6b5016dc1a39a4930d45">&#9670;&nbsp;</a></span>SmartPtrMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#a30773bd5724c6b5016dc1a39a4930d45">System::SmartPtrMode</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointer type: weak or shared. Defines whether pointer is being counted when it is being decided whether to delete object or not. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a30773bd5724c6b5016dc1a39a4930d45aa6156ea9d66fef24e87e841fbabf7cca"></a>Shared&#160;</td><td class="fielddoc"><p>Shared mode: pointer participates in reference counting. </p>
</td></tr>
<tr><td class="fieldname"><a id="a30773bd5724c6b5016dc1a39a4930d45a7324e3727807d95037eb19d304fd91ec"></a>Weak&#160;</td><td class="fielddoc"><p>Weak mode: pointer does not participate in reference counting. </p>
</td></tr>
</table>

</div>
</div>
<a id="a6e11f229dc342b9c5a5cf4880e3df19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e11f229dc342b9c5a5cf4880e3df19d">&#9670;&nbsp;</a></span>StringComparison</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#a6e11f229dc342b9c5a5cf4880e3df19d">System::StringComparison</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines string comparison style. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6e11f229dc342b9c5a5cf4880e3df19da470d47ad82f123fdb894af7608993b45"></a>CurrentCulture&#160;</td><td class="fielddoc"><p>Use current culture. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6e11f229dc342b9c5a5cf4880e3df19dad306e48ebb497be8a47a18f3512bb2be"></a>CurrentCultureIgnoreCase&#160;</td><td class="fielddoc"><p>Use current culture, but ignore case. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6e11f229dc342b9c5a5cf4880e3df19da1cafd57afeb525ed0ea44f6e768e6d50"></a>InvariantCulture&#160;</td><td class="fielddoc"><p>Use invariant culture. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6e11f229dc342b9c5a5cf4880e3df19da49ba78bea2e6420746a32ee1644f498a"></a>InvariantCultureIgnoreCase&#160;</td><td class="fielddoc"><p>Use invariant culture, but ignore case. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6e11f229dc342b9c5a5cf4880e3df19dac9d539922221d77591558b5841d36fd1"></a>Ordinal&#160;</td><td class="fielddoc"><p>Use ordinal sort rules. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6e11f229dc342b9c5a5cf4880e3df19da8ed060eed16572703403fdbcdbf65e32"></a>OrdinalIgnoreCase&#160;</td><td class="fielddoc"><p>Use ordinal sort rules, but ignore case. </p>
</td></tr>
</table>

</div>
</div>
<a id="ac018be9308f77dea81689cca46b1fcf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac018be9308f77dea81689cca46b1fcf2">&#9670;&nbsp;</a></span>StringSplitOptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#ac018be9308f77dea81689cca46b1fcf2">System::StringSplitOptions</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines string splitting behavior. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac018be9308f77dea81689cca46b1fcf2a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>Keep empty strings when splitting string. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac018be9308f77dea81689cca46b1fcf2af848693a8ba86ca7d0888ce5a78d3966"></a>RemoveEmptyEntries&#160;</td><td class="fielddoc"><p>Discard empty strings when splitting string. </p>
</td></tr>
</table>

</div>
</div>
<a id="a48979d2322a6e265fc61c924c8e40863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48979d2322a6e265fc61c924c8e40863">&#9670;&nbsp;</a></span>TypeCode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863">System::TypeCode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the type of an object. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863ace2c8aed9c2fa0cfbed56cbda4d8bf07"></a>Empty&#160;</td><td class="fielddoc"><p>A null reference. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a497031794414a552435f90151ac3b54b"></a>Object&#160;</td><td class="fielddoc"><p>A general type representing any reference or value type not explicitly represented by another TypeCode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a87bb9cdb34f638ec3ac651a887f3e747"></a>DBNull&#160;</td><td class="fielddoc"><p>A database null (column) value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a27226c864bac7454a8504f8edb15d95b"></a>Boolean&#160;</td><td class="fielddoc"><p>A simple type representing <a class="el" href="class_system_1_1_boolean.html" title="Class that keeps static members of System.Boolean .Net type. ">Boolean</a> values of true or false. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a8e95e84813830072b7516cfaa7dbc1a9"></a>Char&#160;</td><td class="fielddoc"><p>An integral type representing unsigned 16-bit integers with values between 0 and 65535. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a7e76fb67fc7b4cb0004bc45f2bd92723"></a>SByte&#160;</td><td class="fielddoc"><p>An integral type representing signed 8-bit integers with values between -128 and 127. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863aa245c3230debe5c956484ecc6fa93877"></a>Byte&#160;</td><td class="fielddoc"><p>An integral type representing unsigned 8-bit integers with values between 0 and 255. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a39bc2ae44b184207f560ff8619823208"></a>Int16&#160;</td><td class="fielddoc"><p>An integral type representing signed 16-bit integers with values between -32768 and 32767. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a8bd950a9d7779b83f5c30046c9aaf1cf"></a>UInt16&#160;</td><td class="fielddoc"><p>An integral type representing unsigned 16-bit integers with values between 0 and 65535. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863ac06129f6e6e15c09328365e553f1dc31"></a>Int32&#160;</td><td class="fielddoc"><p>An integral type representing signed 32-bit integers with values between -2147483648 and 2147483647. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863ae7956ed7be1c5025a27ed3cb42a396bd"></a>UInt32&#160;</td><td class="fielddoc"><p>An integral type representing unsigned 32-bit integers with values between 0 and 4294967295. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863afbde23b11d7e59af7828e81144c8b487"></a>Int64&#160;</td><td class="fielddoc"><p>An integral type representing signed 64-bit integers with values between -9223372036854775808 and 9223372036854775807. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863aaf71234725f0470ccf993e263a8b820a"></a>UInt64&#160;</td><td class="fielddoc"><p>An integral type representing unsigned 64-bit integers with values between 0 and 18446744073709551615. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a66ba162102bbf6ae31b522aec561735e"></a>Single&#160;</td><td class="fielddoc"><p>A floating point type representing values ranging from approximately 1.5 x 10 -45 to 3.4 x 10 38 with a precision of 7 digits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863ad909d38d705ce75386dd86e611a82f5b"></a>Double&#160;</td><td class="fielddoc"><p>A floating point type representing values ranging from approximately 5.0 x 10 -324 to 1.7 x 10 308 with a precision of 15-16 digits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a937504f318f04eaf0f1d701df4c4d7f3"></a>Decimal&#160;</td><td class="fielddoc"><p>A simple type representing values ranging from 1.0 x 10 -28 to approximately 7.9 x 10 28 with 28-29 significant digits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a8cf10d2341ed01492506085688270c1e"></a>DateTime&#160;</td><td class="fielddoc"><p>A type representing a date and time value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a48979d2322a6e265fc61c924c8e40863a27118326006d3829667a400ad23d5d98"></a>String&#160;</td><td class="fielddoc"><p>A sealed class type representing Unicode character strings. </p>
</td></tr>
</table>

</div>
</div>
<a id="af9931ba346cf7e3bdcdfdba5c5cf4e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9931ba346cf7e3bdcdfdba5c5cf4e13">&#9670;&nbsp;</a></span>UriComponents</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13">System::UriComponents</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents URI components. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13a827452688eed02a12178e96f924ac529"></a>Scheme&#160;</td><td class="fielddoc"><p>The Scheme data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13a21d23644baa10e1eba75fdd29e179288"></a>UserInfo&#160;</td><td class="fielddoc"><p>The UserInfo data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13ac2ca16d048ec66e04bca283eab048ec2"></a>Host&#160;</td><td class="fielddoc"><p>The Host data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13a60aaf44d4b562252c04db7f98497e9aa"></a>Port&#160;</td><td class="fielddoc"><p>The Port data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13abaafc686ded2377660b91aa4833943f6"></a>SchemeAndServer&#160;</td><td class="fielddoc"><p>The Scheme, Host and Port data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13aac70412e939d72a9234cdebb1af5867b"></a>Path&#160;</td><td class="fielddoc"><p>The LocalPath data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13a66c1b4c7f3dc385b68a9fa903ccd016d"></a>Query&#160;</td><td class="fielddoc"><p>The Query data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13ac1f15304a1e513e2feb761f690f77b26"></a>PathAndQuery&#160;</td><td class="fielddoc"><p>The LocalPath and Query data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13a21a8e46f676e60bb73c1c34a8071b48a"></a>HttpRequestUrl&#160;</td><td class="fielddoc"><p>The Scheme, Host, Port, Query and LocalPath data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13a37d01b98065725fe3a1d30acf3a0064a"></a>Fragment&#160;</td><td class="fielddoc"><p>The Fragment data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13a77ac1c528ff49cd0bc9be07c1185aaee"></a>AbsoluteUri&#160;</td><td class="fielddoc"><p>The Scheme, Host, Port, Quer, LocalPath and Fragment data. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13adedb207fd8a720b080f08c2116d2c4d9"></a>StrongPort&#160;</td><td class="fielddoc"><p>The Port data; if the port data not present in the <a class="el" href="class_system_1_1_uri.html" title="Unified resource identifier. Objects of this class should only be allocated using System::MakeObject(...">Uri</a> and a default port has been assigned to the Scheme, the default port is returned; if there is no default port, -1 is returned. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13a5518dcdf898b72b153f016e7393d462d"></a>HostAndPort&#160;</td><td class="fielddoc"><p>The Host and Port data; if the port data is not present in the <a class="el" href="class_system_1_1_uri.html" title="Unified resource identifier. Objects of this class should only be allocated using System::MakeObject(...">Uri</a> and a default port has been assigned to the Scheme, the default port is returned. If there is no default port, -1 is returned. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13ad024b548ee6d8d9067874f413f85c6b8"></a>StrongAuthority&#160;</td><td class="fielddoc"><p>The UserInfo, Host, and Port data.If no port data is in the <a class="el" href="class_system_1_1_uri.html" title="Unified resource identifier. Objects of this class should only be allocated using System::MakeObject(...">Uri</a> and a default port has been assigned to the Scheme, the default port is returned.If there is no default port, -1 is returned. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13a7bdf45907e3cecba3cc9eab322267abf"></a>NormalizedHost&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13ad7199979e3d58410669da77a1d76599e"></a>KeepDelimiter&#160;</td><td class="fielddoc"><p>Specifies that the delimiter should be included. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9931ba346cf7e3bdcdfdba5c5cf4e13afa646410dc281a96883e4ce1612f3062"></a>SerializationInfoString&#160;</td><td class="fielddoc"><p>The complete <a class="el" href="class_system_1_1_uri.html" title="Unified resource identifier. Objects of this class should only be allocated using System::MakeObject(...">Uri</a> context that is needed for <a class="el" href="class_system_1_1_uri.html" title="Unified resource identifier. Objects of this class should only be allocated using System::MakeObject(...">Uri</a> Serializers. The context includes the IPv6 scope. </p>
</td></tr>
</table>

</div>
</div>
<a id="adefcae6e2818e910545a2713fd1c2fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefcae6e2818e910545a2713fd1c2fac">&#9670;&nbsp;</a></span>UriFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#adefcae6e2818e910545a2713fd1c2fac">System::UriFormat</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies how the URI is escaped. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adefcae6e2818e910545a2713fd1c2faca6580a27ae5e36f23c67a8f9727e7f653"></a>UriEscaped&#160;</td><td class="fielddoc"><p>Escaping according to RFC-2396. </p>
</td></tr>
<tr><td class="fieldname"><a id="adefcae6e2818e910545a2713fd1c2facab048227579bc97486100c4ab806d33b9"></a>Unescaped&#160;</td><td class="fielddoc"><p>No escaping. </p>
</td></tr>
<tr><td class="fieldname"><a id="adefcae6e2818e910545a2713fd1c2facaecdddc4dd0fc27bfb60fe28833f1b500"></a>SafeUnescaped&#160;</td><td class="fielddoc"><p>Only the characters that have a reserved meaning in the URI are escaped. </p>
</td></tr>
</table>

</div>
</div>
<a id="aca29ba7cb1b9f1dbd4147235c04e5178"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca29ba7cb1b9f1dbd4147235c04e5178">&#9670;&nbsp;</a></span>UriHostNameType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#aca29ba7cb1b9f1dbd4147235c04e5178">System::UriHostNameType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the type of host name. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aca29ba7cb1b9f1dbd4147235c04e5178a88183b946cc5f0e8c96b2e66e1c74a7e"></a>Unknown&#160;</td><td class="fielddoc"><p>The host name type is not supplied. </p>
</td></tr>
<tr><td class="fieldname"><a id="aca29ba7cb1b9f1dbd4147235c04e5178a972e73b7a882d0802a4e3a16946a2f94"></a>Basic&#160;</td><td class="fielddoc"><p>The name is set but its type cannot be determined. </p>
</td></tr>
<tr><td class="fieldname"><a id="aca29ba7cb1b9f1dbd4147235c04e5178a4d3cc87f77cb704db96a7dc499206433"></a>Dns&#160;</td><td class="fielddoc"><p>DNS name. </p>
</td></tr>
<tr><td class="fieldname"><a id="aca29ba7cb1b9f1dbd4147235c04e5178a42a9137a05a60eb752dcdf982e717626"></a>IPv4&#160;</td><td class="fielddoc"><p>IPv4 address. </p>
</td></tr>
<tr><td class="fieldname"><a id="aca29ba7cb1b9f1dbd4147235c04e5178afdb7cb8f657426e7c409bfd6d1a36ce4"></a>IPv6&#160;</td><td class="fielddoc"><p>IPv6 address. </p>
</td></tr>
</table>

</div>
</div>
<a id="a548a7575f15cb0b2cebd21081f9b25b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a548a7575f15cb0b2cebd21081f9b25b6">&#9670;&nbsp;</a></span>UriKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#a548a7575f15cb0b2cebd21081f9b25b6">System::UriKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the kinds of URIs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a548a7575f15cb0b2cebd21081f9b25b6ac5e69ef1c75727c4665f4611a3465eab"></a>RelativeOrAbsolute&#160;</td><td class="fielddoc"><p>Undetermined kind. </p>
</td></tr>
<tr><td class="fieldname"><a id="a548a7575f15cb0b2cebd21081f9b25b6ab51ca26c6c89cfc9bec338f7a0d3e0c8"></a>Absolute&#160;</td><td class="fielddoc"><p>Absolute URI. </p>
</td></tr>
<tr><td class="fieldname"><a id="a548a7575f15cb0b2cebd21081f9b25b6a2ca9469819fb0fb61ff98e914a7ccca0"></a>Relative&#160;</td><td class="fielddoc"><p>Relative URI. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad24c40188222f4a76da525fce7f607d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad24c40188222f4a76da525fce7f607d1">&#9670;&nbsp;</a></span>UriPartial</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_system.html#ad24c40188222f4a76da525fce7f607d1">System::UriPartial</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Represents the parts of a URI for the <a class="el" href="class_system_1_1_uri.html#a05fe7bc86845008ce935ffcd81de8bef" title="Returns the specified portion of the URI represented by the current object. ">Uri.GetLeftPart</a> method. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad24c40188222f4a76da525fce7f607d1a827452688eed02a12178e96f924ac529"></a>Scheme&#160;</td><td class="fielddoc"><p>The scheme component of the URI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad24c40188222f4a76da525fce7f607d1a60f1a22c0e577712dfd7ff055183e4ad"></a>Authority&#160;</td><td class="fielddoc"><p>The scheme and authority components of the URI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad24c40188222f4a76da525fce7f607d1aac70412e939d72a9234cdebb1af5867b"></a>Path&#160;</td><td class="fielddoc"><p>The scheme, authority and path components of the URI. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad24c40188222f4a76da525fce7f607d1a66c1b4c7f3dc385b68a9fa903ccd016d"></a>Query&#160;</td><td class="fielddoc"><p>The scheme, authority, path and query components of the URI. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2a3b7b6bd472f4c218ddf6bcc28b6462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3b7b6bd472f4c218ddf6bcc28b6462">&#9670;&nbsp;</a></span>Cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type&gt;::type System::Cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if cast is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaee59b45d6a8565484e343936c5b249e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee59b45d6a8565484e343936c5b249e">&#9670;&nbsp;</a></span>Cast_noexcept()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type&gt;::type System::Cast_noexcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a5abc1dba14d79109dfef912624eec8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5abc1dba14d79109dfef912624eec8fb">&#9670;&nbsp;</a></span>CastEnumerableTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!System::detail::has_method_get_Count&lt;From&gt;::value,<a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt;To&gt; &gt;::type System::CastEnumerableTo </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the static casting of elements of the specified enumerable object to different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Enumerable object containing the elements to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new collection containing elements of type <code>To</code> equivalent to the elements of <code>enumerable</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to statically cast the elements of the enumerable object to </td></tr>
    <tr><td class="paramname">From</td><td>The type of enumerable object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbf1302c7f611663668d258bf960dcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbf1302c7f611663668d258bf960dcf6">&#9670;&nbsp;</a></span>CastEnumerableTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;System::detail::has_method_get_Count&lt;From&gt;::value,<a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt;To&gt; &gt;::type System::CastEnumerableTo </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the static casting of elements of the specified enumerable object to different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>is inheritor of Enumerable object with defined get_Count method and containing the elements to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new collection containing elements of type <code>To</code> equivalent to the elements of <code>enumerable</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to statically cast the elements of the enumerable object to </td></tr>
    <tr><td class="paramname">From</td><td>The type of enumerable object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7b744966a1f5dee04392904a8886b3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b744966a1f5dee04392904a8886b3fc">&#9670;&nbsp;</a></span>CheckedCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TTo System::CheckedCast </td>
          <td>(</td>
          <td class="paramtype">TFrom&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the specified value falls into the range of values of type <code>TTo</code> and if it does casts it to the type <code>TTo</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of type <code>TTo</code> equivalent to <code>value</code> </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">OverflowException</td><td>If the specified value does not fall into the range of values represented by the <code>TTo</code> type </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>The type to which the specified value is to be cast </td></tr>
    <tr><td class="paramname">TFrom</td><td>The type of the specified value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28059507def8470e7000bdd82634ee05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28059507def8470e7000bdd82634ee05">&#9670;&nbsp;</a></span>Compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , typename TB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!std::is_floating_point&lt;TA&gt;::value &amp;&amp; !std::is_floating_point&lt;TB&gt;::value, int&gt; System::Compare </td>
          <td>(</td>
          <td class="paramtype">const TA &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TB &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first comparand </td></tr>
    <tr><td class="paramname">b</td><td>The second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>a</code> compares less than <code>b</code>; 0 if the values are equal; 1 if <code>a</code> compares greater than <code>b</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TA</td><td>The type of the first comparand </td></tr>
    <tr><td class="paramname">TB</td><td>The type of the second comparand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9e024123b882559b0a97cbd6e9b66d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e024123b882559b0a97cbd6e9b66d8c">&#9670;&nbsp;</a></span>Compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , typename TB &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_floating_point&lt;TA&gt;::value &amp;&amp; std::is_floating_point&lt;TB&gt;::value, int&gt; System::Compare </td>
          <td>(</td>
          <td class="paramtype">const TA &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TB &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two floating point values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first comparand </td></tr>
    <tr><td class="paramname">b</td><td>The second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 if <code>a</code> compares less than <code>b</code>; 0 if the values are equal; 1 if <code>a</code> compares greater than <code>b</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TA</td><td>The type of the first comparand </td></tr>
    <tr><td class="paramname">TB</td><td>The type of the second comparand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27873458de9389f7d347332663d1d4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27873458de9389f7d347332663d1d4b9">&#9670;&nbsp;</a></span>const_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;Y&gt; System::const_pointer_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts smart pointers using const_cast. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Source pointer pointee type. </td></tr>
    <tr><td class="paramname">Y</td><td>Target pointer pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer after cast. </dd></dl>

</div>
</div>
<a id="a1786be517f2529f586b668174cb46232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1786be517f2529f586b668174cb46232">&#9670;&nbsp;</a></span>ConstCast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type System::ConstCast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs const cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a29657c7a3a1c7dd772de02adc9db5975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29657c7a3a1c7dd772de02adc9db5975">&#9670;&nbsp;</a></span>DECLARE_ENUM_OPERATORS() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::DECLARE_ENUM_OPERATORS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58a">System::DayOfWeek</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declaration of template arithmetic operators for values of the DayOfWeek enum type. </p>

</div>
</div>
<a id="af5bb970fa26f4717890ab607ad57f67b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bb970fa26f4717890ab607ad57f67b">&#9670;&nbsp;</a></span>DECLARE_ENUM_OPERATORS() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::DECLARE_ENUM_OPERATORS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_system.html#a48979d2322a6e265fc61c924c8e40863">System::TypeCode</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Declaration of template arithmetic operators for values of the TypeCode enum type. </p>

</div>
</div>
<a id="adbd3bf20ee407a89e84edf5dbce5ece4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd3bf20ee407a89e84edf5dbce5ece4">&#9670;&nbsp;</a></span>DECLARE_ENUM_OPERATORS() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::DECLARE_ENUM_OPERATORS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_system.html#af9931ba346cf7e3bdcdfdba5c5cf4e13">System::UriComponents</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ad0d992017f89643c76af49818066e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad0d992017f89643c76af49818066e0">&#9670;&nbsp;</a></span>DECLARE_ENUM_OPERATORS() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">System::DECLARE_ENUM_OPERATORS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_system.html#adefcae6e2818e910545a2713fd1c2fac">System::UriFormat</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a463a73466d9d7e1d18048ea49e89f08a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463a73466d9d7e1d18048ea49e89f08a">&#9670;&nbsp;</a></span>Default() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::enable_if&lt;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value, T&amp;&gt;::type System::Default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the default-constructed instance of the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type whose instance is returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a245feaf217b8be306d77381a0b9f809d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245feaf217b8be306d77381a0b9f809d">&#9670;&nbsp;</a></span>Default() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;T&gt;::value, T&amp;&gt;::type System::Default </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the default-constructed instance of the specified type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type whose instance is returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e949f5f9fa7dffbbd28dea430f21993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e949f5f9fa7dffbbd28dea430f21993">&#9670;&nbsp;</a></span>DoTryFinally() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Details::is_lambda_void_void&lt;T&gt;::value&gt; System::DoTryFinally </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>tryBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>finallyBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sigle function that emulates behavior of C#'s try[-catch]-finally statement. During Porting of C#'s try[-catch]-finally statement with Porter's option finally_statement_as_lambda set to true, the statement is translated into the invocation of this method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tryBlock</td><td>The function object whose body contains the implementation of the try[-catch] part of the try[-catch]-finally statemet being emulated </td></tr>
    <tr><td class="paramname">finallyBlock</td><td>The function object whose body contains the implementation of the finally part of the try[-catch]-finally statement being emulated </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the function object that implements the try[-catch] part of the try[-catch]-finally statement being emulated </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function object that implements the finally part of the try[-catch]-finally statement being emulated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd3768c9651bfcdf2484f5bccbee320e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3768c9651bfcdf2484f5bccbee320e">&#9670;&nbsp;</a></span>DoTryFinally() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Details::is_lambda_void_boolref&lt;T&gt;::value, bool&gt; System::DoTryFinally </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>tryBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>finallyBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sigle function that emulates behavior of C#'s try[-catch]-finally statement. During Porting of C#'s try[-catch]-finally statement with Porter's option finally_statement_as_lambda set to true, the statement is translated into the invocation of this method. This overload handles the case in which the return value of the function object that implements the try[-catch] part of the try[-catch]-finally statement is bool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tryBlock</td><td>The function object whose body contains the implementation of the try[-catch] part of the try[-catch]-finally statemet being emulated </td></tr>
    <tr><td class="paramname">finallyBlock</td><td>The function object whose body contains the implementation of the finally part of the try[-catch]-finally statement being emulated </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the function object that implements the try[-catch] part of the try[-catch]-finally statement being emulated </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function object that implements the finally part of the try[-catch]-finally statement being emulated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a57fe04830ee0cb8b19e26d72e3d27aa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57fe04830ee0cb8b19e26d72e3d27aa6">&#9670;&nbsp;</a></span>DoTryFinally() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Details::is_lambda_nonovoid_boolref&lt;T&gt;::value, std::optional&lt;std::result_of_t&lt;T(bool&amp;)&gt; &gt; &gt; System::DoTryFinally </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>tryBlock</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>finallyBlock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The sigle function that emulates behavior of C#'s try[-catch]-finally statement. During Porting of C#'s try[-catch]-finally statement with Porter's option finally_statement_as_lambda set to true, the statement is translated into the invocation of this method. This overload handles the case in which the return value of the function object that implements the try[-catch] part of the try[-catch]-finally statement is bool&amp;. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tryBlock</td><td>The function object whose body contains the implementation of the try[-catch] part of the try[-catch]-finally statemet being emulated </td></tr>
    <tr><td class="paramname">finallyBlock</td><td>The function object whose body contains the implementation of the finally part of the try[-catch]-finally statement being emulated </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the function object that implements the try[-catch] part of the try[-catch]-finally statement being emulated </td></tr>
    <tr><td class="paramname">F</td><td>The type of the function object that implements the finally part of the try[-catch]-finally statement being emulated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81a5c3b28998540578e44b91741497d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a5c3b28998540578e44b91741497d0">&#9670;&nbsp;</a></span>dynamic_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;Y&gt; System::dynamic_pointer_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts smart pointers using dynamic_cast. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Source pointer pointee type. </td></tr>
    <tr><td class="paramname">Y</td><td>Target pointer pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer after cast. </dd></dl>

</div>
</div>
<a id="a65f75c58083a9f099cf712e70ab2328a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f75c58083a9f099cf712e70ab2328a">&#9670;&nbsp;</a></span>DynamicCast() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TFrom&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value &amp;&amp; (std::is_convertible&lt;TTo, TFrom&gt;::value || std::is_base_of&lt;TTo, TFrom&gt;::value), TTo&gt;::type System::DynamicCast </td>
          <td>(</td>
          <td class="paramtype">const TFrom &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs dynamic cast on Exception objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target Exception type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source Exception type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if cast is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0be32cc2000153c8e2bc4b181a52df64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be32cc2000153c8e2bc4b181a52df64">&#9670;&nbsp;</a></span>DynamicCast() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_enum&lt;TTo&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type&gt;::type System::DynamicCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs dynamic cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if cast is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3b78ffbf79c9b5ec9ecfd6dd2a23977"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b78ffbf79c9b5ec9ecfd6dd2a23977">&#9670;&nbsp;</a></span>DynamicCast() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_enum&lt;TTo&gt;::value, TTo&gt;::type System::DynamicCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unboxes boxed enum via cast. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target enum type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the object to unbox data from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unboxed enum value. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if obj is not a boxed enum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1933f4f06c4e203b5785fe32c6f8fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1933f4f06c4e203b5785fe32c6f8fcf">&#9670;&nbsp;</a></span>DynamicCast() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type System::DynamicCast </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs dynamic cast of null objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr. </dd></dl>

</div>
</div>
<a id="ab35bb077928360ee2d4a866d94d5fdf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35bb077928360ee2d4a866d94d5fdf9">&#9670;&nbsp;</a></span>DynamicCast() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TFrom&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;TFrom&gt;::value &amp;&amp; std::is_convertible&lt;TTo, TFrom&gt;::value , TTo&gt;::type System::DynamicCast </td>
          <td>(</td>
          <td class="paramtype">TFrom &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs dynamic cast on non-pointer objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result. </dd></dl>

</div>
</div>
<a id="aa049b684335a5c4eb02b66f795887d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa049b684335a5c4eb02b66f795887d8f">&#9670;&nbsp;</a></span>DynamicCast() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;<a class="el" href="class_system_1_1_object.html">System::Object</a>, TFrom&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, TTo&gt;::type System::DynamicCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs dynamic cast on Objects to Exception objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target Exception type. </td></tr>
    <tr><td class="paramname">TFrom</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if cast is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67461a4a908d3976678e3028e0b7b9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67461a4a908d3976678e3028e0b7b9e7">&#9670;&nbsp;</a></span>DynamicCast() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_pointer&lt;TTo&gt;::value &amp;&amp; std::is_same&lt;IntPtr, TFrom&gt;::value, TTo&gt;::type System::DynamicCast </td>
          <td>(</td>
          <td class="paramtype">TFrom&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs dynamic cast from IntPtr to pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Source IntPtr value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result. </dd></dl>

</div>
</div>
<a id="a78958162ebbe8cbc0debbe905cb37c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78958162ebbe8cbc0debbe905cb37c13">&#9670;&nbsp;</a></span>DynamicCast_noexcept() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TFrom&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value &amp;&amp; (std::is_convertible&lt;TTo, TFrom&gt;::value || std::is_base_of&lt;TTo, TFrom&gt;::value), TTo&gt;::type System::DynamicCast_noexcept </td>
          <td>(</td>
          <td class="paramtype">const TFrom &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs dynamic cast on Exception objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target Exception type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source Exception type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="addc6991e5a0db8641b4abc40454697ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc6991e5a0db8641b4abc40454697ff">&#9670;&nbsp;</a></span>DynamicCast_noexcept() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type&gt;::type System::DynamicCast_noexcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs dynamic cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a013a9d78d740f2a82c7967cdaf9f625b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013a9d78d740f2a82c7967cdaf9f625b">&#9670;&nbsp;</a></span>DynamicCast_noexcept() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;<a class="el" href="class_system_1_1_object.html">System::Object</a>, TFrom&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, TTo&gt;::type System::DynamicCast_noexcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs dynamic cast on Objects to Exception objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target Exception type. </td></tr>
    <tr><td class="paramname">TFrom</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a95a179f06c894f7018a6865756961c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a179f06c894f7018a6865756961c49">&#9670;&nbsp;</a></span>DynamicCastArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt;<a class="el" href="class_system_1_1_array.html">Array</a>&lt;To&gt; &gt; System::DynamicCastArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">Array</a>&lt; From &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the dynamic casting of elements of the specified array to different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Shared pointer to the array containing the elements to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new array containing elements of type <code>To</code> equivalent to the elements of <code>from</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to cast the elements of the specified array to </td></tr>
    <tr><td class="paramname">From</td><td>The type of elements of the elements of the arry elements of which to cast </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85c329bb6582deabe1bcd92af6e40ec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c329bb6582deabe1bcd92af6e40ec5">&#9670;&nbsp;</a></span>DynamicCastEnumerableTo() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;To&gt;::value &amp;&amp; System::detail::has_method_get_Count&lt;From&gt;::value,<a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt;To&gt; &gt;::type System::DynamicCastEnumerableTo </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the dynamic casting of elements of the specified enumerable object to different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>is inheritor of Enumerable object with defined get_Count method and containing the elements to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new collection containing elements of type <code>To</code> equivalent to the elements of <code>enumerable</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to statically cast the elements of the enumerable object to </td></tr>
    <tr><td class="paramname">From</td><td>The type of enumerable object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a28fdbf145376ef25a44ef81419e6563b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28fdbf145376ef25a44ef81419e6563b">&#9670;&nbsp;</a></span>DynamicCastEnumerableTo() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;To&gt;::value &amp;&amp; !System::detail::has_method_get_Count&lt;From&gt;::value,<a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt;To&gt; &gt;::type System::DynamicCastEnumerableTo </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the dynamic casting of elements of the specified enumerable object to different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Enumerable object containing the elements to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new collection containing elements of type <code>To</code> equivalent to the elements of <code>enumerable</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to statically cast the elements of the enumerable object to </td></tr>
    <tr><td class="paramname">From</td><td>The type of enumerable object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad409fc80a6f52315112afc7f471fdfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad409fc80a6f52315112afc7f471fdfa7">&#9670;&nbsp;</a></span>DynamicCastEnumerableTo() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class To , class From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;(!<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;To&gt;::value), <a class="el" href="class_system_1_1_collections_1_1_generic_1_1_list_ptr.html">Collections::Generic::ListPtr</a>&lt;To&gt; &gt;::type System::DynamicCastEnumerableTo </td>
          <td>(</td>
          <td class="paramtype">const From &amp;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the dynamic casting of elements of the specified enumerable object to different type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enumerable</td><td>Enumerable object containing the elements to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new collection containing elements of type <code>To</code> equivalent to the elements of <code>enumerable</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to statically cast the elements of the enumerable object to </td></tr>
    <tr><td class="paramname">From</td><td>The type of enumerable object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92a53a4b39ee98df4e9dc1babdd12078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a53a4b39ee98df4e9dc1babdd12078">&#9670;&nbsp;</a></span>EnumGetName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_system_1_1_string.html">System::String</a> System::EnumGetName </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a92a53a4b39ee98df4e9dc1babdd12078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a53a4b39ee98df4e9dc1babdd12078">&#9670;&nbsp;</a></span>EnumGetName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_system_1_1_string.html">System::String</a> System::EnumGetName </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a387e3a056a0f577be4c928489353dc70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387e3a056a0f577be4c928489353dc70">&#9670;&nbsp;</a></span>Equals()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TA , typename TB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::Equals </td>
          <td>(</td>
          <td class="paramtype">const TA &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TB &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines the equality of two values applying <a class="el" href="namespace_system.html#afd3b275a80034605a0034ba4e53ac85b">operator==()</a> to them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first comparand </td></tr>
    <tr><td class="paramname">b</td><td>The second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The boolean value returned by <a class="el" href="namespace_system.html#afd3b275a80034605a0034ba4e53ac85b">operator==()</a> applied to <code>a</code> and <code>b</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TA</td><td>The type of the first comparand </td></tr>
    <tr><td class="paramname">TB</td><td>The type of the second comparand </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad8629817d6eca8c8446d5deef6d8026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8629817d6eca8c8446d5deef6d8026">&#9670;&nbsp;</a></span>Equals< double, double >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_system.html#a387e3a056a0f577be4c928489353dc70">System::Equals</a>&lt; double, double &gt; </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization for double-precision floating point values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first comparand </td></tr>
    <tr><td class="paramname">b</td><td>The second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both values are NaN or are equal, otherwise - false </dd></dl>

</div>
</div>
<a id="a8350101d28b86bf072fdcd19577180f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8350101d28b86bf072fdcd19577180f3">&#9670;&nbsp;</a></span>Equals< float, float >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespace_system.html#a387e3a056a0f577be4c928489353dc70">System::Equals</a>&lt; float, float &gt; </td>
          <td>(</td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization for single-precision floating point values. Although two floating point NaNs are defined by IEC 60559:1989 to always compare as unequal, the contract for <a class="el" href="class_system_1_1_object.html#a12f7f848add5ff8d99ad00c5323cb301" title="Compares objects using C# Object.Equals semantics. ">System.Object.Equals</a>, requires that overrides must satisfy the requirements for an equivalence operator. Therefore, System.Double.Equals and System.Single.Equals return True when comparing two NaNs, while the equality operator returns False in that case, as required by the standard. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first comparand </td></tr>
    <tr><td class="paramname">b</td><td>The second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if both values are NaN or are equal, otherwise - false </dd></dl>

</div>
</div>
<a id="a55480df9d4eb2223c679a3e1522b1ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55480df9d4eb2223c679a3e1522b1ced">&#9670;&nbsp;</a></span>ForEachMemberGVName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string System::ForEachMemberGVName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1de1055f4a1e9b079afdd82d3159437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de1055f4a1e9b079afdd82d3159437a">&#9670;&nbsp;</a></span>get_pointer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* System::get_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; T &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets referenced object of smart pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Source smart pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Raw pointer to object referenced by smart pointer passed. </dd></dl>

</div>
</div>
<a id="ab55b792854ecac1a5000a91a93b60105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55b792854ecac1a5000a91a93b60105">&#9670;&nbsp;</a></span>GetHashCode() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_scalar&lt;T&gt;::value, int&gt;::type System::GetHashCode </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash code for the specified scalar value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The value to generate hash code for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash code generated for the specified value </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value for which the function generates hash code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae4245b30730d5469f008a24449f68c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4245b30730d5469f008a24449f68c3">&#9670;&nbsp;</a></span>GetHashCode() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_scalar&lt;T&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;T&gt;::value, int&gt;::type System::GetHashCode </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash code for the specified object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> pointing to the object to generate hash code for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash code generated for the specified object </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object for which the function generates hash code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e74118b53b9143b52751f87cba97782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e74118b53b9143b52751f87cba97782">&#9670;&nbsp;</a></span>GetHashCode() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">System::IsExceptionWrapper</a>&lt;T&gt;::value, int&gt;::type System::GetHashCode </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash code for the specified object which is exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The Exception Wrapper that contains the object to generate hash code for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash code generated for the specified object </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object for which the function generates hash code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a49714d3d76ec84aeee1afd6084f766af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49714d3d76ec84aeee1afd6084f766af">&#9670;&nbsp;</a></span>GetHashCode() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_scalar&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;T&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_exception_wrapper.html">System::IsExceptionWrapper</a>&lt;T&gt;::value, int&gt;::type System::GetHashCode </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a hash code for the specified object which is not a smart pointer nor exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>A const reference to the object to generate hash code for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The hash code generated for the specified object </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the object for which the function generates hash code </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a865f4c1988ea93d218c43d799c00709c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865f4c1988ea93d218c43d799c00709c">&#9670;&nbsp;</a></span>GetHashCode() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int System::GetHashCode </td>
          <td>(</td>
          <td class="paramtype">const std::thread::id &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specialization for std::thread::id; Returns the hash code for the specified thread object. </p>

</div>
</div>
<a id="a606cbef198aa57391c774ac104ce08d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606cbef198aa57391c774ac104ce08d3">&#9670;&nbsp;</a></span>is_vp_test()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::is_vp_test </td>
          <td>(</td>
          <td class="paramtype">const ::testing::TestInfo *&#160;</td>
          <td class="paramname"><em>test_info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a061e3d6cb50f1a228a3577ae21c994f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061e3d6cb50f1a228a3577ae21c994f7">&#9670;&nbsp;</a></span>IsEnumMetaInfoDefined() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool System::IsEnumMetaInfoDefined </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a061e3d6cb50f1a228a3577ae21c994f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061e3d6cb50f1a228a3577ae21c994f7">&#9670;&nbsp;</a></span>IsEnumMetaInfoDefined() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool System::IsEnumMetaInfoDefined </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1f688ba5469b309505fac4e64735ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f688ba5469b309505fac4e64735ca6">&#9670;&nbsp;</a></span>IsInfinity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::IsInfinity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specified value represents infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>value</code> represents infinity, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value checked by the function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aead17c6b07691d6b73033d3ec43d2590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead17c6b07691d6b73033d3ec43d2590">&#9670;&nbsp;</a></span>IsNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::IsNaN </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specified value is Not-A-Number value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>value</code> is a NaN value, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value checked by the function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4334b4226f3eebddf8dd446fd25584eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4334b4226f3eebddf8dd446fd25584eb">&#9670;&nbsp;</a></span>IsNegativeInfinity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::IsNegativeInfinity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specified value represents negative infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>value</code> represents negative infinity, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value checked by the function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd173aa9033edce7ad7ccf196b389f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd173aa9033edce7ad7ccf196b389f02">&#9670;&nbsp;</a></span>IsPositiveInfinity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::IsPositiveInfinity </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines if the specified value represents positive infinity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The value to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>value</code> represents positive infinity, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the value checked by the function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5dd4bc20c5efd68e2f6c33530cbc61ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd4bc20c5efd68e2f6c33530cbc61ac">&#9670;&nbsp;</a></span>IterateOver() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!Details::IsIterable&lt;Enumerable&gt;::value, Details::EnumeratorAdapter&lt;Enumerable, T&gt; &gt; System::IterateOver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable without begin(), end() methods with target type argument for (auto&amp; value : IterateOver&lt;SomeType&gt;(enumerable)) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The target type, it has to be returned from iterator </td></tr>
    <tr><td class="paramname">Enumerable</td><td>The type of a wrapped object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadfdbcfaab47bbc3b7403d256baef924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfdbcfaab47bbc3b7403d256baef924">&#9670;&nbsp;</a></span>IterateOver() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!Details::IsIterable&lt;Enumerable&gt;::value, Details::EnumeratorAdapter&lt;Enumerable&gt; &gt; System::IterateOver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable without begin(), end() methods with default target type argument for (auto&amp; value : IterateOver(enumerable)) analog to the following C# code foreach (var value in enumerable) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Enumerable</td><td>The type of a wrapped object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c12febbfd09cd4dd738d81547f594bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c12febbfd09cd4dd738d81547f594bb">&#9670;&nbsp;</a></span>IterateOver() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Details::IsIterable&lt;Enumerable&gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;Enumerable&gt; &gt; System::IterateOver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable with begin(), end() methods with default target type argument for (auto&amp; value : IterateOver(enumerable)) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Enumerable</td><td>The type of a wrapped object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace39ba1577eea8766768f08cb9bf127e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace39ba1577eea8766768f08cb9bf127e">&#9670;&nbsp;</a></span>IterateOver() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Details::IsIterable&lt;Enumerable&gt;::value &amp;&amp; std::is_same&lt;typename Details::ReturnTypeTrait&lt;T&gt;::ReturnType, Details::IterableValueType&lt;Enumerable&gt; &gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt;Enumerable&gt; &gt; System::IterateOver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable with begin(), end() methods with target type same as original value_type of iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Enumerable</td><td>The type of a wrapped object </td></tr>
    <tr><td class="paramname">T</td><td>The target type which has to returned from iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c9452d9492d6c87c1d04ebec7e50f5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9452d9492d6c87c1d04ebec7e50f5d">&#9670;&nbsp;</a></span>IterateOver() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;Details::IsIterable&lt;Enumerable&gt;::value &amp;&amp; !std::is_same&lt;typename Details::ReturnTypeTrait&lt;T&gt;::ReturnType, Details::IterableValueType&lt;Enumerable&gt; &gt;::value, Details::CppIteratorAdapter&lt;Enumerable, T&gt; &gt; System::IterateOver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">System::SmartPtr</a>&lt; Enumerable &gt;&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable with begin(), end() methods with different target type and original value_type of iterator. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Enumerable</td><td>The type of a wrapped object </td></tr>
    <tr><td class="paramname">T</td><td>The target type which has to returned from iterator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae74f674decd734b10d3f03a5e9f3f61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74f674decd734b10d3f03a5e9f3f61b">&#9670;&nbsp;</a></span>IterateOver() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Enumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;Enumerable&gt;::value, Details::EnumeratorAdapter&lt;Enumerable, Details::ValueTypeOfEnumerable&lt;Enumerable&gt;, Enumerable*&gt; &gt; System::IterateOver </td>
          <td>(</td>
          <td class="paramtype">const Enumerable *&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable this with default target type. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Enumerable</td><td>The type of a wrapped object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0ba66404f9a8f50c753ecc9f41b9c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ba66404f9a8f50c753ecc9f41b9c22">&#9670;&nbsp;</a></span>IterateOver() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enumerable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;Enumerable&gt;::value, Details::EnumeratorAdapter&lt;Enumerable, T, Enumerable*&gt; &gt; System::IterateOver </td>
          <td>(</td>
          <td class="paramtype">const Enumerable *&#160;</td>
          <td class="paramname"><em>enumerable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function property wraps enumerable (or iterable) object so it can be used with range-based for loop This overload for Enumerable without begin(), end() methods with target type argument for (auto&amp; value : IterateOver&lt;SomeType&gt;(enumerable)) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The target type, it has to be returned from iterator </td></tr>
    <tr><td class="paramname">Enumerable</td><td>The type of a wrapped object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c2bd56f01b6de1c99ecfdb0aa076190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c2bd56f01b6de1c99ecfdb0aa076190">&#9670;&nbsp;</a></span>MakeArray() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">ArrayPtr</a>&lt;T&gt; System::MakeArray </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; T &gt;&#160;</td>
          <td class="paramname"><em>init</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A factory function that constructs a new <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object, fills it with the elements from the specified initialization list and returns a smart pointer pointing to the <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">init</td><td>The initialization list containing the elements to fill the array with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer pointing to the constructed <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements of the <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object the function constructs <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;system/array.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">  <span class="comment">// Fill the array.</span></div><div class="line">  <span class="keyword">auto</span> arr = System::MakeArray&lt;int&gt;({-1, -123, 5, 3, 7});</div><div class="line"></div><div class="line">  <span class="comment">// Print elements of the array.</span></div><div class="line">  <span class="keywordflow">for</span>(<span class="keyword">auto</span> item: arr)</div><div class="line">  {</div><div class="line">    std::cout &lt;&lt; item &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div><div class="line">  }</div><div class="line">  std::cout &lt;&lt; std::endl;</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">This code example produces the following output:</span></div><div class="line"><span class="comment">-1 -123 5 3 7</span></div><div class="line"><span class="comment">*/</span></div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef38b36d2b0a91df3d5b4326fc75340d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef38b36d2b0a91df3d5b4326fc75340d">&#9670;&nbsp;</a></span>MakeArray() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">ArrayPtr</a>&lt;T&gt; System::MakeArray </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A factory function that constructs a new <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object passing the specified arguments to its constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments that are passed to the constructor of the <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object being constructed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer pointing to the constructed <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements of the <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object the function constructs </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa37d34b60f1cc3cff03e0a0f3bfbf3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa37d34b60f1cc3cff03e0a0f3bfbf3a0">&#9670;&nbsp;</a></span>MakeArray() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Integral , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_integral&lt;Integral&gt;::value, <a class="el" href="namespace_system.html#a64e8d7c8f13f967748bdd283b4062425">ArrayPtr</a>&lt;T&gt; &gt;::type System::MakeArray </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A factory function that constructs a new <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object passing the specified arguments to its constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the array being created. </td></tr>
    <tr><td class="paramname">args</td><td>The arguments that are passed to the constructor of the <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object being constructed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A smart pointer pointing to the constructed <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of elements of the <a class="el" href="class_system_1_1_array.html" title="Class that represents an array data structure. Objects of this class should only be allocated using S...">Array</a> object the function constructs </td></tr>
    <tr><td class="paramname">Integral</td><td>Type of array size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8f67c6cefb488176e545cb5644dc216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f67c6cefb488176e545cb5644dc216">&#9670;&nbsp;</a></span>MakeObject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;T&gt; &gt;::type System::MakeObject </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates object on heap and returns shared pointer to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Class to instantiate. </td></tr>
    <tr><td class="paramname">Args</td><td>Constructor arguments' types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> to newly created object, always in shared mode. </dd></dl>

</div>
</div>
<a id="a3a941a2e15bfcf1d22edcd4b83d54eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a941a2e15bfcf1d22edcd4b83d54eff">&#9670;&nbsp;</a></span>MakeObject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class ... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;T&gt;::value, T&gt;::type System::MakeObject </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates object on heap and returns shared pointer to it. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> to class to instantiate. </td></tr>
    <tr><td class="paramname">Args</td><td>Constructor arguments' types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Constructor arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> to newly created object, always in shared mode. </dd></dl>

</div>
</div>
<a id="a151fa5ea871885b82ea03ea1b1fc0ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151fa5ea871885b82ea03ea1b1fc0ea4">&#9670;&nbsp;</a></span>MakeScopeGuard()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_system_1_1_scope_guard.html">ScopeGuard</a>&lt;F&gt; System::MakeScopeGuard </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A factory function that creates instances of ScopedGuard class. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function object to pass to ScopedGuard class' constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instance of ScopedGuard class </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">The</td><td>type of the function object to be invoked by the constructed ScopedGuard object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3a656299355b7c04338499b03e0b13a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3a656299355b7c04338499b03e0b13a">&#9670;&nbsp;</a></span>MakeSharedPtr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;X&gt; System::MakeSharedPtr </td>
          <td>(</td>
          <td class="paramtype">X *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts raw pointer to smart pointer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Raw pointer to object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared smart pointer to object. </dd></dl>

</div>
</div>
<a id="aade3f21a99628f60b40cabe2e3dd5f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade3f21a99628f60b40cabe2e3dd5f72">&#9670;&nbsp;</a></span>MakeSharedPtr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;X&gt; System::MakeSharedPtr </td>
          <td>(</td>
          <td class="paramtype">const X *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts raw pointer to smart pointer. Overload for const pointers. Useful e. g. when using 'this' variable in C# methods ported as const. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>Raw pointer to object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Shared smart pointer to object. </dd></dl>

</div>
</div>
<a id="a1c26a170da5d1558025b3f07238e5d29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c26a170da5d1558025b3f07238e5d29">&#9670;&nbsp;</a></span>MemberwiseClone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">Object</a>&gt; System::MemberwiseClone </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs memberwise cloning using copy constructor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Class to be copy-constructed. Subclass information is being lost. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Pointer to the object to clone. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to cloned object. </dd></dl>

</div>
</div>
<a id="a1e3f7bf974593425621e8e393989dde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e3f7bf974593425621e8e393989dde8">&#9670;&nbsp;</a></span>ObjectExt::GetType< System::DateTime >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp; <a class="el" href="class_system_1_1_object_ext.html#a889c6b314efc4b36a74530a36197b185">System::ObjectExt::GetType</a>&lt; <a class="el" href="class_system_1_1_date_time.html">System::DateTime</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for <a class="el" href="class_system_1_1_date_time.html" title="Represents a specific date and time value on the time continuum. This type should be allocated on sta...">DateTime</a>. </p>

</div>
</div>
<a id="ab74362b737830718d30ab15c20f9413b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74362b737830718d30ab15c20f9413b">&#9670;&nbsp;</a></span>ObjectExt::GetType< System::String >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_system_1_1_type_info.html">System::TypeInfo</a>&amp; <a class="el" href="class_system_1_1_object_ext.html#a889c6b314efc4b36a74530a36197b185">System::ObjectExt::GetType</a>&lt; <a class="el" href="class_system_1_1_string.html">System::String</a> &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements typeof() translation. Overload for <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a>. </p>

</div>
</div>
<a id="a1d20631216c584b44d430a4b99ae6bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d20631216c584b44d430a4b99ae6bd8">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_array_segment.html">ArraySegment</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_array_segment.html">ArraySegment</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbe0c3395a022f0635cb72ec1c1d68da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe0c3395a022f0635cb72ec1c1d68da">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_uri.html">Uri</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uri1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_uri.html">Uri</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uri2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the URIs represented by the current and specified objects are not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri1</td><td>The first <a class="el" href="class_system_1_1_uri.html" title="Unified resource identifier. Objects of this class should only be allocated using System::MakeObject(...">Uri</a> object to compare </td></tr>
    <tr><td class="paramname">uri2</td><td>The second <a class="el" href="class_system_1_1_uri.html" title="Unified resource identifier. Objects of this class should only be allocated using System::MakeObject(...">Uri</a> object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if URIs not equal, otherwise - false </dd></dl>

</div>
</div>
<a id="adf2725bddced23204368544f0493ded4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2725bddced23204368544f0493ded4">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f7979c3468cc86d56a3ead052c17ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7979c3468cc86d56a3ead052c17ea5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a095def4a93da5452005616e8bff17d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095def4a93da5452005616e8bff17d9c">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, bool&gt;::type System::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object represents a value that is not equal to null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>A constant reference to an <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object to test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the specified object represents non-null value, false otherwise </dd></dl>

</div>
</div>
<a id="af588a8117ab8f22bada9b639eb7cfbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af588a8117ab8f22bada9b639eb7cfbea">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T1&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T2&gt;::value, bool&gt;::type System::operator!= </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>some</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the specified value is not equal to the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#a1d20631216c584b44d430a4b99ae6bd8">operator!=()</a> to these values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">some</td><td>A constant reference to the value that is to be used as the first comparand </td></tr>
    <tr><td class="paramname">other</td><td>A constant reference to the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object the represented value of which is to be used as the second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the comparands are not equal, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first comparand value </td></tr>
    <tr><td class="paramname">T2</td><td>The underlying type of the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object that represents the second comparand value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c6a55eec0f68556192042960c4974a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c6a55eec0f68556192042960c4974a5">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time.html">DateTime</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a925d936835430179503cbd69d4cf735f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925d936835430179503cbd69d4cf735f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Chars , typename std::enable_if&lt; IsStringLiteral&lt; Chars, char_t &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">Chars &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> comparison. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Chars</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> literal type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> literal to compare. </td></tr>
    <tr><td class="paramname">right</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if strings match, true otherwise. </dd></dl>

</div>
</div>
<a id="a99c04fc57a97ccc76742bd4e09a40788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c04fc57a97ccc76742bd4e09a40788">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; IsStringPointer&lt; T, char_t &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> comparison. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> pointer to compare. </td></tr>
    <tr><td class="paramname">right</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if strings match, true otherwise. </dd></dl>

</div>
</div>
<a id="a8309adc9dd024fd1607cf3301ba00917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8309adc9dd024fd1607cf3301ba00917">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> and string comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to convert to string and compare. </td></tr>
    <tr><td class="paramname">right</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if object string representation equals to string, true otherwise. </dd></dl>

</div>
</div>
<a id="ae5a389533d1d0ef57fc79242695f6f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a389533d1d0ef57fc79242695f6f13">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if string is null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if string is null, true otherwise. </dd></dl>

</div>
</div>
<a id="a1e91fb0cd7a3668b8b429e8e693794f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e91fb0cd7a3668b8b429e8e693794f7">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Non-equal-compares two smart pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Pointee type of first pointer. </td></tr>
    <tr><td class="paramname">Y</td><td>Pointee type of second pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>First pointer to compare. </td></tr>
    <tr><td class="paramname">y</td><td>Second pointer to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if pointers match, true otherwise. </dd></dl>

</div>
</div>
<a id="ac084f2a184ca17d817431d853ac3d518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac084f2a184ca17d817431d853ac3d518">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if smart pointer is not null. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Pointee type of pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if pointer is null, true otherwise. </dd></dl>

</div>
</div>
<a id="a3b856aab2e28c274676f19667898a2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b856aab2e28c274676f19667898a2d9">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if smart pointer is not null. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Pointee type of pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if pointer is null, true otherwise. </dd></dl>

</div>
</div>
<a id="ab42212883ca01482c5e735522aa0b158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42212883ca01482c5e735522aa0b158">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename _  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_decimal.html">Decimal</a> System::operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is a result of multiplication of the specified value and the value represented by the specified <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first multiplier </td></tr>
    <tr><td class="paramname">d</td><td>The <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object representing the second multiplier </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is a result of multiplication of <code>x</code> and the value represented by <code>d</code>. </dd></dl>

</div>
</div>
<a id="a2b2d242f5df66bdac582e2fdc0950261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2d242f5df66bdac582e2fdc0950261">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename _  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_decimal.html">Decimal</a> System::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is a sum of the specified value and the value represented by the specified <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The first summand </td></tr>
    <tr><td class="paramname">d</td><td>The constant reference to the <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object representing the second summand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is a sum of <code>x</code> and the value represented by the <code>d</code>. </dd></dl>

</div>
</div>
<a id="a2ce2bc5a752f738c594143556304ad00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce2bc5a752f738c594143556304ad00">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value &amp;&amp; std::is_class&lt;T&gt;::value, <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt;T&gt; &gt;::type System::operator+ </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always returns a default-constructed instance of the Nullable&lt;T&gt; class representing the null value. </p>

</div>
</div>
<a id="acec0b6d75181d27997407f54844cd315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec0b6d75181d27997407f54844cd315">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, T&gt;::type System::operator+ </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always returns a default-constructed instance of the Nullable&lt;T&gt; class representing the null value. </p>

</div>
</div>
<a id="aad8480c036b2207d516a783094a8546f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8480c036b2207d516a783094a8546f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value &amp;&amp; std::is_class&lt;T&gt;::value, <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt;T&gt; &gt;::type System::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always returns a default-constructed instance of the Nullable&lt;T&gt; class representing the null value. </p>

</div>
</div>
<a id="ad9fa06871065a5c7555cea2e61691c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9fa06871065a5c7555cea2e61691c3f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, T&gt;::type System::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always returns a default-constructed instance of the Nullable&lt;T&gt; class representing the null value. </p>

</div>
</div>
<a id="abc204f0b20f4133bc919ea7cae0737c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc204f0b20f4133bc919ea7cae0737c0">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt;!IsNullable&lt;T1&gt;::value &amp;&amp; !IsNullable&lt;T2&gt;::value &amp;&amp; !std::is_same&lt;T1, System::String&gt;::value, int&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto System::operator+ </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>some</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="class_system_1_1_nullable.html">System::Nullable</a>&lt;decltype(some + other.get_Value())&gt;
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums non-nullable and nullable values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Left operand type. </td></tr>
    <tr><td class="paramname">T2</td><td>Right operand type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">some</td><td>Left operand. </td></tr>
    <tr><td class="paramname">other</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Summing result. </dd></dl>

</div>
</div>
<a id="a86e80d47735b18814640a8a6ceb64aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e80d47735b18814640a8a6ceb64aca">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_string_literal.html">IsStringLiteral</a>&lt;T, char_t&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::operator+ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> concatenation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> literal type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Literal to concatenate to string. </td></tr>
    <tr><td class="paramname">right</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Concatenated string. </dd></dl>

</div>
</div>
<a id="ae353982f79c36410c671c17024ad6c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae353982f79c36410c671c17024ad6c5a">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_string_pointer.html">IsStringPointer</a>&lt;T, char_t&gt;::value, <a class="el" href="class_system_1_1_string.html">String</a>&gt;::type System::operator+ </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> concatenation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> pointer to concatenate to string. </td></tr>
    <tr><td class="paramname">right</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Concatenated string. </dd></dl>

</div>
</div>
<a id="a23375f1805cf045f7f6bc7b77b0b57d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23375f1805cf045f7f6bc7b77b0b57d4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_string.html">String</a> System::operator+ </td>
          <td>(</td>
          <td class="paramtype">const char_t&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> concatenation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>Character to concatenate to string. </td></tr>
    <tr><td class="paramname">right</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to concatenate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Concatenated string. </dd></dl>

</div>
</div>
<a id="abff7d92a82cab10d1a0d7b51ac0c6f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff7d92a82cab10d1a0d7b51ac0c6f06">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto System::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58a">DayOfWeek</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_system.html#ad8f2b5f31e3f2582c6cfbcc24721a58a">DayOfWeek</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the number of days between two days of week. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The minuend </td></tr>
    <tr><td class="paramname">b</td><td>The subtrahend </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of days between weekdays <code>a</code> and <code>b</code>; the return value is a negative number if <em>goes</em> after <b></b> </dd></dl>

</div>
</div>
<a id="a48af9f748c0c294991f6d2c546ab578a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48af9f748c0c294991f6d2c546ab578a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename _  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_decimal.html">Decimal</a> System::operator- </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is the result of subtraction of the value represented by the specified <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object from the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to subtract from </td></tr>
    <tr><td class="paramname">d</td><td>The <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object representing the subtracted value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is the result of subtraction of the value represented by <code>d</code> from <code>x</code>. </dd></dl>

</div>
</div>
<a id="ab2de841d8615daa21a10859260bf89ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2de841d8615daa21a10859260bf89ec">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename  = typename std::enable_if&lt;!IsNullable&lt;T1&gt;::value &amp;&amp; !IsNullable&lt;T2&gt;::value &amp;&amp; !std::is_same&lt;T1, System::String&gt;::value, int&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto System::operator- </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>some</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="class_system_1_1_nullable.html">System::Nullable</a>&lt;decltype(some - other.get_Value())&gt;
    </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts non-nullable and nullable values. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>Left operand type. </td></tr>
    <tr><td class="paramname">T2</td><td>Right operand type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">some</td><td>Left operand. </td></tr>
    <tr><td class="paramname">other</td><td>Right operand. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Substation result. </dd></dl>

</div>
</div>
<a id="a3f85e5e3fa771ce8078ca5aeffe97f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f85e5e3fa771ce8078ca5aeffe97f94">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename _  = typename std::enable_if&lt;std::is_arithmetic&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_decimal.html">Decimal</a> System::operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is a result of division of the specified value and the value represented by the specified <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The value to divide </td></tr>
    <tr><td class="paramname">d</td><td>The <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object representing the divisor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new instance of <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> class that represents a value that is a result of division of <code>x</code> by the value represented by <code>d</code>. </dd></dl>

</div>
</div>
<a id="a1e7589a21fb562ffda17bc088dc54b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7589a21fb562ffda17bc088dc54b1b">&#9670;&nbsp;</a></span>operator<() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b8aa93aea168ced06257d856bf6298f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8aa93aea168ced06257d856bf6298f">&#9670;&nbsp;</a></span>operator<() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af76286d7dc936ba63040b6e1daf3653a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76286d7dc936ba63040b6e1daf3653a">&#9670;&nbsp;</a></span>operator<() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, bool&gt;::type System::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always returns false. </p>

</div>
</div>
<a id="a428139c8ef33c75cb1b930c6f5bd8b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428139c8ef33c75cb1b930c6f5bd8b0c">&#9670;&nbsp;</a></span>operator<() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T1&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T2&gt;::value, bool&gt;::type System::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>some</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the specified value is less than the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#aed9988f7fe49db96f7d7b601ceb247d9">operator&lt;()</a> to these values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">some</td><td>A constant reference to the value that is to be used as the first comparand </td></tr>
    <tr><td class="paramname">other</td><td>A constant reference to the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object the represented value of which is to be used as the second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first comparand is less than the second comparand, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first comparand value </td></tr>
    <tr><td class="paramname">T2</td><td>The underlying type of the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object that represents the second comparand value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed9988f7fe49db96f7d7b601ceb247d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9988f7fe49db96f7d7b601ceb247d9">&#9670;&nbsp;</a></span>operator<() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time.html">DateTime</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a464fe6b406e6f01ff59cbb754ed3fd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464fe6b406e6f01ff59cbb754ed3fd4d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_operating_system.html">OperatingSystem</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">os</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="aeebfc84f6c2d760d582c4684c0b08fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebfc84f6c2d760d582c4684c0b08fad">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_operating_system.html">OperatingSystem</a> &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">os</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a60a70f33760d771a807f9ebc9244be45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a70f33760d771a807f9ebc9244be45">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_version.html">Version</a> &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">version</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="aeab98466e5f0eaa5ae195721260cd4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab98466e5f0eaa5ae195721260cd4ab">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">object_ptr</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="ac3ac9ae4b3c628fb59fc97e26afe46f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3ac9ae4b3c628fb59fc97e26afe46f1">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_version.html">Version</a> &amp;&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">version</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="afea314e116a10b2ef7b4bbc707ad580a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea314e116a10b2ef7b4bbc707ad580a">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[6/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">object_ptr</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a8749d77f4db04d6c8c8623b69e04c1ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8749d77f4db04d6c8c8623b69e04c1ef">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[7/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_guid.html">Guid</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">guid</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a38555a08991939399070fea9de9d1fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38555a08991939399070fea9de9d1fe5">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[8/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_guid.html">Guid</a> &amp;&#160;</td>
          <td class="paramname"><em>guid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">guid</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a5d2f97111feb45ca9758090ca8b25824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2f97111feb45ca9758090ca8b25824">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[9/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_type_info.html">TypeInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>type_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">type_info</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a5480220f420e611ccc039aaf933cf671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5480220f420e611ccc039aaf933cf671">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[10/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_type_info.html">TypeInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>type_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">type_info</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="aaec7ba86b09d07d230b5de3869f4947a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec7ba86b09d07d230b5de3869f4947a">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[11/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#af2ac70ce5544cf54b67cc546c2dc19aa">Exception</a> &amp;&#160;</td>
          <td class="paramname"><em>exception</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">exception</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="ae60c4e89a51cab6665f52e98de7ce386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60c4e89a51cab6665f52e98de7ce386">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[12/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="ac9e963a7e1144c1f4720f260bd5da0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e963a7e1144c1f4720f260bd5da0c0">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[13/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#af2ac70ce5544cf54b67cc546c2dc19aa">Exception</a> &amp;&#160;</td>
          <td class="paramname"><em>exception</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">exception</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a5d0e562f774803962af4619366e76e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0e562f774803962af4619366e76e5a">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[14/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a24e621b9612acac13e51af217c397bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e621b9612acac13e51af217c397bb8">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[15/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time_span</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">time_span</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a316db243891f53cb92ef95efda695265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316db243891f53cb92ef95efda695265">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[16/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;&#160;</td>
          <td class="paramname"><em>decimal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">decimal</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="ad5e7671eb528e2967591bfe53cd5a04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e7671eb528e2967591bfe53cd5a04d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[17/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;&#160;</td>
          <td class="paramname"><em>decimal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">decimal</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a75c6392004249a17ea4debc4ba58552c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c6392004249a17ea4debc4ba58552c">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[18/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>time_span</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">time_span</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="af984d30faf96cdc931ea85ce4ee164c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af984d30faf96cdc931ea85ce4ee164c9">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[19/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time.html">DateTime</a>&#160;</td>
          <td class="paramname"><em>date_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">date_time</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="aedc57fa0c68f8beb8fa64d139bf396ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc57fa0c68f8beb8fa64d139bf396ce">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[20/28]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time.html">DateTime</a>&#160;</td>
          <td class="paramname"><em>date_time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">date_time</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="ae51d32a20ac8cf7204dde11548d18fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51d32a20ac8cf7204dde11548d18fc9">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[21/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a18f50fd8093fff4532229c6ecbd8f487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f50fd8093fff4532229c6ecbd8f487">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[22/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">value</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a957bc825d4a178d3adfc19a5e18d10a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957bc825d4a178d3adfc19a5e18d10a0">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[23/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_object.html">System::Object</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">object</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a1057a7c46c249783d63afab4562a4b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1057a7c46c249783d63afab4562a4b9a">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[24/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_object.html">System::Object</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">object</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a0ad14660adab7a0d4bedf71ee8b2c17f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad14660adab7a0d4bedf71ee8b2c17f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[25/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a string to the output stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>An output stream object (instantiation of <code>basic_ostream</code> with <code>char</code>). </td></tr>
    <tr><td class="paramname">str</td><td>A string to be sent to the output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output stream to which the string was added. </dd></dl>

</div>
</div>
<a id="a2a1bdaee84413d4f69d56c211e62fedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1bdaee84413d4f69d56c211e62fedc">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[26/28]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a string to the output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>An output stream object (instantiation of <code>basic_ostream</code> with <code>wchar_t</code>). </td></tr>
    <tr><td class="paramname">str</td><td>A string to be sent to the output stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An output stream to which the string was added. </dd></dl>

</div>
</div>
<a id="ab0ad11ced7b3b84f4a9e1a5ac0b9b5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ad11ced7b3b84f4a9e1a5ac0b9b5da">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[27/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream using UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">object_ptr</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="adbdf5edb3468e674247e125ad9e55e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbdf5edb3468e674247e125ad9e55e26">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[28/28]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::wostream&amp; System::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::wostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert data into the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>Output stream to insert data to. </td></tr>
    <tr><td class="paramname">object_ptr</td><td><a class="el" href="namespace_system_1_1_data.html">Data</a> to insert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>stream</code>. </dd></dl>

</div>
</div>
<a id="a7b56849915f206f0e91a05273b9af5fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b56849915f206f0e91a05273b9af5fa">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bec47abb0fce1c591ea6f563a739854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bec47abb0fce1c591ea6f563a739854">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec7ad08a8f262408ecf4d0ddd7d4ea34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7ad08a8f262408ecf4d0ddd7d4ea34">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, bool&gt;::type System::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always returns false. </p>

</div>
</div>
<a id="acecc05b02ac3dd0b3aac883b68714186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecc05b02ac3dd0b3aac883b68714186">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T1&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T2&gt;::value, bool&gt;::type System::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>some</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the specified value is less or equal to the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#af03910ceff1e2bc8ed68d88b6024b629">operator&lt;=()</a> to these values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">some</td><td>A constant reference to the value that is to be used as the first comparand </td></tr>
    <tr><td class="paramname">other</td><td>A constant reference to the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object the represented value of which is to be used as the second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first comparand is less or equal to the second comparand, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first comparand value </td></tr>
    <tr><td class="paramname">T2</td><td>The underlying type of the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object that represents the second comparand value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af03910ceff1e2bc8ed68d88b6024b629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af03910ceff1e2bc8ed68d88b6024b629">&#9670;&nbsp;</a></span>operator<=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time.html">DateTime</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd3b275a80034605a0034ba4e53ac85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3b275a80034605a0034ba4e53ac85b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_array_segment.html">ArraySegment</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_array_segment.html">ArraySegment</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22be25bce29021f7ba8ec02753a72a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22be25bce29021f7ba8ec02753a72a83">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_uri.html">Uri</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uri1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_uri.html">Uri</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>uri2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the URIs represented by the current and specified objects are equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uri1</td><td>The first <a class="el" href="class_system_1_1_uri.html" title="Unified resource identifier. Objects of this class should only be allocated using System::MakeObject(...">Uri</a> object to compare </td></tr>
    <tr><td class="paramname">uri2</td><td>The second <a class="el" href="class_system_1_1_uri.html" title="Unified resource identifier. Objects of this class should only be allocated using System::MakeObject(...">Uri</a> object to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if URIs are equal, otherwise - false </dd></dl>

</div>
</div>
<a id="a3cfee24836c1a18a537a758465e07573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfee24836c1a18a537a758465e07573">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64b3f8d3161133d8c5c24610af4759a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b3f8d3161133d8c5c24610af4759a6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af996a81841a1a6d18530f6b06439b1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af996a81841a1a6d18530f6b06439b1bf">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T1&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T2&gt;::value, bool&gt;::type System::operator== </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>some</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the specified value is equal to the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#afd3b275a80034605a0034ba4e53ac85b">operator==()</a> to these values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">some</td><td>A constant reference to the value that is to be used as the first comparand </td></tr>
    <tr><td class="paramname">other</td><td>A constant reference to the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object the represented value of which is to be used as the second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the comparands are equal, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first comparand value </td></tr>
    <tr><td class="paramname">T2</td><td>The underlying type of the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object that represents the second comparand value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6619a906a7dceefbb2afd4306c6d2d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6619a906a7dceefbb2afd4306c6d2d14">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time.html">DateTime</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afedb16cc9e68db7063a5143ce6748f32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedb16cc9e68db7063a5143ce6748f32">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Chars , typename std::enable_if&lt; IsStringLiteral&lt; Chars, char_t &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">Chars &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> comparison. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Chars</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> literal type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> literal to compare. </td></tr>
    <tr><td class="paramname">right</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if strings match, false otherwise. </dd></dl>

</div>
</div>
<a id="a0719e67675788f6bebe51b66cd74a97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0719e67675788f6bebe51b66cd74a97f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , typename std::enable_if&lt; IsStringPointer&lt; T, char_t &gt;::value &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> comparison. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> pointer type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> pointer to compare. </td></tr>
    <tr><td class="paramname">right</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if strings match, false otherwise. </dd></dl>

</div>
</div>
<a id="a096d02c9f312d137d94c8cedc4dce203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096d02c9f312d137d94c8cedc4dce203">&#9670;&nbsp;</a></span>operator==() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">SharedPtr</a>&lt; <a class="el" href="class_system_1_1_object.html">Object</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> and string comparison. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to convert to string and compare. </td></tr>
    <tr><td class="paramname">right</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if object string representation equals to string, false otherwise. </dd></dl>

</div>
</div>
<a id="a7d6246aaba76b34dc6c62d3dbba08e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6246aaba76b34dc6c62d3dbba08e9b">&#9670;&nbsp;</a></span>operator==() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if string is null. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td><a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if string is null, false otherwise. </dd></dl>

</div>
</div>
<a id="a9d32c7b0dffb0727222fc5d786328fba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d32c7b0dffb0727222fc5d786328fba">&#9670;&nbsp;</a></span>operator==() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X , class Y &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; Y &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equal-compares two smart pointers. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Pointee type of first pointer. </td></tr>
    <tr><td class="paramname">Y</td><td>Pointee type of second pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>First pointer to compare. </td></tr>
    <tr><td class="paramname">y</td><td>Second pointer to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if pointers match, false otherwise. </dd></dl>

</div>
</div>
<a id="a2776c071edcbc9b58f99a48b4eb20ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2776c071edcbc9b58f99a48b4eb20ae3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool System::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if smart pointer is null. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Pointee type of pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Pointer to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if pointer is null, false otherwise. </dd></dl>

</div>
</div>
<a id="accd2be66d96eb500af3f3b05715a4f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd2be66d96eb500af3f3b05715a4f23">&#9670;&nbsp;</a></span>operator==() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_scalar&lt;T&gt;::value &amp;&amp; !std::is_pointer&lt;T&gt;::value &amp;&amp; !std::is_array&lt;T&gt;::value, bool&gt;::type System::operator== </td>
          <td>(</td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if value type object (ported C# structure, etc.) is null. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if object is null, false otherwise. </dd></dl>

</div>
</div>
<a id="af4ba2986f68f4c7580170e44a6a2bcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ba2986f68f4c7580170e44a6a2bcba">&#9670;&nbsp;</a></span>operator==() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_scalar&lt;T&gt;::value &amp;&amp; !std::is_pointer&lt;T&gt;::value &amp;&amp; !std::is_array&lt;T&gt;::value, bool&gt;::type System::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if value type object (ported C# structure, etc.) is null. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if object is null, false otherwise. </dd></dl>

</div>
</div>
<a id="a60e40d265d5c7d0079448e1ae0c46513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e40d265d5c7d0079448e1ae0c46513">&#9670;&nbsp;</a></span>operator>() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa638f787595c8beab6ddbf3dc96573fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa638f787595c8beab6ddbf3dc96573fd">&#9670;&nbsp;</a></span>operator>() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a981b208009ae96e5f0ca5348ce939ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981b208009ae96e5f0ca5348ce939ee2">&#9670;&nbsp;</a></span>operator>() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, bool&gt;::type System::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always returns false. </p>

</div>
</div>
<a id="aa4ef10e6e075a236b8d8c5cfc7febdac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ef10e6e075a236b8d8c5cfc7febdac">&#9670;&nbsp;</a></span>operator>() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T1&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T2&gt;::value, bool&gt;::type System::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>some</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the specified value is greater than the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#a970cf4b21e945ee63aecc37362673e94">operator&gt;()</a> to these values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">some</td><td>A constant reference to the value that is to be used as the first comparand </td></tr>
    <tr><td class="paramname">other</td><td>A constant reference to the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object the represented value of which is to be used as the second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first comparand is greater than the second comparand, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first comparand value </td></tr>
    <tr><td class="paramname">T2</td><td>The underlying type of the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object that represents the second comparand value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a970cf4b21e945ee63aecc37362673e94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970cf4b21e945ee63aecc37362673e94">&#9670;&nbsp;</a></span>operator>() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time.html">DateTime</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e1e2117453263abf9df3fded9992090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1e2117453263abf9df3fded9992090">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a677055ddf9f7b5c6c74dff7cdfde7ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677055ddf9f7b5c6c74dff7cdfde7ee5">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5044c939308984b2f47f780966b80d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5044c939308984b2f47f780966b80d06">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T&gt;::value, bool&gt;::type System::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Always returns false. </p>

</div>
</div>
<a id="ad5290947dac08645b8d2b0ebf5888bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5290947dac08645b8d2b0ebf5888bab">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T1&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_nullable.html">IsNullable</a>&lt;T2&gt;::value, bool&gt;::type System::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>some</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines if the specified value is greater or equal to the value represented by the specified <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object by applying <a class="el" href="namespace_system.html#af3f0d62782434e0f9ff2b626c18d454f">operator&gt;=()</a> to these values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">some</td><td>A constant reference to the value that is to be used as the first comparand </td></tr>
    <tr><td class="paramname">other</td><td>A constant reference to the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object the represented value of which is to be used as the second comparand </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the first comparand is greater or equal than the second comparand, otherwise - false </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1</td><td>The type of the first comparand value </td></tr>
    <tr><td class="paramname">T2</td><td>The underlying type of the <a class="el" href="class_system_1_1_nullable.html" title="Forward declaration. ">Nullable</a> object that represents the second comparand value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af3f0d62782434e0f9ff2b626c18d454f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f0d62782434e0f9ff2b626c18d454f">&#9670;&nbsp;</a></span>operator>=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool System::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time.html">DateTime</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ef7599970c5d491c14238e60e00bf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ef7599970c5d491c14238e60e00bf12">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::istream&amp; System::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a string from the input streamusing UTF-8 encoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An input stream object (instantiation of <code>basic_ostream</code> with <code>char</code>). </td></tr>
    <tr><td class="paramname">str</td><td>A string to read from the input stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An input stream from which the string was extracted. </dd></dl>

</div>
</div>
<a id="affc19a4c97b934575d3edf13bc0a00df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc19a4c97b934575d3edf13bc0a00df">&#9670;&nbsp;</a></span>operator>>() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API std::wistream&amp; System::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::wistream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_system_1_1_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets a string from the input stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>An input stream object (instantiation of <code>basic_ostream</code> with <code>wchar_t</code>). </td></tr>
    <tr><td class="paramname">str</td><td>A string to read from the input stream. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An input stream from which the string was extracted. </dd></dl>

</div>
</div>
<a id="a199679e3b4ba5f4e36c68d35a7769284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199679e3b4ba5f4e36c68d35a7769284">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[1/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="a0df6e5667bbf2bafbbef12e90d27d5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df6e5667bbf2bafbbef12e90d27d5d8">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[2/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_guid.html">Guid</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="a89a04801e60c2bd7d465da0fe4b75d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a04801e60c2bd7d465da0fe4b75d17">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[3/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const Details_Exception &amp;&#160;</td>
          <td class="paramname"><em>exception</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="a38333e5c02e050f0bbd4db2ab73794c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38333e5c02e050f0bbd4db2ab73794c2">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[4/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_exception_wrapper.html">ExceptionWrapper</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>exception_wrapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="a008e02e26c0f9eefe6c4fde5afbd54ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008e02e26c0f9eefe6c4fde5afbd54ae">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[5/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time_offset.html">DateTimeOffset</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="aea7ccc8e0ae73f2304c7ea8886287c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7ccc8e0ae73f2304c7ea8886287c8e">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[6/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_time_span.html">TimeSpan</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="aef73dcfe21643d817a8431d20723bc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef73dcfe21643d817a8431d20723bc69">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[7/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_decimal.html">Decimal</a> &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the value represented by the specified object to the specified output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td>The <a class="el" href="class_system_1_1_decimal.html" title="Represents a decimal number. This type should be allocated on stack and passed to functions by value ...">Decimal</a> object to print to the stream </td></tr>
    <tr><td class="paramname">os</td><td>The stream to print the specified object to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0896582818b18d4f140204d944d56ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0896582818b18d4f140204d944d56ad8">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[8/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_date_time.html">DateTime</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="a46a54af53bea429541e870b5ecc470e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a54af53bea429541e870b5ecc470e7">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[9/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_nullable.html">Nullable</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="ad956930000f648fb745a10baa84813a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad956930000f648fb745a10baa84813a7">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[10/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_object.html">System::Object</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="a28a93b53e5ec828a454b812900cfe8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a93b53e5ec828a454b812900cfe8d9">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[11/13]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ASPOSECPP_SHARED_API void System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_string.html">System::String</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints string to ostream. Mostly used for debug. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>to print. </td></tr>
    <tr><td class="paramname">os</td><td>target ostream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebb3acae8eccc54f13094fe930734eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb3acae8eccc54f13094fe930734eb3">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[12/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;detail::has_print_to_function&lt;T&gt;::value, void&gt; System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="acced940a0e9f18e6e92757a45f20a569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acced940a0e9f18e6e92757a45f20a569">&#9670;&nbsp;</a></span>PrintTo() <span class="overload">[13/13]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!detail::has_print_to_function&lt;T&gt;::value, void&gt; System::PrintTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints value to ostream. Mostly used for debug. </p>

</div>
</div>
<a id="a1590938710c1d50a4c15c619cdb9c262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1590938710c1d50a4c15c619cdb9c262">&#9670;&nbsp;</a></span>Ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , SmartPtrMode trunkMode, unsigned int ... weakLeafs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_dynamic_weak_ptr.html">DynamicWeakPtr</a>&lt;T, trunkMode, weakLeafs...&gt;::Reference System::Ref </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_dynamic_weak_ptr.html">DynamicWeakPtr</a>&lt; T, trunkMode, weakLeafs... &gt; &amp;&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates reference to <a class="el" href="class_system_1_1_dynamic_weak_ptr.html" title="Smart pointer class which tracks pointer modes of template arguments of stored object and updates the...">DynamicWeakPtr</a> object. Used by porter when passing function arguments by reference. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Pointee type. </td></tr>
    <tr><td class="paramname">trunkMode</td><td>Mode of smart pointer itself. </td></tr>
    <tr><td class="paramname">weakLeafs</td><td>Indexes of template arguments for which SetTemplateWeakPtr method must be called. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>Smart pointer to create reference to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Smart pointer reference. </dd></dl>

</div>
</div>
<a id="ab95c00865efdd393135521535846fc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab95c00865efdd393135521535846fc81">&#9670;&nbsp;</a></span>Ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; System::Ref </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper function to acquire references to objects. Used to guarantee that <a class="el" href="class_system_1_1_dynamic_weak_ptr.html" title="Smart pointer class which tracks pointer modes of template arguments of stored object and updates the...">System::DynamicWeakPtr</a> updates referenced object after assignments. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to create reference to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to create reference to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the value passed to this function. </dd></dl>

</div>
</div>
<a id="afb7e6b3d01541b653201905fd0ccb24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7e6b3d01541b653201905fd0ccb24b">&#9670;&nbsp;</a></span>setter_decrement_wrap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T System::setter_decrement_wrap </td>
          <td>(</td>
          <td class="paramtype">T(*)()&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s pre-decrement expressions targeting class' property that has setter and getter defined, into invocation of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter free function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter free function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property before incrementing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31a0796f4d307292d67463ffd7ff50d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a0796f4d307292d67463ffd7ff50d3">&#9670;&nbsp;</a></span>setter_decrement_wrap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Host , typename HostGet , typename HostSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;HostGet, Host&gt;::value &amp;&amp; std::is_base_of&lt;HostSet, Host&gt;::value, T&gt;::type System::setter_decrement_wrap </td>
          <td>(</td>
          <td class="paramtype">Host *const&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(HostGet::*)()&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(HostSet::*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s pre-decrement expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for non-const getter). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property. </td></tr>
    <tr><td class="paramname">Host</td><td>- class of instance to be modified </td></tr>
    <tr><td class="paramname">HostGet</td><td>- Host itself, or it's base type, where property's getter is defined </td></tr>
    <tr><td class="paramname">HostSet</td><td>- Host itself, or it's base type, where property's setter is defined </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Instance to call getters and setters for. </td></tr>
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property before incrementing </dd></dl>

</div>
</div>
<a id="a1e4f22987eee2f3d63ad16e9ffd0fb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4f22987eee2f3d63ad16e9ffd0fb1d">&#9670;&nbsp;</a></span>setter_decrement_wrap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Host , typename HostConstGet , typename HostSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;HostConstGet, Host&gt;::value &amp;&amp; std::is_base_of&lt;HostSet, Host&gt;::value, T&gt;::type System::setter_decrement_wrap </td>
          <td>(</td>
          <td class="paramtype">Host *const&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(HostConstGet::*)() const&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(HostSet::*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s pre-decrement expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for const getter). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property. </td></tr>
    <tr><td class="paramname">Host</td><td>- class of instance to be modified </td></tr>
    <tr><td class="paramname">HostConstGet</td><td>- Host itself, or it's base type, where property's getter is defined </td></tr>
    <tr><td class="paramname">HostSet</td><td>- Host itself, or it's base type, where property's setter is defined </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Instance to call getters and setters for. </td></tr>
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property before incrementing </dd></dl>

</div>
</div>
<a id="aa831bd44fb54318e784fcc8700c6bf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa831bd44fb54318e784fcc8700c6bf93">&#9670;&nbsp;</a></span>setter_increment_wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T System::setter_increment_wrap </td>
          <td>(</td>
          <td class="paramtype">T(*)()&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s increment expressions targeting class' property that has setter and getter defined, into invocation of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter free function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter free function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incremented value of the property </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add748986ad4492919ed9429588ace08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add748986ad4492919ed9429588ace08f">&#9670;&nbsp;</a></span>setter_increment_wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Host , typename HostGet , typename HostSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_base_of&lt; HostGet, Host &gt;::value &amp;&amp;std::is_base_of&lt; HostSet, Host &gt;::value, T &gt;::type System::setter_increment_wrap </td>
          <td>(</td>
          <td class="paramtype">Host *const&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(HostGet::*)()&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(HostSet::*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s increment expressions targeting class' property that has setter and getter defined, into invocation of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>A pointer to an object whose property is to be incremented </td></tr>
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter method </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The incremented value of the property </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property </td></tr>
    <tr><td class="paramname">Host</td><td>- class of instance to be modified </td></tr>
    <tr><td class="paramname">HostGet</td><td>- Host itself, or it's base type, where property's getter is defined </td></tr>
    <tr><td class="paramname">HostSet</td><td>- Host itself, or it's base type, where property's setter is defined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad549475f4530f5927b98805bf84fa43e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad549475f4530f5927b98805bf84fa43e">&#9670;&nbsp;</a></span>setter_post_decrement_wrap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T System::setter_post_decrement_wrap </td>
          <td>(</td>
          <td class="paramtype">T(*)()&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s post-decrement expressions targeting class' property that has setter and getter defined, into invocation of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter free function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter free function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property before incrementing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aad7208b97f8a19c9adda23f440ef03d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7208b97f8a19c9adda23f440ef03d1">&#9670;&nbsp;</a></span>setter_post_decrement_wrap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Host , typename HostGet , typename HostSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;HostGet, Host&gt;::value &amp;&amp; std::is_base_of&lt;HostSet, Host&gt;::value, T&gt;::type System::setter_post_decrement_wrap </td>
          <td>(</td>
          <td class="paramtype">Host *const&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(HostGet::*)()&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(HostSet::*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s post-decrement expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for non-const getter). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property. </td></tr>
    <tr><td class="paramname">Host</td><td>- class of instance to be modified </td></tr>
    <tr><td class="paramname">HostGet</td><td>- Host itself, or it's base type, where property's getter is defined </td></tr>
    <tr><td class="paramname">HostSet</td><td>- Host itself, or it's base type, where property's setter is defined </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Instance to call getters and setters for. </td></tr>
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property before incrementing </dd></dl>

</div>
</div>
<a id="a41dbedddc50a44853137fc3692bd9bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dbedddc50a44853137fc3692bd9bf3">&#9670;&nbsp;</a></span>setter_post_decrement_wrap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Host , typename HostConstGet , typename HostSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;HostConstGet, Host&gt;::value &amp;&amp; std::is_base_of&lt;HostSet, Host&gt;::value, T&gt;::type System::setter_post_decrement_wrap </td>
          <td>(</td>
          <td class="paramtype">Host *const&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(HostConstGet::*)() const&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(HostSet::*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s post-decrement expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for const getter). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property. </td></tr>
    <tr><td class="paramname">Host</td><td>- class of instance to be modified </td></tr>
    <tr><td class="paramname">HostConstGet</td><td>- Host itself, or it's base type, where property's getter is defined </td></tr>
    <tr><td class="paramname">HostSet</td><td>- Host itself, or it's base type, where property's setter is defined </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Instance to call getters and setters for. </td></tr>
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property before incrementing </dd></dl>

</div>
</div>
<a id="a46e340207f6853878e1555ea02f6f3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e340207f6853878e1555ea02f6f3be">&#9670;&nbsp;</a></span>setter_post_increment_wrap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T System::setter_post_increment_wrap </td>
          <td>(</td>
          <td class="paramtype">T(*)()&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s post-increment expressions targeting class' property that has setter and getter defined, into invocation of this function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter free function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter free function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property before incrementing </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1de6b22fbee5ee9e78e805f0f8566ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de6b22fbee5ee9e78e805f0f8566ff8">&#9670;&nbsp;</a></span>setter_post_increment_wrap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Host , typename HostGet , typename HostSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;HostGet, Host&gt;::value &amp;&amp; std::is_base_of&lt;HostSet, Host&gt;::value, T&gt;::type System::setter_post_increment_wrap </td>
          <td>(</td>
          <td class="paramtype">Host *const&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(HostGet::*)()&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(HostSet::*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s post-increment expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for non-const getter). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property. </td></tr>
    <tr><td class="paramname">Host</td><td>- class of instance to be modified </td></tr>
    <tr><td class="paramname">HostGet</td><td>- Host itself, or it's base type, where property's getter is defined </td></tr>
    <tr><td class="paramname">HostSet</td><td>- Host itself, or it's base type, where property's setter is defined </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Instance to call getters and setters for. </td></tr>
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property before incrementing </dd></dl>

</div>
</div>
<a id="a1893f3ad5cded8e7d64c564f8423bcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1893f3ad5cded8e7d64c564f8423bcca">&#9670;&nbsp;</a></span>setter_post_increment_wrap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Host , typename HostConstGet , typename HostSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;HostConstGet, Host&gt;::value &amp;&amp; std::is_base_of&lt;HostSet, Host&gt;::value, T&gt;::type System::setter_post_increment_wrap </td>
          <td>(</td>
          <td class="paramtype">Host *const&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(HostConstGet::*)() const&#160;</td>
          <td class="paramname"><em>pGetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(HostSet::*)(T)&#160;</td>
          <td class="paramname"><em>pSetter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Porter translates C#'s post-increment expressions targeting instance's property that has setter and getter defined, into invocation of this function (overload for const getter). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of the property. </td></tr>
    <tr><td class="paramname">Host</td><td>- class of instance to be modified </td></tr>
    <tr><td class="paramname">HostConstGet</td><td>- Host itself, or it's base type, where property's getter is defined </td></tr>
    <tr><td class="paramname">HostSet</td><td>- Host itself, or it's base type, where property's setter is defined </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Instance to call getters and setters for. </td></tr>
    <tr><td class="paramname">pGetter</td><td>Function pointer pointing to the property's getter function </td></tr>
    <tr><td class="paramname">pSetter</td><td>Function pointer pointing to the property's setter function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the property before incrementing </dd></dl>

</div>
</div>
<a id="ae01a209cda2bf0448f60b05f5430b489"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01a209cda2bf0448f60b05f5430b489">&#9670;&nbsp;</a></span>setter_wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T System::setter_wrap </td>
          <td>(</td>
          <td class="paramtype">void(*)(T2)&#160;</td>
          <td class="paramname"><em>pSetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for static setter functions with type conversion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type. </td></tr>
    <tr><td class="paramname">T2</td><td>Type expected by setter function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSetter</td><td>Static setter function reference. </td></tr>
    <tr><td class="paramname">value</td><td>Value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set value. </dd></dl>

</div>
</div>
<a id="a90aaef5031be74f44d35fba5420def3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aaef5031be74f44d35fba5420def3d">&#9670;&nbsp;</a></span>setter_wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , typename Host , typename HostSet &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_base_of&lt;HostSet, Host&gt;::value, T&gt;::type System::setter_wrap </td>
          <td>(</td>
          <td class="paramtype">Host *const&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(HostSet::*)(T2)&#160;</td>
          <td class="paramname"><em>pSetter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload for instance setter functions with type conversion. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Value type. </td></tr>
    <tr><td class="paramname">T2</td><td>Type expected by setter function. </td></tr>
    <tr><td class="paramname">Host</td><td>Instance type. </td></tr>
    <tr><td class="paramname">HostSet</td><td>- Host itself, or it's base type, where property's setter is defined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> to call setter function for. </td></tr>
    <tr><td class="paramname">pSetter</td><td>Setter function reference. </td></tr>
    <tr><td class="paramname">value</td><td>Value to set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>set value. </dd></dl>

</div>
</div>
<a id="ae18d1f9ebb008487e571a171489df598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18d1f9ebb008487e571a171489df598">&#9670;&nbsp;</a></span>static_holder()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; System::static_holder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Singleton accessor function. </p>
<dl class="section return"><dt>Returns</dt><dd>Singleton reference. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Singleton type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72f09a7006b50f64ee0ce133b803d3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f09a7006b50f64ee0ce133b803d3cd">&#9670;&nbsp;</a></span>static_pointer_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Y , class X &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt;Y&gt; System::static_pointer_cast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; X &gt; const &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Casts smart pointers using static_cast. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">X</td><td>Source pointer pointee type. </td></tr>
    <tr><td class="paramname">Y</td><td>Target pointer pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer after cast. </dd></dl>

</div>
</div>
<a id="aec55c703d291b84ff94ef32ac954ed14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec55c703d291b84ff94ef32ac954ed14">&#9670;&nbsp;</a></span>StaticCast() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type&gt;::type System::StaticCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs static cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if cast is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abefcaf34229820d8e970fb3ffa1861fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefcaf34229820d8e970fb3ffa1861fa">&#9670;&nbsp;</a></span>StaticCast() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type System::StaticCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; TFrom &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs static cast on <a class="el" href="class_system_1_1_weak_ptr.html" title="Subclass of System::SmartPtr which sets itself to weak mode at construction. Please note that this cl...">WeakPtr</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if cast is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a589ebb1ed606af7df2d9f9f0c95b53c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589ebb1ed606af7df2d9f9f0c95b53c5">&#9670;&nbsp;</a></span>StaticCast() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type System::StaticCast </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs static cast of null objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>nullptr. </dd></dl>

</div>
</div>
<a id="abe7a977959b1205723c820c210eff2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7a977959b1205723c820c210eff2ed">&#9670;&nbsp;</a></span>StaticCast() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_arithmetic&lt;TFrom&gt;::value, TTo&gt;::type System::StaticCast </td>
          <td>(</td>
          <td class="paramtype">TFrom&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization for arithmetic types. </p>

</div>
</div>
<a id="a3041159c5f29dfe490e239c06ae8d09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3041159c5f29dfe490e239c06ae8d09c">&#9670;&nbsp;</a></span>StaticCast() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;TTo, <a class="el" href="class_system_1_1_string.html">System::String</a>&gt;::value, TTo&gt;::type System::StaticCast </td>
          <td>(</td>
          <td class="paramtype">TTo&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process cast from <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a> to <a class="el" href="class_system_1_1_string.html" title="String class used across the library. Is a substitute for C# System.String when porting code...">String</a>. </p>

</div>
</div>
<a id="a4945f68826fff476a7fb5c167b46974f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4945f68826fff476a7fb5c167b46974f">&#9670;&nbsp;</a></span>StaticCast() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_arithmetic&lt;TFrom&gt;::value, TTo&gt;::type System::StaticCast </td>
          <td>(</td>
          <td class="paramtype">const TFrom *&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization for arithmetic types. </p>

</div>
</div>
<a id="a79d7f4cb9071e7a0e39e5250bd9dc3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d7f4cb9071e7a0e39e5250bd9dc3ac">&#9670;&nbsp;</a></span>StaticCast() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!std::is_same&lt;TFrom, <a class="el" href="class_system_1_1_string.html">System::String</a>&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TFrom&gt;::value &amp;&amp; !<a class="el" href="struct_system_1_1_is_smart_ptr.html">IsSmartPtr</a>&lt;TFrom&gt;::value &amp;&amp; !std::is_arithmetic&lt;TFrom&gt;::value, TTo&gt;::type System::StaticCast </td>
          <td>(</td>
          <td class="paramtype">TFrom &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs static cast on non-pointer objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if cast is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af9fd54b2151d6b479accb2707e7c1c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fd54b2151d6b479accb2707e7c1c32">&#9670;&nbsp;</a></span>StaticCast() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TFrom&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value &amp;&amp; (std::is_convertible&lt;TTo, TFrom&gt;::value || std::is_base_of&lt;TTo, TFrom&gt;::value), TTo&gt;::type System::StaticCast </td>
          <td>(</td>
          <td class="paramtype">const TFrom &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs static cast on Exception objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target Exception type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source Exception type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if cast is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a839f0309200ae1d6a75c098a05938495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a839f0309200ae1d6a75c098a05938495">&#9670;&nbsp;</a></span>StaticCast() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;<a class="el" href="class_system_1_1_object.html">System::Object</a>, TFrom&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, TTo&gt;::type System::StaticCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs static cast on Objects to Exception objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target Exception type. </td></tr>
    <tr><td class="paramname">TFrom</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">InvalidCastException</td><td>if cast is not allowed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44c63c8b88ca46577ccd74f712ab1767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c63c8b88ca46577ccd74f712ab1767">&#9670;&nbsp;</a></span>StaticCast_noexcept() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, typename <a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type&gt;::type System::StaticCast_noexcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs static cast on <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a5e6b0c5f1b7879f547e50485f78e3935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6b0c5f1b7879f547e50485f78e3935">&#9670;&nbsp;</a></span>StaticCast_noexcept() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_system_1_1_cast_result.html">CastResult</a>&lt;TTo&gt;::type System::StaticCast_noexcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_weak_ptr.html">WeakPtr</a>&lt; TFrom &gt; const &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs static cast on <a class="el" href="class_system_1_1_weak_ptr.html" title="Subclass of System::SmartPtr which sets itself to weak mode at construction. Please note that this cl...">WeakPtr</a> objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target pointee type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source pointee type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a5255975378a13bafcd607c37b1569162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5255975378a13bafcd607c37b1569162">&#9670;&nbsp;</a></span>StaticCast_noexcept() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TFrom&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value &amp;&amp; (std::is_convertible&lt;TTo, TFrom&gt;::value || std::is_base_of&lt;TTo, TFrom&gt;::value), TTo&gt;::type System::StaticCast_noexcept </td>
          <td>(</td>
          <td class="paramtype">const TFrom &amp;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs static cast on Exception objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target Exception type. </td></tr>
    <tr><td class="paramname">TFrom</td><td>Source Exception type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a50c0694261e19a770349a5c430f84762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c0694261e19a770349a5c430f84762">&#9670;&nbsp;</a></span>StaticCast_noexcept() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TTo , typename TFrom &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;std::is_same&lt;<a class="el" href="class_system_1_1_object.html">System::Object</a>, TFrom&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_exception_wrapper.html">IsExceptionWrapper</a>&lt;TTo&gt;::value, TTo&gt;::type System::StaticCast_noexcept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_system_1_1_smart_ptr.html">SmartPtr</a>&lt; TFrom &gt;&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs static cast on Objects to Exception objects. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TTo</td><td>Target Exception type. </td></tr>
    <tr><td class="paramname">TFrom</td><td><a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a> type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Source pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Cast result if cast is allowed or nullptr otherwise. </dd></dl>

</div>
</div>
<a id="a389d03ff2cccd6c3ff6ee36d81a34bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389d03ff2cccd6c3ff6ee36d81a34bdf">&#9670;&nbsp;</a></span>StaticCastArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;From&gt;::value, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt;<a class="el" href="class_system_1_1_array.html">System::Array</a>&lt;To&gt; &gt; &gt; System::StaticCastArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">System::Array</a>&lt; From &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the static casting of elements of the specified array to different type. Override for cases then From is <a class="el" href="class_system_1_1_smart_ptr.html" title="Pointer class to wrap types being allocated on heap. Use it to manage memory for classes inheriting O...">SmartPtr</a> obj. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Shared pointer to the array containing the elements to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new array containing elements of type <code>To</code> equivalent to the elements of <code>from</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to cast the elements of the specified array to </td></tr>
    <tr><td class="paramname">From</td><td>The type of elements of the elements of the arry elements of which to cast </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa2c59a25554d0129ba9c9d5111f9b6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c59a25554d0129ba9c9d5111f9b6ff">&#9670;&nbsp;</a></span>StaticCastArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;!<a class="el" href="struct_system_1_1_is_smart_ptr.html">System::IsSmartPtr</a>&lt;From&gt;::value &amp;&amp; <a class="el" href="struct_system_1_1_is_boxable.html">System::IsBoxable</a>&lt;From&gt;::value &amp;&amp; std::is_same&lt;To, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt;<a class="el" href="class_system_1_1_object.html">Object</a>&gt; &gt;::value, <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt;<a class="el" href="class_system_1_1_array.html">System::Array</a>&lt;To&gt; &gt; &gt; System::StaticCastArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_system.html#a6b77ccd8c49df28c153be0462cdfdf49">System::SharedPtr</a>&lt; <a class="el" href="class_system_1_1_array.html">System::Array</a>&lt; From &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the static casting of elements of the specified array to different type. Override for cases then From is Boxable and To is <a class="el" href="class_system_1_1_object.html" title="Base class that enables using methods available for System.Object class in C#. All non-trivial classe...">Object</a>[]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>Shared pointer to the array containing the elements to cast </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a new array containing elements of type <code>To</code> equivalent to the elements of <code>from</code> </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">To</td><td>The type to cast the elements of the specified array to </td></tr>
    <tr><td class="paramname">From</td><td>The type of elements of the elements of the arry elements of which to cast </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab6edd195298e0176863c4f759c970698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6edd195298e0176863c4f759c970698">&#9670;&nbsp;</a></span>Array</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">class ASPOSECPP_SHARED_CLASS <a class="el" href="class_system_1_1_array.html">System::Array</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a14faf88f23e48915859360609eb1a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a14faf88f23e48915859360609eb1a3">&#9670;&nbsp;</a></span>Ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(Ref(std::declval&lt;T&amp;&gt;())) System::Ref(const std::reference_wrapper&lt; T &gt; &amp;wrapper)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper to make sure Ref(std::ref(DynamicWeakPtr)) works. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Referenced type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrapper</td><td>std wrapper to unwrap. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference type defined in <a class="el" href="namespace_system.html">System</a>:: rather than in std. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_system.html">System</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
